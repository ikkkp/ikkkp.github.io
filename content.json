{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"關於我","text":"写作，是内心的独白“写作，是内心的独白，是灵魂的流淌。” - 王小波 我是ikkkp。 其实想建一个属于自己的个人网站并在上面写一些自己喜欢的东西也不是一天两天了。 我写作的原因，或许并不复杂。文字，是我与世界沟通的桥梁，是我思考、感受、触摸生活的工具。 而写作，是我在孤独中寻找陪伴的方式，是我在迷茫中找到方向的灯塔。 文字是生活的注解，写作是内心的显现。 在这个喧嚣的世界里，写作替我找到了一份宁静。 写作，让我能够更清晰地思考问题，更深刻地理解自己。 每当我将思绪转化为文字，就像是给心灵进行了一次洗礼，让我更加了解自己的内心世界。写作，也是我与他人交流的方式，通过文字，我能够传递我的思想、分享我的经验，与他人建立起深厚的情感纽带。 在文字的海洋里，我们可以不受拘束地航行，探寻无限的可能。","link":"/abouts/index.html"},{"title":"Archives","text":"","link":"/archive/index.html"},{"title":"推薦閱讀","text":"","link":"/recommend/index.html"}],"posts":[{"title":"301/302-重定向","text":"前言当你在网站上进行重定向设置时，特别是在以下两种情况下，可能会遇到问题： 从HTTP到HTTPS的重定向： 假设你配置了SSL证书，将网站从HTTP升级到HTTPS。 如果在这个过程中出现了问题，导致网站无法正常访问，你可能会想撤销重定向，回到HTTP版本。然而，问题在于，一旦你使用了301永久性重定向，浏览器会把这个重定向信息保存下来。即使你在服务器上取消了重定向，用户的浏览器依然会强制将他们重定向到HTTPS版本，无法再访问HTTP版本。 更改网站域名的重定向： 当你将网站从一个域名（比如old-domain.com）迁移到另一个域名（比如new-domain.com），你可能会使用301永久性重定向，以便搜索引擎和浏览器知道网站已经永久地移动到了新的域名。 但如果在这个过程中出现了问题，你可能希望撤销重定向，使用户能够再次访问旧域名。然而，由于301重定向被浏览器硬缓存，用户将被永久性地重定向到新域名，无法再访问旧域名。 为了避免这种情况，建议在测试确保一切正常后，一开始使用302临时性重定向，而不是301永久性重定向。302重定向不会被浏览器永久性地缓存，这意味着如果需要，你可以随时撤销重定向，而用户不会被永久性地锁定在新的网址上。这样可以避免用户需要手动清除浏览器缓存的繁琐步骤，提供更好的用户体验。 301重定向：意味着资源（页面）被永久性地移动到了一个新的位置。客户端&#x2F;浏览器不应再尝试请求原始位置，而应该从现在开始使用新的位置。 302重定向：意味着资源暂时位于其他地方，客户端&#x2F;浏览器应继续请求原始URL。 301是永久性重定向。即使你从服务器移除了重定向，你的浏览器仍然会将资源永久性地重定向到新的域名或HTTPS，因为它们被硬缓存。 所以，302不会被浏览器硬缓存，如果你从服务器（网站）移除了重定向，你就能够访问旧版本。 清除301&#x2F;302重定向缓存通常涉及清除浏览器缓存或者操作系统的DNS缓存。下面是如何在不同平台上做的说明： 清除浏览器缓存（适用于Windows、macOS、Linux）Google Chrome： 打开Chrome浏览器。 点击右上角的三个垂直点，选择“更多工具”。 选择“清除浏览数据”。 在弹出的窗口中，选择“高级”选项卡。 选择“所有时间”作为时间范围。 勾选“缓存图像和文件”选项。 点击“清除数据”按钮。 Mozilla Firefox： 打开Firefox浏览器。 点击右上角的三条水平线，选择“隐私与安全”。 在“Cookie和站点数据”部分，点击“清除数据”。 确保勾选了“缓存”选项。 点击“清除”。 Microsoft Edge： 打开Edge浏览器。 点击右上角的三个水平点，选择“设置”。 滚动至底部，点击“查看高级设置”。 在“隐私与服务”部分，点击“清除浏览数据”。 勾选“缓存图像和文件”选项。 点击“清除”按钮。 清除操作系统的DNS缓存（适用于Windows、macOS）Windows： 打开命令提示符（在开始菜单中搜索“cmd”并打开）。 输入以下命令并按下回车键：ipconfig &#x2F;flushdns macOS： 打开终端（在应用程序 &gt; 实用工具文件夹中找到）。 输入以下命令并按下回车键：sudo dscacheutil -flushcache 然后输入管理员密码并再次按下回车键。 请注意，清除浏览器缓存可能会导致您在网站上的登录状态丢失，所以请确保您已经备份了重要的信息，以防需要重新登录网站。","link":"/2023/10/28/301-302-Redirection/"},{"title":"Webpack 性能优化-1","text":"前言先来说说为什么要优化？当然如果你的项目很小，构建很快，其实不需要特别关注性能方面的问题。 但是随着项目涉及到的页面越来越多，功能和业务代码也会越来越多，相应的 webpack 的构建时间也会越来越久，这个时候我们就不得不考虑性能优化的事情了。 webpack 的性能优化较多，我们考虑从两方面入手：优化一：打包后的结果，上线时的性能优化。（比如分包处理、减小包体积、CDN服务器等）优化二：优化打包速度，开发或者构建时优化打包速度。（比如 exclude 、cache-loader等） 因为这个上线时的性能是直接影响到用户使用体验的，而构建时间与我们的日常开发是密切相关，当我们本地开发启动 devServer 或者 build 的时候，如果时间过长，会大大降低我们的工作效率。 性能优化 - 代码分离代码分离（Code Splitting）是 webpack 一个非常重要的特性： 它主要的目的是将代码分离到不同的 bundle 中，之后我们可以按需加载，或者并行加载这些文件；比如默认情况下，所有的 JavaScript 代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度；代码分离可以分出更小的 bundle ，以及控制资源加载优先级，提供代码的加载性能； Webpack中常用的代码分离有三种： 入口起点：使用entry配置手动分离代码； 防止重复：使用Entry Dependencies或者SplitChunksPlugin去重和分离代码； 动态导入：通过模块的内联函数调用来分离代码； 入口起点优化-Entry Dependencies(入口依赖)当项目拥有多个入口点（entry points）时，可能会遇到一些重复依赖的问题。某些模块可能在多个入口点中被引用，导致这些模块被重复打包，增加了最终输出文件的体积。dependon-shared模块解决重复依赖 module.exports = &#123; entry: &#123; page1: &#123; import: './src/page1.js', dependOn: 'shared', &#125;, page2: &#123; import: './src/page2.js', dependOn: 'shared', &#125;, shared: './src/shared.js', &#125;, output: &#123; filename: '[name].bundle.js', path: __dirname + '/dist', &#125;, &#125;; 动态导入(dynamic import)动态导入是一种在Webpack中实现按需加载（Lazy Loading）的技术，允许在运行时异步加载模块，而不是在应用初始化时就把所有模块打包到一个大文件中。可以提高应用的初始加载速度，并且减小了初始包的体积。 const path = require('path'); module.exports = &#123; entry: &#123; main: './src/index.js', &#125;, output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist'), publicPath: '/', &#125;, module: &#123; rules: [ // 添加你的Loader规则 ], &#125;, optimization: &#123; splitChunks: &#123; chunks: 'all', &#125;, &#125;, &#125;; 在上述配置中，通过 optimization.splitChunks 进行代码分割，它的 chunks: &#39;all&#39; 选项表示对所有模块进行代码分割。 然后，在代码中使用 import() 函数进行动态导入： // 在需要的地方使用动态导入 const loadModule = () => import('./Module'); loadModule().then(module => &#123; // 使用加载的模块 &#125;); Webpack会将使用 import() 函数引入的模块进行代码分割，生成单独的文件。在运行时，这些文件会在需要的时候异步加载。 自定义分包-SplitChunks分包（code splitting）是一种优化策略，它允许将代码分割成小块，使得应用在加载时能够更快地显示内容。 Webpack提供了多种分包的模式，其中一种是使用SplitChunksPlugin插件来实现的，这个模式叫做splitChunks。 module.exports = &#123; // ...其他配置 optimization: &#123; splitChunks: &#123; chunks: 'all', minSize: 30000, // 模块的最小体积 minChunks: 1, // 模块的最小被引用次数 maxAsyncRequests: 5, // 按需加载时的最大并行请求数 maxInitialRequests: 3, // 入口点的最大并行请求数 automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10, reuseExistingChunk: true, &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true, &#125;, &#125;, &#125;, &#125;, &#125;; webpack-split-chunks-plugin 性能优化-CDNCDN称之为内容分发网络（Content Delivery Network或Content Distribution Network，缩写：CDN）， 它是指通过相互连接的网络系统，利用最靠近每个用户的服务器； 更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户； 来提供高性能、可扩展性及低成本的网络内容传递给用户； 在开发中，我们使用CDN主要是两种方式： 打包的所有静态资源，放到CDN服务器， 用户所有资源都是通过CDN服务器加载的； 一些第三方资源放到CDN服务器上； 使用CDN（Content Delivery Network，内容分发网络）是一种非常有效的性能优化策略，特别是在Webpack中。CDN可以加速网站的加载速度，减轻服务器负担，并提高用户体验。以下是如何在Webpack中配置和使用CDN的方法： 将第三方库引入CDN将你的项目中用到的第三方库（例如React、Vue、jQuery等）引入CDN。可以选择在HTML文件中直接引入CDN链接： &lt;script src=\"https://cdn.jsdelivr.net/npm/react@版本号/dist/react.min.js\">&lt;/script> &lt;script src=\"https://cdn.jsdelivr.net/npm/react-dom@版本号/dist/react-dom.min.js\">&lt;/script> 在Webpack中配置externals在Webpack的配置中使用externals字段，告诉Webpack哪些模块是外部引入的，不需要打包。 module.exports = &#123; // ...其他配置 externals: &#123; react: 'React', 'react-dom': 'ReactDOM', &#125;, &#125;; 然后在HTML文件中通过script标签引入CDN： &lt;script src=\"https://cdn.jsdelivr.net/npm/react@版本号/dist/react.min.js\">&lt;/script> &lt;script src=\"https://cdn.jsdelivr.net/npm/react-dom@版本号/dist/react-dom.min.js\">&lt;/script> 配置CDN的publicPath在Webpack的output字段中配置publicPath，指定在引入资源时使用的URL前缀，通常设置为CDN的地址： module.exports = &#123; // ...其他配置 output: &#123; // ...其他output配置 publicPath: 'https://cdn.example.com/', &#125;, &#125;; 这样在Webpack构建时，所有的资源引用路径都会加上CDN的地址前缀。 性能优化-提取css文件将CSS文件从JavaScript打包文件中提取出来是一种常见的性能优化策略。这样做的好处是可以减小JavaScript文件的体积，加快页面加载速度，并且使浏览器能够并行下载CSS和JavaScript文件，提高加载性能。在Webpack中，你可以使用mini-css-extract-plugin插件来实现CSS文件的提取。 配置Webpack 在Webpack配置文件中引入mini-css-extract-plugin插件，然后配置module.rules来处理CSS文件。 const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = &#123; // ...其他配置 module: &#123; rules: [ &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', // 可以加入其他的CSS处理loader，比如postcss-loader和sass-loader ], &#125;, ], &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: 'styles.css', // 提取出的CSS文件的文件名 &#125;), ], &#125;; 引入CSS文件 在JavaScript文件或者入口文件中引入CSS文件： import './styles.css'; 或者在HTML文件中使用link标签引入提取出来的CSS文件： &lt;link rel=\"stylesheet\" href=\"styles.css\"> 性能优化-打包文件命名(Hash,ContentHash,ChunkHash)在Webpack中，打包文件的命名是一个重要的性能优化策略。合适的命名方案可以确保浏览器能够正确地缓存文件，避免不必要的网络请求，提高应用的加载速度。以下是三种常见的打包文件命名方式：Hash、ContentHash 和 ChunkHash。 Hash（哈希）Hash 是根据文件内容生成的哈希值，当文件内容发生改变时，其对应的 Hash 值也会改变。在Webpack中，可以使用 [hash] 占位符来表示 Hash 值。 output: &#123; filename: 'bundle.[hash].js', &#125; ContentHash（内容哈希）ContentHash 是根据文件内容生成的哈希值，但是不同于 Hash 的是，ContentHash 只会受到文件内容的影响，不会受到文件名或路径等其他因素的影响。在Webpack中，可以使用 [contenthash] 占位符来表示 ContentHash 值。 output: &#123; filename: 'bundle.[contenthash].js', &#125; ChunkHash（块哈希）ChunkHash 是根据模块内容生成的哈希值，不同模块的内容不同，它们的 ChunkHash 值也会不同。在Webpack中，可以使用 [chunkhash] 占位符来表示 ChunkHash 值。 output: &#123; filename: '[name].[chunkhash].js', &#125; 性能优化-webpack实现Tree ShakingJavaScript的Tree Shaking： 对JavaScript进行Tree Shaking是源自打包工具rollup（后面我们也会讲的构建工具）； 这是因为Tree Shaking依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）； webpack2正式内置支持了ES2015模块，和检测未使用模块的能力； 在webpack4正式扩展了这个能力，并且通过 package.json的 sideEffects属性作为标记，告知webpack在编译时，哪里文 件可以安全的删除掉； webpack5中，也提供了对部分CommonJS的tree shaking的支持； commonjs-tree-shaking JS实现Tree Shakingwebpack实现Tree Shaking采用了两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的； sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用； CSS进行Tree ShakingCSS的Tree Shaking需要借助于一些其他的插件； 在早期的时候，我们使用PurifyCss插件来完成CSS的tree shaking，但是目前该库已经不再维护； 目前我们可以使用另外一个库来完成CSS的Tree Shaking：PurgeCSS，也是一个帮助我们删除未使用的CSS的工具: PurgeCss","link":"/2023/10/26/Webpack-optimization-1/"},{"title":"Webpack 性能优化-2","text":"性能优化 - JS-CSS代码压缩 Terser是一个JavaScript的解释（Parser）、Mangler（绞肉机）&#x2F;Compressor（压缩机）的工具集； 早期我们会使用 uglify-js来压缩、丑化我们的JavaScript代码，但是目前已经不再维护，并且不支持ES6+的语法； Terser是从 uglify-es fork 过来的，并且保留它原来的大部分API以及适配 uglify-es和uglify-js@3等； webpack-terser JavaScript 代码压缩Webpack 提供了terser-webpack-plugin 插件进行代码优化和压缩。 在production模式下，默认就是使用TerserPlugin来处理代码。 const TerserPlugin = require('terser-webpack-plugin'); module.exports = &#123; // 配置其他Webpack选项... optimization: &#123; minimizer: [new TerserPlugin()], &#125;, &#125;; CSS 代码压缩除了JavaScript代码，CSS代码也可以通过Webpack进行压缩。使用css-minimizer-webpack-plugin 进行压缩CSS代码。 const CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); module.exports = &#123; // 配置其他Webpack选项... optimization: &#123; minimizer: [ new CssMinimizerPlugin(), // 可以继续添加其他压缩插件... ], &#125;, &#125;; webpack实现Tree Shakingtree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。 Webpack 实现 Tree Shaking在现代的前端开发中，代码体积优化是一个关键的议题。Tree Shaking 是一种用于消除未引用代码的优化技术，它可以帮助我们剔除项目中未使用的 JavaScript 模块，从而减小打包后的文件体积。Webpack 提供了内置的支持，使得 Tree Shaking 在项目中变得非常容易实现。 开启 ES 模块化首先，确保你的 JavaScript 代码采用了 ES 模块化的方式，因为Webpack 的 Tree Shaking 功能仅对 ES 模块有效。你可以在项目中使用 import 和 export 语法来定义模块。 // math.js export function square(x) &#123; return x * x; &#125; export function cube(x) &#123; return x * x * x; &#125; Webpack 配置在 Webpack 的配置文件中，确保以下几点设置，以启用 Tree Shaking： 将 mode 设置为 &#39;production&#39;，Webpack 会自动启用相关的优化，包括 Tree Shaking。 JS实现Tree Shakingwebpack实现Tree Shaking采用了两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的； sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用； 使用usedExports实现Tree Sharking配置模式为production module.exports = &#123; mode: 'production', // ...其他配置 &#125;; 配置optimization里面的usedExports const path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), &#125;, mode: 'development', optimization: &#123; usedExports: true, &#125;, &#125;; 使用sideEffect实现Tree Sharking在package.json中设置sideEffects的值： 如果我们将sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports； 如果有一些我们希望保留，可以设置为数组； &#123; \"name\": \"your-project\", \"sideEffects\": [\"./src/some-side-effectful-file.js\"] &#125; Webpack 中的 sideEffects 解释 tree shaking 和 sideEffectssideEffects 和 usedExports（更多被认为是 tree shaking）是两种不同的优化方式。 sideEffects 更为有效 是因为它允许跳过整个模块&#x2F;文件和整个文件子树。 usedExports 依赖于 terser 去检测语句中的副作用。它是一个 JavaScript 任务而且没有像 sideEffects 一样简单直接。而且它不能跳转子树&#x2F;依赖由于细则中说副作用需要被评估。尽管导出函数能运作如常，但 React 框架的高阶函数（HOC）在这种情况下是会出问题的。 CSS实现TreeShakingCSS的Tree Shaking需要借助于一些其他的插件； 在早期的时候，我们会使用PurifyCss插件来完成CSS的tree shaking，但是目前该库已经不再维护了（最新更新也是在4年前 了）； 目前我们可以使用另外一个库来完成CSS的Tree Shaking：PurgeCSS，也是一个帮助我们删除未使用的CSS的工具； Webpack对文件压缩什么是HTTP压缩HTTP压缩是一种内置在 服务器 和 客户端 之间的，以改进传输速度和带宽利用率的方式；HTTP压缩的流程什么呢？第一步：HTTP数据在服务器发送前就已经被压缩了；（可以在webpack中完成）第二步：兼容的浏览器在向服务器发送请求时，会告知服务器自己支持哪些压缩格式；第三步：服务器在浏览器支持的压缩格式下，直接返回对应的压缩后的文件，并且在响应头中告知浏览器； 目前的流行压缩格式目前的压缩格式非常的多：compress – UNIX的“compress”程序的方法（历史性原因，不推荐大多数应用使用，应该使用gzip或deflate）；deflate – 基于deflate算法（定义于RFC 1951）的压缩，使用zlib数据格式封装；gzip – GNU zip格式（定义于RFC 1952），是目前使用比较广泛的压缩算法；br – 一种新的开源压缩算法，专为HTTP内容的编码而设计； Webpack配置文件压缩webpack中相当于是实现了HTTP压缩的第一步操作，我们可以使用CompressionPlugin。 第一步，安装CompressionPlugin： npm install compression-webpack-plugin -D 第二步，使用CompressionPlugin即可 module.exports = &#123; plugins: [ new CompressionPlugin(&#123; test: /\\.js(\\?.*)?$/i, &#125;), ], &#125;;","link":"/2023/10/27/Webpack-optimization-2/"},{"title":"輕鬆理解 Ajax 與跨來源請求","text":"前言一般來說在學習寫網頁的時候，最先碰到的會是 HTML 與 CSS，負責把版面刻出來以及美化版面，當基礎打穩之後，會開始學習 JavaScript，試著做出一點互動性的效果。而「互動」除了使用者跟瀏覽器的互動以外，別忘了還有 Client 端跟 Server 端的互動，也就是必須要學會從瀏覽器用 JavaScript 跟後端 Server 拿資料，否則你的網頁資料都只能是寫死的。 這篇的主要預設讀者是網頁前端的初學者，希望能讓本來不太理解怎麼跟 Server 交換資料或是怎麼串 APi 的讀者看完之後，能夠更了解該怎麼跟後端串接。 先從舉例開始在開始之前，我們可以先想想一個問題： 為什麼前端必須跟後端交換資料？ 其實這跟你做的網頁類型有關，假如說你今天做的是一個官方網站，很可能整個網站都是靜態的，只要 HTML 跟 CSS 就可以了，並不需要跟後端 Server 拿資料。 那我們先假設今天要做的是一個可以瀏覽現在 Twitch 實況列表的網頁好了，如下圖。 如果這個網頁不跟後端拿資料，就代表說網頁的內容都是固定的，無論什麼時候看都一樣。可是這樣的話就不對了嘛，因為這個網頁的目標是顯示出「現在有在開實況的頻道」，所以內容是會跟著改變的。 既然會跟著改變，就必須不斷的去更新資料，從 Server 那邊拿資料回來，接著在前端處理過後顯示。 已經確認有拿資料的必要性之後，就可以問自己兩個問題： 要跟誰拿資料？ 要怎麼拿資料？ 第一個問題，很明顯的就是跟 Twitch，因為 Twitch 才有你要的這些資料嘛！ 那第二個問題，要怎麼拿資料呢？就必須透過 Twitch API 了。 API什麼是 API？你可能已經聽過很多次這個名詞，但還是不知道是什麼。先來講講它的全名吧，它的全名是「Application Programming Interface」，中文翻作應用程式介面。 你可能會想說這是什麼鬼東西，怎麼中文英文我都看不懂在幹嘛。但其實這幾個字裡面，最重要的是「介面」兩個字。 介面是什麼？介面就是拿來串接用的，我舉一個例子你就知道了。 電腦上不是有一個 USB 插槽嗎？然後你只要是看到市面上有賣 USB 隨身碟的，都可以買來以後插到 USB 插槽，你的電腦就可以讀取得到。你有想過為什麼嗎？明明就是不同廠商做的東西，可是卻都可以讀得到、都可以插到 USB 插槽裡面。 因為有一項標準叫做 USB 介面，當這套標準訂出來以後，所有廠商只要按照這一套標準來開發，就可以保證能夠連接電腦跟 USB 隨身碟。 API 也是這樣，只是變成程式跟程式之間的串接。例如說今天我寫程式需要讀取檔案好了，我要怎麼讀取檔案？讀取檔案是作業系統提供的功能，因此我可以去串接「讀取檔案的 API」，就可以在我的程式裡面也使用這個功能了。 再多舉幾個例子你可能會更有感覺。 例如說今天我想要讓我的網頁能夠用 Facebook 登入，那要怎麼辦？我就要去串接「Facebook 提供的 API」，就等於說是 Facebook 向外提供給大家的一套介面、一套標準，任何想要接入 Facebook 服務的開發者們，都可以遵循著那套規範拿到自己想要的資料，這個東西就叫做 API。 或是你可能今天是一個飯店管理系統的開發者，你們公司做了一套給飯店用的 ERP，可以管理飯店的訂房狀態等等，就能知道說現在有哪些房間是空的。 而這些資料如果只有自己用太可惜了，於是公司決定把這些資料提供給大型訂房網站，在那些網站上能夠即時顯示這間飯店的房間狀況。所以就必須交換資料，你要提供一個「查詢房間情形的 API」給其他網站，讓他們能夠去串接，才能獲得這些資訊。 講到這邊，大家應該對 API 已經有一些 sense 了，我再多舉幾個例子： 我想要抓到 flickr 上面的照片，所以我要去串接 flickr 的 API Google 要開放讓其他 App 也能用 Google 登入驗證，所以 Google 要提供「Google 登入 API」 我要抓 Twitch 上面現在有哪些頻道，所以要串 Twitch API API Documentation既然已經知道 API 是什麼了，也知道要串接 API，那下一個問題就是「那要怎麼串呢？」 剛剛前面有提過檔案存取的例子，其實這個比較像是呼叫作業系統或是程式語言的函式庫提供的 Function，而這些 Function 你通常都可以在官方文件上查到更詳細的說明，例如說 Node.js 的讀取檔案： （來源：https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback） 上面就有寫說你應該呼叫哪一個 Function，應該傳入哪些參數。 API 的串接也是一樣，一定要有文件你才知道怎麼串，不然根本串不起來，因為你連要傳什麼參數都不知道。 我們可以先來看看Twitch API 文件是怎麼寫的。 裡面說明了你必須要有一個Client ID，然後 API Root 的 URL 是 https://api.twitch.tv/kraken 等等，這些都是與 API 相關的基本資訊。如果你在左側欄隨便點一個 API，會看到個別 API 的詳細資訊： 這邊就有寫說網址是什麼，你應該傳的參數是什麼等等，下面還有附上參考範例，這就是一個很完整的 API 文件。 通常在寫網頁的時候，我們都會直接講 API，但其實我們指的是 Web API，也就是透過網路來傳輸的 API。那有沒有非 Web API 呢？有，像我們前面提到的跟作業系統要讀檔的 API，就都是在本機底下執行的，沒有透過任何網路。 不過這其實也不用太在意，反正大家都習慣講 API，聽得懂就好。 現在有了 API 文件，我們就有了所有我們需要的資訊。以上面這個 Twitch 的例子來講，我們只要能夠發送 Request 到https://api.twitch.tv/kraken/games/top?client_id=xxx，Twitch 就會傳回目前最熱門的遊戲列表。 我們已經把問題的範圍一步步給縮小了，一開始是「要怎麼跟 Twitch 拿資料」，現在則更細的切分為：「要怎麼利用 JavaScript 發送 Reuqest」 Ajax要在瀏覽器上面發送 Request，必須應用到一種技術叫做 Ajax，全名是「Asynchronous JavaScript and XML」，重點在於Asynchronous這個單字，非同步。 在講什麼是非同步之前，就要先來提一下什麼是同步。你原本寫的 JavaScript 就幾乎都是同步執行的。意思是他執行到某一行的時候，會等這行執行完畢，才執行到下一行，確保執行順序。 也就是說下面這段程式碼，最後一行需要等很長一段時間才能執行到： var count = 10000000; while(count--) &#123; // 做一些耗時的操作 &#125; // 等很久才被執行到 console.log('done') 看起來滿有道理的，程式本來不就是一行一行執行的嗎？可是如果今天牽涉到網路操作的話，大家可以思考看看下面這個例子： // 假設有個發送 Request 的函式叫做 sendRequest var result = sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx'); // 等很久才被執行到 console.log(result); 當 JavaScript 執行到sendRequest的時候，由於是同步的，就會等待 Response 回來才繼續做事。換句話說，在 Response 還沒回來之前，整個 JavaScript 引擎是不會執行任何東西的！很可怕對吧，你點任何有牽涉到 JavaScript 的東西，都不會有反應，因為 JavaScript 還在等 Response 回來。 所以呢，像是這種已經預期到可能非常耗時間，非常不穩定的操作，就不能用同步的方式來執行，而是要用非同步。 非同步是什麼意思呢？就是執行完之後就不管它了，不等結果回來就繼續執行下一行： // 假設有個發送 Request 的函式叫做 sendRequest var result = sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx'); // 上面 Request 發送完之後就執行到這一行，所以 result 不會有東西 // 因為 Response 根本沒有回來 console.log(result); 這邊需要特別注意的是「非同步的 Function 不能直接透過 return 把結果傳回來」，為什麼？因為像上面這個例子，它發送 Request 之後就會執行到下一行了，這個時候根本就還沒有 Response，是要回傳什麼？ 那怎麼辦呢？先聽我舉個很常見的小例子吧！ 我之前在新加坡的 Food Court 吃飯的時候，那邊每一張桌子上面都會有桌號。你去點餐的時候，只要跟老闆講說你坐哪一桌，等餐點完成之後老闆就會自己主動送過來。 所以我不需要站在店家門口等，我只要在位子上繼續坐我的事情，反正餐點好了之後老闆會送過來。 非同步的概念也是這樣，我發送 Request 之後（我點餐之後），我不用等 Response 回來（不用等老闆做好），可以繼續做自己的事，等 Response 回來之後（等餐點做好之後），會自己幫我把結果送過來（老闆會自己送過來）。 在點餐的例子中，老闆可以透過桌號知道應該把資料送到哪邊，那在 JavaScript 裡面呢？可以透過 Function！而這個 Function，我們就稱作 Callback Function，回呼函式。 當非同步的操作完成時，就可以呼叫這個 Function，並且把資料帶進來。 // 假設有個發送 Request 的函式叫做 sendRequest sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx', callMe); function callMe (response) &#123; console.log(response); &#125; // 或者寫成匿名函式 sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx', function (response) &#123; console.log(response); &#125;); 現在你就知道為什麼網路的操作是非同步，以及什麼是 callback function 了。 XMLHttpRequest方才提到 Ajax、非同步以及 callback function 的概念，但還是沒講到要怎麼發送 Request，只寫了一個假的sendRequest函式當作參考而已。 要發送 Request 的話，就要透過瀏覽器幫我們準備好的一個物件，叫做XMLHttpRequest，範例程式碼如下： var request = new XMLHttpRequest(); request.open('GET', `https://api.twitch.tv/kraken/games/top?client_id=xxx`, true); request.onload = function() &#123; if (request.status >= 200 &amp;&amp; request.status &lt; 400) &#123; // Success! console.log(request.responseText); &#125; &#125;; request.send(); 上面的request.onload其實就是在指定說當資料回來的時候，要用哪一個 function 去處理。 有了上面這一段程式碼之後，你終於大功告成，終於可以串接 Twitch API，從那邊拿資料下來了！真是可喜可賀，從此之後，你就跟「串接 API」這個技能過著幸福快樂的生活… 才怪。 Same Origin Policy正當你以為自己已經對串接 API 駕輕就熟，想說去串接別的 API 試試看好了的時候，才發現一串就出問題了： XMLHttpRequest cannot load http:&#x2F;&#x2F;odata.tn.edu.tw&#x2F;ebookapi&#x2F;api&#x2F;getOdataJH&#x2F;?level&#x3D;all. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;null&#39; is therefore not allowed access. 咦？為什麼會有這個錯誤呢？ 其實是瀏覽器因為安全性的考量，有一個東西叫做同源政策，Same-origin policy。 意思就是說如果你現在這個網站的跟你要呼叫的 API 的網站「不同源」的時候，瀏覽器一樣會幫你發 Request，但是會把 Response 給擋下來，不讓你的 JavaScript 拿到並且傳回錯誤。 什麼是不同源呢？其實你想簡單一點，只要是 Domain 不一樣就是不同源，或者是一個用http一個用https也是不同源，端口號不一樣也是不同源。 所以如果你是接別人 API 的話，大多數情形都是不同源的。 這邊我想再強調一點，「你的 Request 還是有發出去的」，而且瀏覽器也「確實有收到 Response」，重點是「瀏覽器因為同源政策，不把結果傳回給你的 JavaScript」。如果沒有瀏覽器的話其實就沒有這些問題，你愛發給誰就發給誰，不管怎樣都拿得到 Response。 好，既然剛剛說了不同源會被擋下來，那 Twitch API 不是也不同源嗎，是怎麼串接成功的？ CORS大家都知道其實在不同源之間互相傳輸資料是很常有的事情，像我們串接 Twitch API 就是，我們怎麼可能跟 Twitch API 在同一個 Domain 底下呢？ 因此，同源政策的確是規範非同源就被擋下來，但與此同時其實又有另外一個規範，是說：「如果你想在不同 origin 之間傳輸資料的話，你應該怎麼做」，這規範就叫做 CORS。 CORS，全名為 Cross-Origin Resource Sharing，跨來源資源共用。 這套規範跟你說，如果你想開啟跨來源 HTTP 請求的話，Server 必須在 Response 的 Header 裡面加上Access-Control-Allow-Origin。 這個字段你應該不陌生才對，覺得陌生的可以拉回去上面看，剛剛的錯誤訊息其實就有講到這一個 Header。 當瀏覽器收到 Response 之後，會先檢查Access-Control-Allow-Origin裡面的內容，如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。 如果你打開 Devtool 仔細看一開始我們發給 Twitch 的 Request，你會發現 Response 的 Header 大概是長這樣： Content-Type: application&#x2F;json Content-Length: 71 Connection: keep-alive Server: nginx Access-Control-Allow-Origin: * Cache-Control: no-cache, no-store, must-revalidate, private Expires: 0 Pragma: no-cache Twitch-Trace-Id: e316ddcf2fa38a659fa95af9012c9358 X-Ctxlog-Logid: 1-5920052c-446a91950e3abed21a360bd5 Timing-Allow-Origin: https:&#x2F;&#x2F;www.twitch.tv 重點是這一行：Access-Control-Allow-Origin: *，星號就代表萬用字元，意思是任何一個 Origin 都接受。所以當瀏覽器接收到這個 Response 之後，比對目前的 Origin 符合*這個規則，檢驗通過，允許我們接受跨來源請求的回應。 除了這個 Header 以外，其實還有其他的可以用，例如說Access-Control-Allow-Headers跟Access-Control-Allow-Methods，就可以定義接受哪些 Request Header 以及接受哪些 Method。 總結一下，如果你想要發起跨來源 HTTP 請求並且順利收到回應的話，需要確保 Server 端有加上Access-Control-Allow-Origin，不然 Response 會被瀏覽器給擋下來並且顯示出錯誤訊息。 Preflight Request還記得 Twitch 的 API 文件嗎？裡面需要帶一個client-id的參數，而文件裡面寫說你可以帶在 GET 的參數上面，也可以帶在 Header 裡，我們來試試看帶在 Header 裡會怎樣吧！打開 Devtool，你會看到一個神奇的現象： 咦？我明明只發了一個 Request，怎麼變兩個了？而且第一個的 Method 居然是OPTIONS。只是多加了一個 Header 就多了一個 Request，是為什麼呢？ 其實這又跟上面講的 CORS 有關了，CORS 把 Request 分成兩種，一種是簡單請求（simple requests）。什麼是簡單請求呢？其實定義有滿長一串的，我認為有需要用到的時候再看就好，但總之如果你沒有加任何自定義的 Header，而且又是 GET 的話，絕對是簡單請求（這個夠簡單了吧） 反之呢，如果你有加一些自定義的 Header，例如說我們剛剛加的Client-ID，這個 Request 就絕對不是簡單請求。 （定義可參考：MDN: 簡單請求） 從上述分類可知，我們剛剛發起的 Request 因為有帶了 Custom header，所以不會是簡單請求，那為什麼會多一個 Request 呢？ 這一個 Request 叫做 Preflight Request，中文翻作「預檢請求」，因為非簡單請求可能會帶有一些使用者資料，因此會先透過 Preflight Request 去確認後續的請求能否送出。 如果這個 Preflight Request 沒有過的話，真的 Request 也就不會發送了，這就是預檢請求的目的。 我舉一個例子，你就會知道為什麼需要這個 Preflight Request 了。 假設今天某個 Server 提供了一個 API 網址叫做：https://example.com/data/16，你只要對它發送 GET，就能夠拿到 id 是 16 的資料，只要對它發送 DELETE，就可以把這筆資料刪除。 如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。 因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。 如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。 先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。 JSONP最後來講一下 JSONP，這是跨來源請求除了 CORS 以外的另外一種方法，全名叫做：JSON with Padding。 還記得一開始提到的同源政策吧？仔細思考一下會發現，其實有些東西是不受同源政策限制的，例如說&lt;script&gt;這個 Tag，我們不是常常引用 CDN 或是 Google Analytics 之類的第三方套件嗎？網址都是其他 Domain 的，但是卻能正常載入。 JSONP 就是利用&lt;script&gt;的這個特性來達成跨來源請求的。 今天先想像你有一段 HTML 長這樣： &lt;script> var response = &#123; data: 'test' &#125;; &lt;/script> &lt;script> console.log(response); &lt;/script> 很好懂的一段程式碼，我就不多做解釋了。那如果今天把上面那一段換成一串網址呢？ &lt;script src=\"https://another-origin.com/api/games\">&lt;/script> &lt;script> console.log(response); &lt;/script> 如果https://another-origin.com/api/games這個網址返回的內容就是剛剛的： var response = &#123; data: 'test' &#125;; 那我不就一樣可以拿到資料了嗎？而且這些資料還是 Server 端控制的，所以 Server 可以給我任何資料。但是這樣用全域變數其實不太好，我們可以借用剛剛的 Callback Function 的概念，改成這樣： &lt;script> receiveData(&#123; data: 'test' &#125;); &lt;/script> &lt;script> function receiveData (response) &#123; console.log(response); &#125; &lt;/script> 所以 JSONP 是什麼？JSONP 其實就是透過上面這種形式，利用&lt;script&gt;裡面放資料，透過指定好的 function 把資料給帶回去。你只要把第一段的&lt;script&gt;那邊想成是 Server 的回傳值，你就可以理解了。 實務上在操作 JSONP 的時候，Server 通常會提供一個callback的參數讓 client 端帶過去。Twitch API 有提供 JSONP 的版本，我們可以直接來看範例： URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=aaa&amp;limit=1 aaa(&#123;\"_total\":1069,\"_links\":&#123;\"self\":\"https://api.twitch.tv/kraken/games/top?limit=1\",\"next\":\"https://api.twitch.tv/kraken/games/top?limit=1\\u0026offset=1\"&#125;,\"top\":[&#123;\"game\":&#123;\"name\":\"Dota 2\",\"popularity\":63361,\"_id\":29595,\"giantbomb_id\":32887,\"box\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"logo\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"_links\":&#123;&#125;,\"localized_name\":\"Dota 2\",\"locale\":\"zh-tw\"&#125;,\"viewers\":65243,\"channels\":373&#125;]&#125;) URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1 receiveData(&#123;\"_total\":1067,\"_links\":&#123;\"self\":\"https://api.twitch.tv/kraken/games/top?limit=1\",\"next\":\"https://api.twitch.tv/kraken/games/top?limit=1\\u0026offset=1\"&#125;,\"top\":[&#123;\"game\":&#123;\"name\":\"Dota 2\",\"popularity\":63361,\"_id\":29595,\"giantbomb_id\":32887,\"box\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"logo\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"_links\":&#123;&#125;,\"localized_name\":\"Dota 2\",\"locale\":\"zh-tw\"&#125;,\"viewers\":65622,\"channels\":376&#125;]&#125;) 有發現了嗎？它就是透過你帶過去的callback這個參數當作函式名稱，把 JavaScript 物件整個傳到 Function 裡面，你就可以在 Function 裡面拿到資料。 結合起來會變這樣： &lt;script src=\"https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1\">&lt;/script> &lt;script> function receiveData (response) &#123; console.log(response); &#125; &lt;/script> 利用 JSONP，也可以存取跨來源的資料。但 JSONP 的缺點就是你要帶的那些參數永遠都只能用附加在網址上的方式（GET）帶過去，沒辦法用 POST。 如果能用 CORS 的話，還是應該優先考慮 CORS。 總結今天這篇文章的內容就是從抓資料這件事情開始，一步步告訴你應該去哪裡抓？應該怎麼抓？用 API 抓，那什麼是 API？怎麼在 JavaScript 裡面呼叫 Web API？怎麼樣存取跨來源的資料？ 一般來說，跟前端抓資料有關的東西我基本上都提到了，不過有個遺珠之憾是沒有提到Fetch API，這是比較新的標準，也是拿來抓資料用的，MDN 上面的介紹是： The Fetch API provides an interface for fetching resources (including across the network). It will seem familiar to anyone who has used XMLHttpRequest, but the new API provides a more powerful and flexible feature set. 有興趣的讀者們可以自己去看一下。 希望大家看完這篇之後，會更了解怎麼樣串接後端 API，以及串接的時候可能會碰到哪些困難。","link":"/2017/08/27/ajax-and-cors/"},{"title":"pack-tool-preview","text":"试了试把真实项目从 Vite 迁移到 Rspack，Build 速度从 125 秒缩短到了 17 秒，开发中刷新页面的速度也提升了 64 %，不过 HMR 时间比 Vite 慢多了。 如果开发过程中触发 HMR 比较多，而刷新页面比较少，Vite 还是有开发体验的优势。如果是复杂项目，刷新页面更常用，那 Rspack 的开发体验反而会更好。 前端构建的工具实在是太多了，rolldown、rollup、Rspack、Vite…… 先提前插个眼","link":"/2023/10/27/pack-tool-preview/"},{"title":"Webpack 中的 sideEffects 该怎么用","text":"webpack v4 开始新增了一个 sideEffects 特性，通过给 package.json 加入 sideEffects 声明该 包&#x2F;模块 是否包含 sideEffects(副作用)，从而可以为 tree-shaking 提供更大的优化空间。 基于我们对 side effect 的常规理解，我们可以认为，只要我们确定当前包里的模块不包含副作用，然后将发布到 npm 里的包标注为 sideEffects: false ，我们就能为使用方提供更好的打包体验。原理是 webpack 能将标记为 side-effects-free 的包由 import &#123;a&#125; from xx 转换为 import &#123;a&#125; from &#39;xx/a&#39;，从而自动修剪掉不必要的 import，作用同 babel-plugin-import。 Tree Shaking 与副作用Tree-Shaking在前端界由rollup首先提出并实现，后续webpack在2.x版本也借助于UglifyJS实现了。自那以后，在各类讨论优化打包的文章中，都能看到Tree-Shaking的身影。 Tree-Shaking的原理ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。 分析程序流，判断哪些变量未被使用、引用，进而删除此代码。 很好，原理非常完美，那为什么有时候我们项目里面多余的的代码又删不掉呢？ 先说原因：都是副作用的锅！ 副作用了解过函数式编程的同学对副作用这词肯定不陌生。它大致可以理解成：一个函数会、或者可能会对函数外部变量产生影响的行为。 举个例子，比如这个函数： function go (url) &#123; window.location.href = url &#125; 这个函数修改了全局变量location，甚至还让浏览器发生了跳转，这就是一个有副作用的函数。 // componetns.js export class Person &#123; constructor (&#123; name &#125;) &#123; this.className = 'Person' this.name = name &#125; getName () &#123; return this.name &#125; &#125; export class Apple &#123; constructor (&#123; model &#125;) &#123; this.className = 'Apple' this.model = model &#125; getModel () &#123; return this.model &#125; &#125; // main.js import &#123; Apple &#125; from './components' const appleModel = new Apple(&#123; model: 'IphoneX' &#125;).getModel() console.log(appleModel) 很显然这个Person类是无用的代码 而为什么有时候别的工具，比如rollup在线repl尝试了下tree-shaking，也确实删掉了无用的代码 而使用webpack打包工具却不能进行有效的代码消除呢？ 答案是：babel编译 + webpack打包 在这边贴一个链接，是有关于详细介绍babel编译 + webpack打包是怎么让你无效的代码消除不掉的。你的Tree-Shaking并没什么卵用 如果不想看文章的话，这边直接简单说一下原理：babel编译会使得Person类被封装成了一个IIFE(立即执行函数)，然后返回一个构造函数，在这边就产生了一个副作用。 这边有个Issues，IIFE 中的类声明被视为副作用 当我在 IIFE 中声明一个类，但没有使用类时，它不会被 UglifyJS 剥离，因为它被认为是副作用。 var V6Engine = (function () &#123; function V6Engine() &#123; &#125; V6Engine.prototype.toString = function () &#123; return 'V6'; &#125;; return V6Engine; &#125;()); 编译时收到这样的警告：WARN: Side effects in initialization of unused variable V6Engine [./dist/car.bundle.js:74,4] 下面给出的回复：Uglify 没做执行程序流分析。它并不会因为你注意到的副作用而删除代码。你要是想弄个完善一点的摇树，去隔壁rollup呗！ issue中总结下几点关键信息： 函数的参数若是引用类型，对于它属性的操作，都是有可能会产生副作用的。因为首先它是引用类型，对它属性的任何修改其实都是改变了函数外部的数据。其次获取或修改它的属性，会触发getter或者setter，而getter、setter是不透明的，有可能会产生副作用。 uglify没有完善的程序流分析。它可以简单的判断变量后续是否被引用、修改，但是不能判断一个变量完整的修改过程，不知道它是否已经指向了外部变量，所以很多有可能会产生副作用的代码，都只能保守的不删除。 rollup有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。 但这已经是很久之前的版本问题，现在的webpack tree shaking已经做了很多的优化，足够的程序流分析进行tree shaking webpack 的 tree shaking 的作用是可以将未被使用的 exported member 标记为 unused 同时在将其 re-export 的模块中不再 export。说起来很拗口，看代码： // a.js export function a() &#123;&#125; // b.js export function b()&#123;&#125; // package/index.js import a from './a' import b from './b' export &#123; a, b &#125; // app.js import &#123;a&#125; from 'package' console.log(a) 当我们以 app.js 为 entry 时，经过摇树后的代码会变成这样： // a.js export function a() &#123;&#125; // b.js 不再导出 function b()&#123;&#125; function b() &#123;&#125; // package/index.js 不再导出 b 模块 import a from './a' import './b' export &#123; a &#125; // app.js import &#123;a&#125; from 'package' console.log(a) 配合 webpack 的 scope hoisting 和 uglify 之后，b 模块的痕迹会被完全抹杀掉。 但是如果 b 模块中添加了一些副作用，比如一个简单的 log： // b.js export function b(v) &#123; reutrn v &#125; console.log(b(1)) webpack 之后会发现 b 模块内容变成了： // b.js console.log(function (v)&#123;return v&#125;(1)) 虽然 b 模块的导出是被忽略了，但是副作用代码被保留下来了。 由于目前 transformer 转换后可能引入的各种奇怪操作引发的副作用，很多时候我们会发现就算有了 tree shaking 我们的 bundle size 还是没有明显的减小。 而通常我们期望的是 b 模块既然不被使用了，其中所有的代码应该不被引入才对。 这个时候 sideEffects 的作用就显现出来了：如果我们引入的 包&#x2F;模块 被标记为 sideEffects: false 了，那么不管它是否真的有副作用，只要它没有被引用到，整个 模块&#x2F;包 都会被完整的移除。 以 mobx-react-devtool 为例，我们通常这样去用： import DevTools from 'mobx-react-devtools'; class MyApp extends React.Component &#123; render() &#123; return ( &lt;div> ... &#123; process.env.NODE_ENV === 'production' ? null : &lt;DevTools /> &#125; &lt;/div> ); &#125; &#125; 这是一个很常见的按需导入场景，然而在没有 sideEffects: false 配置时，即便 NODE_ENV 设为 production ，打包后的代码里依然会包含 mobx-react-devtools 包，虽然我们没使用过其导出成员，但是 mobx-react-devtools 还是会被 import，因为里面“可能”会有副作用。 但当我们加上 sideEffects false 之后，tree shaking 就能安全的把它从 bundle 里完整的移除掉了。 sideEffects 的使用场景上面也说到，通常我们发布到 npm 上的包很难保证其是否包含副作用（可能是代码的锅可能是 transformer 的锅），但是我们基本能确保这个包是否会对包以外的对象产生影响，比如是否修改了 window 上的属性，是否复写了原生对象方法等。如果我们能保证这一点，其实我们就能知道整个包是否能设置 sideEffects: false了，至于是不是真的有副作用则并不重要，这对于 webpack 而言都是可以接受的。 这也就能解释为什么能给 vue 这个本身充满副作用的包加上 sideEffects: false 了。 所以其实 webpack 里的 sideEffects: false 的意思并不是我这个模块真的没有副作用，而只是为了在摇树时告诉 webpack：我这个包在设计的时候就是期望没有副作用的，即使他打完包后是有副作用的。","link":"/2023/10/27/Webpack-optimization-3/"}],"tags":[{"name":"http","slug":"http","link":"/tags/http/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"Build","slug":"Build","link":"/tags/Build/"}],"categories":[{"name":"http","slug":"http","link":"/categories/http/"},{"name":"Webpack","slug":"Webpack","link":"/categories/Webpack/"},{"name":"Front-end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"Build","slug":"Build","link":"/categories/Build/"}]}