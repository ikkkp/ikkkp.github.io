{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"關於我","text":"写作，是内心的独白“写作，是内心的独白，是灵魂的流淌。” - 王小波 我是ikkkp。 其实想建一个属于自己的个人网站并在上面写一些自己喜欢的东西也不是一天两天了。 我写作的原因，或许并不复杂。文字，是我与世界沟通的桥梁，是我思考、感受、触摸生活的工具。 而写作，是我在孤独中寻找陪伴的方式，是我在迷茫中找到方向的灯塔。 文字是生活的注解，写作是内心的显现。 在这个喧嚣的世界里，写作替我找到了一份宁静。 写作，让我能够更清晰地思考问题，更深刻地理解自己。 每当我将思绪转化为文字，就像是给心灵进行了一次洗礼，让我更加了解自己的内心世界。写作，也是我与他人交流的方式，通过文字，我能够传递我的思想、分享我的经验，与他人建立起深厚的情感纽带。 在文字的海洋里，我们可以不受拘束地航行，探寻无限的可能。","link":"/abouts/index.html"},{"title":"Archives","text":"","link":"/archive/index.html"},{"title":"推薦閱讀","text":"","link":"/recommend/index.html"}],"posts":[{"title":"2023-11-24-随笔","text":"「人的一切痛苦，本质上都是对自己无能的愤怒」","link":"/2023/11/24/2023-11-24-Writing/"},{"title":"2023-11-22 随笔","text":"“你不爱我的时候 我可能还是爱你 同时爱那个曾经的自己他又可爱 执迷不悟 又不可复制 其实谢谢你的体贴 这些日子 天又蓝又晴” ——《陪安东尼度过漫长岁月》","link":"/2023/11/22/2023-11-22-Writing/"},{"title":"301/302-重定向","text":"前言当你在网站上进行重定向设置时，特别是在以下两种情况下，可能会遇到问题： 从HTTP到HTTPS的重定向： 假设你配置了SSL证书，将网站从HTTP升级到HTTPS。 如果在这个过程中出现了问题，导致网站无法正常访问，你可能会想撤销重定向，回到HTTP版本。然而，问题在于，一旦你使用了301永久性重定向，浏览器会把这个重定向信息保存下来。即使你在服务器上取消了重定向，用户的浏览器依然会强制将他们重定向到HTTPS版本，无法再访问HTTP版本。 更改网站域名的重定向： 当你将网站从一个域名（比如old-domain.com）迁移到另一个域名（比如new-domain.com），你可能会使用301永久性重定向，以便搜索引擎和浏览器知道网站已经永久地移动到了新的域名。 但如果在这个过程中出现了问题，你可能希望撤销重定向，使用户能够再次访问旧域名。然而，由于301重定向被浏览器硬缓存，用户将被永久性地重定向到新域名，无法再访问旧域名。 为了避免这种情况，建议在测试确保一切正常后，一开始使用302临时性重定向，而不是301永久性重定向。302重定向不会被浏览器永久性地缓存，这意味着如果需要，你可以随时撤销重定向，而用户不会被永久性地锁定在新的网址上。这样可以避免用户需要手动清除浏览器缓存的繁琐步骤，提供更好的用户体验。 301重定向：意味着资源（页面）被永久性地移动到了一个新的位置。客户端&#x2F;浏览器不应再尝试请求原始位置，而应该从现在开始使用新的位置。 302重定向：意味着资源暂时位于其他地方，客户端&#x2F;浏览器应继续请求原始URL。 301是永久性重定向。即使你从服务器移除了重定向，你的浏览器仍然会将资源永久性地重定向到新的域名或HTTPS，因为它们被硬缓存。 所以，302不会被浏览器硬缓存，如果你从服务器（网站）移除了重定向，你就能够访问旧版本。 清除301&#x2F;302重定向缓存通常涉及清除浏览器缓存或者操作系统的DNS缓存。下面是如何在不同平台上做的说明： 清除浏览器缓存（适用于Windows、macOS、Linux）Google Chrome： 打开Chrome浏览器。 点击右上角的三个垂直点，选择“更多工具”。 选择“清除浏览数据”。 在弹出的窗口中，选择“高级”选项卡。 选择“所有时间”作为时间范围。 勾选“缓存图像和文件”选项。 点击“清除数据”按钮。 Mozilla Firefox： 打开Firefox浏览器。 点击右上角的三条水平线，选择“隐私与安全”。 在“Cookie和站点数据”部分，点击“清除数据”。 确保勾选了“缓存”选项。 点击“清除”。 Microsoft Edge： 打开Edge浏览器。 点击右上角的三个水平点，选择“设置”。 滚动至底部，点击“查看高级设置”。 在“隐私与服务”部分，点击“清除浏览数据”。 勾选“缓存图像和文件”选项。 点击“清除”按钮。 清除操作系统的DNS缓存（适用于Windows、macOS）Windows： 打开命令提示符（在开始菜单中搜索“cmd”并打开）。 输入以下命令并按下回车键：ipconfig &#x2F;flushdns macOS： 打开终端（在应用程序 &gt; 实用工具文件夹中找到）。 输入以下命令并按下回车键：sudo dscacheutil -flushcache 然后输入管理员密码并再次按下回车键。 请注意，清除浏览器缓存可能会导致您在网站上的登录状态丢失，所以请确保您已经备份了重要的信息，以防需要重新登录网站。","link":"/2023/10/28/301-302-Redirection/"},{"title":"浏览器默认行为","text":"前言其实浏览器内置了很多的事件。 而许多事件会自动触发浏览器执行某些行为。 例如： 点击一个链接 —— 触发导航（navigation）到该 URL。 点击表单的提交按钮 —— 触发提交到服务器的行为。 在文本上按下鼠标按钮并移动 —— 选中文本。 如果我们使用 JavaScript 处理一个事件，那么我们通常不希望发生相应的浏览器行为。而是想要实现其他行为进行替代。 阻止浏览器行为有两种方式来告诉浏览器我们不希望它执行默认行为： 主流的方式是使用 event 对象。有一个 event.preventDefault() 方法。 如果处理程序是使用 on&lt;event&gt;（而不是 addEventListener）分配的，那返回 false 也同样有效。 在下面这个示例中，点击链接不会触发导航（navigation），浏览器不会执行任何操作： &lt;a href=\"/\" onclick=\"return false\">Click here&lt;/a> or &lt;a href=\"/\" onclick=\"event.preventDefault()\">here&lt;/a> Click hereorhere 请注意的是，处理程序是使用 on&lt;event&gt;分配的，并进行return返回false并不是一个好的实践。 从处理程序返回 false 是一个例外事件处理程序返回的值通常会被忽略。 唯一的例外是从使用 on&lt;event&gt; 分配的处理程序中返回的 return false。 在所有其他情况下，return 值都会被忽略。并且，返回 true 没有意义。 处理程序选项 “passive”addEventListener 的可选项 passive: true 向浏览器发出信号，表明处理程序将不会调用 preventDefault()。 为什么需要这样做？ 移动设备上会发生一些事件，例如 touchmove（当用户在屏幕上移动手指时），默认情况下会导致滚动，但是可以使用处理程序的 preventDefault() 来阻止滚动。 因此，当浏览器检测到此类事件时，它必须首先处理所有处理程序，然后如果没有任何地方调用 preventDefault，则页面可以继续滚动。但这可能会导致 UI 中不必要的延迟和“抖动”。 passive: true 选项告诉浏览器，处理程序不会取消滚动。然后浏览器立即滚动页面以提供最大程度的流畅体验，并通过某种方式处理事件。 对于某些浏览器（Firefox，Chrome），默认情况下，touchstart 和 touchmove 事件的 passive 为 true。 event.defaultPrevented如果默认行为被阻止，那么 event.defaultPrevented 属性为 true，否则为 false。 这儿有一个有趣的用例。 你还记得我们在 冒泡和捕获 一章中讨论过的 event.stopPropagation()，以及为什么停止冒泡是不好的吗？ 有时我们可以使用 event.defaultPrevented 来代替，来通知其他事件处理程序，该事件已经被处理。 我们来看一个实际的例子。 默认情况下，浏览器在 contextmenu 事件（单击鼠标右键）时，显示带有标准选项的上下文菜单。我们可以阻止它并显示我们自定义的菜单，就像这样： &lt;button>Right-click shows browser context menu&lt;/button> &lt;button oncontextmenu=\"alert('Draw our menu'); return false\"> Right-click shows our context menu &lt;/button> Right-click shows browser context menu Right-click shows our context menu 现在，除了该上下文菜单外，我们还想实现文档范围的上下文菜单。 右键单击时，应该显示最近的上下文菜单： &lt;p>Right-click here for the document context menu&lt;/p> &lt;button id=\"elem\">Right-click here for the button context menu&lt;/button> &lt;script> elem.oncontextmenu = function(event) &#123; event.preventDefault(); alert(\"Button context menu\"); &#125;; document.oncontextmenu = function(event) &#123; event.preventDefault(); alert(\"Document context menu\"); &#125;; &lt;/script> Right-click here for the document context menu Right-click here for the button context menu elem.oncontextmenu = function(event) { event.preventDefault(); alert(\"Button context menu\"); }; document.oncontextmenu = function(event) { event.preventDefault(); alert(\"Document context menu\"); }; 问题是，当我们点击 elem 时，我们会得到两个菜单：按钮级和文档级（事件冒泡）的菜单。 如何修复呢？其中一个解决方案是：“当我们在按钮处理程序中处理鼠标右键单击事件时，我们阻止其冒泡”，使用 event.stopPropagation()： &lt;p>Right-click for the document menu&lt;/p> &lt;button id=\"elem\">Right-click for the button menu (fixed with event.stopPropagation)&lt;/button> &lt;script> elem.oncontextmenu = function(event) &#123; event.preventDefault(); event.stopPropagation(); alert(\"Button context menu\"); &#125;; document.oncontextmenu = function(event) &#123; event.preventDefault(); alert(\"Document context menu\"); &#125;; &lt;/script> Right-click for the document menu Right-click for the button menu (fixed with event.stopPropagation) elem.oncontextmenu = function(event) { event.preventDefault(); event.stopPropagation(); alert(\"Button context menu\"); }; document.oncontextmenu = function(event) { event.preventDefault(); alert(\"Document context menu\"); }; 现在按钮级菜单如期工作。但是代价太大，我们拒绝了任何外部代码对右键点击信息的访问，包括收集统计信息的计数器等。这是非常不明智的。 另一个替代方案是，检查 document 处理程序是否阻止了浏览器的默认行为？如果阻止了，那么该事件已经得到了处理，我们无需再对此事件做出反应。 &lt;p>Right-click for the document menu (added a check for event.defaultPrevented)&lt;/p> &lt;button id=\"elem\">Right-click for the button menu&lt;/button> &lt;script> elem.oncontextmenu = function(event) &#123; event.preventDefault(); alert(\"Button context menu\"); &#125;; document.oncontextmenu = function(event) &#123; if (event.defaultPrevented) return; event.preventDefault(); alert(\"Document context menu\"); &#125;; &lt;/script> Right-click for the document menu (added a check for event.defaultPrevented) Right-click for the button menu elem.oncontextmenu = function(event) { event.preventDefault(); alert(\"Button context menu\"); }; document.oncontextmenu = function(event) { if (event.defaultPrevented) return; event.preventDefault(); alert(\"Document context menu\"); }; 现在一切都可以正常工作了。如果我们有嵌套的元素，并且每个元素都有自己的上下文菜单，那么这也是可以运行的。只需确保检查每个 contextmenu 处理程序中的 event.defaultPrevented。 event.stopPropagation() 和 event.preventDefault()正如我们所看到的，event.stopPropagation() 和 event.preventDefault()（也被认为是 return false）是两个不同的东西。它们之间毫无关联。 嵌套的上下文菜单结构还有其他实现嵌套上下文菜单的方式。其中之一是拥有一个具有 document.oncontextmenu 处理程序的全局对象，以及使我们能够在其中存储其他处理程序的方法。该对象将捕获任何右键单击，浏览存储的处理程序并运行适当的处理程序。 但是，每段需要上下文菜单的代码都应该了解该对象，并使用它的帮助，而不是使用自己的 contextmenu 处理程序。 总结有很多默认的浏览器行为： mousedown —— 开始选择（移动鼠标进行选择）。 在 &lt;input type=&quot;checkbox&quot;&gt; 上的 click —— 选中&#x2F;取消选中的 input。 submit —— 点击&lt;input type=&quot;submit&quot;&gt;或者在表单字段中按下 Enter 键会触发该事件，之后浏览器将提交表单。 keydown —— 按下一个按键会导致将字符添加到字段，或者触发其他行为。 contextmenu —— 事件发生在鼠标右键单击时，触发的行为是显示浏览器上下文菜单。 ……还有更多…… 如果我们只想通过 JavaScript 来处理事件，那么所有默认行为都是可以被阻止的。 想要阻止默认行为 —— 可以使用 event.preventDefault() 或 return false。第二个方法只适用于通过 on&lt;event&gt; 分配的处理程序。 addEventListener 的 passive: true 选项告诉浏览器该行为不会被阻止。这对于某些移动端的事件（像 touchstart 和 touchmove）很有用，用以告诉浏览器在滚动之前不应等待所有处理程序完成。 如果默认行为被阻止，event.defaultPrevented 的值会变成 true，否则为 false。","link":"/2023/12/06/Browser-Default-Behavior/"},{"title":"云计算及应用","text":"云计算的定义即通过网络按需提供可动态伸缩的廉价计算服务。是与信息技术、软件、互联网相关的一种服务。 云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进入可配置的计算机资源共享池（资源包括网络、服务器、存储、应用软件、服务），这些资源能够被快速提供。 云计算发展史2006年3月，亚马逊（Amazon）推出弹性计算云（Elastic Compute Cloud；EC2）服务。 2006年8月9日，Google首席执行官埃里克·施密特（Eric Schmidt）在搜索引擎大会（SES San Jose 2006）首次提出“云计算”（Cloud Computing）的概念。Google“云端计算”源于Google工程师克里斯托弗·比希利亚所做的“Google 101”项目。 2007年10月，Google与IBM开始在美国大学校园推广云计算的计划。 2008年2月1日，IBM（NYSE: IBM）宣布将在中国无锡太湖新城科教产业园为中国的软件公司建立全球第一个云计算中心（Cloud Computing Center）。 2008年7月29日，雅虎、惠普和英特尔宣布一项联合研究计划，推出云计算研究测试床，推进云计算。 2008年8月3日，美国专利商标局网站信息显示，戴尔正在申请“云计算”（Cloud Computing）商标，此举旨在加强对这一未来可能重塑技术架构的术语的控制权。 2010年3月5日，Novell与云安全联盟（CSA）共同宣布一项供应商中立计划，名为“可信任云计算计划（Trusted Cloud Initiative）”。 2010年7月，美国国家航空航天局和包括Rackspace、AMD、Intel、戴尔等支持厂商共同宣布“OpenStack”开放源代码计划，微软在2010年10月表示支持OpenStack与Windows Server 2008 R2的集成；而Ubuntu已把OpenStack加至11.04版本中。 2011年2月，思科系统正式加入OpenStack，重点研制OpenStack的网络服务。 云计算的技术背景云计算是并行计算(Parallel Computing)、分布式计算(Distributed Computing)和网格计算(Grid Computing)的发展，或者说是这些计算机科学概念的商业实现 云计算是虚拟化(Virtualization)、效用计算(Utility Computing)、IaaS(基础设施即服务)、PaaS(平台即服务)、SaaS(软件即服务)等技术混合演进、提升的结果","link":"/2023/11/08/Cloud-Computing/"},{"title":"Vue Components 和 Web 组件Custom Elements","text":"前言Web 组件是一组 Web 原生 API 的总称，允许开发人员创建可重用的自定义元素。 Vue 和 Web Components 主要是互补技术。无论是将自定义元素集成到现有的 Vue 应用程序中，还是使用 Vue 构建和分发自定义元素，Vue 对使用和创建自定义元素都有出色的支持。 什么是Custom ElementsWeb 组件的一个关键特性是创建自定义元素：即由 Web 开发人员定义行为的 HTML 元素，扩展了浏览器中可用的元素集。 Custom Elements有两种类型的自定义元素： 自定义内置元素（Customized built-in element） 继承自标准的 HTML 元素，例如 HTMLImageElement 或 HTMLParagraphElement。它们的实现定义了标准元素的行为。 独立自定义元素（Autonomous custom element） 继承自 HTML 元素基类 HTMLElement。你必须从头开始实现它们的行为。 自定义元素生命周期回调当然Custom Elements也有自定义元素生命周期回调 一旦你的自定义元素被注册，当页面中的代码以特定方式与你的自定义元素交互时，浏览器将调用你的类的某些方法。 通过提供这些方法的实现，规范称之为生命周期回调，你可以运行代码来响应这些事件。 自定义元素生命周期回调包括： connectedCallback()：每当元素添加到文档中时调用。规范建议开发人员尽可能在此回调中实现自定义元素的设定，而不是在构造函数中实现。 disconnectedCallback()：每当元素从文档中移除时调用。 adoptedCallback()：每当元素被移动到新文档中时调用。 attributeChangedCallback()：在属性更改、添加、移除或替换时调用。有关此回调的更多详细信息，请参见响应属性变化。 以下是一个记录这些生命周期事件的最小自定义元素示例： // 为这个元素创建类 class MyCustomElement extends HTMLElement &#123; static observedAttributes = [\"color\", \"size\"]; constructor() &#123; // 必须首先调用 super 方法 super(); &#125; connectedCallback() &#123; console.log(\"自定义元素添加至页面。\"); &#125; disconnectedCallback() &#123; console.log(\"自定义元素从页面中移除。\"); &#125; adoptedCallback() &#123; console.log(\"自定义元素移动至新页面。\"); &#125; attributeChangedCallback(name, oldValue, newValue) &#123; console.log(`属性 $&#123;name&#125; 已变更。`); &#125; &#125; customElements.define(\"my-custom-element\", MyCustomElement); 在 Vue 中使用自定义元素​在 Vue 应用程序中使用自定义元素在很大程度上与使用原生 HTML 元素相同，但需要记住以下几点： 跳过组件解析​默认情况下，Vue 会尝试将非原生 HTML 标签解析为已注册的 Vue 组件，然后再将其渲染为自定义元素。 这将导致 Vue 在开发过程中发出“无法解析组件”警告。为了让 Vue 知道某些元素应该被视为自定义元素并跳过组件解析，我们可以指定compilerOptions.isCustomElement选项。 如果您使用 Vue 进行构建设置，则该选项应通过构建配置传递，因为它是编译时选项。 浏览器内配置示例: &#x2F;&#x2F; Only works if using in-browser compilation. &#x2F;&#x2F; If using build tools, see config examples below. app.config.compilerOptions.isCustomElement &#x3D; (tag) &#x3D;&gt; tag.includes(&#39;-&#39;) Vite 配置示例​ // vite.config.js import vue from '@vitejs/plugin-vue' export default &#123; plugins: [ vue(&#123; template: &#123; compilerOptions: &#123; // treat all tags with a dash as custom elements isCustomElement: (tag) => tag.includes('-') &#125; &#125; &#125;) ] &#125; Vue CLI 配置示例​ // vue.config.js module.exports = &#123; chainWebpack: config => &#123; config.module .rule('vue') .use('vue-loader') .tap(options => (&#123; ...options, compilerOptions: &#123; // treat any tag that starts with ion- as custom elements isCustomElement: tag => tag.startsWith('ion-') &#125; &#125;)) &#125; &#125; 使用 Vue 构建自定义元素​自定义元素的主要好处是它们可以与任何框架一起使用，甚至可以在没有框架的情况下使用。这使得它们非常适合分发最终消费者可能不使用相同前端堆栈的组件，或者当您希望将最终应用程序与其使用的组件的实现细节隔离时。 定义自定义元素​Vue 支持通过该方法使用完全相同的 Vue 组件 API 创建自定义元素defineCustomElement。该方法接受与 相同的参数defineComponent，但返回一个扩展的自定义元素构造函数HTMLElement： 模板 &lt;my-vue-element&gt;&lt;&#x2F;my-vue-element&gt; import &#123; defineCustomElement &#125; from 'vue' const MyVueElement = defineCustomElement(&#123; // normal Vue component options here props: &#123;&#125;, emits: &#123;&#125;, template: `...`, // defineCustomElement only: CSS to be injected into shadow root styles: [`/* inlined css */`] &#125;) // Register the custom element. // After registration, all `&lt;my-vue-element>` tags // on the page will be upgraded. customElements.define('my-vue-element', MyVueElement) // You can also programmatically instantiate the element: // (can only be done after registration) document.body.appendChild( new MyVueElement(&#123; // initial props (optional) &#125;) ) 当我们谈论自定义元素和Vue组件时，实际上在讨论构建网页应用程序时使用的两种不同方式。自定义元素是一种Web标准，就像HTML元素一样，而Vue组件是Vue.js框架提供的一种更高级的构建方式。 有人认为只使用自定义元素是更“未来”的方式，但这段文字指出这种看法过于简单。它列举了一些原因，说明为什么Vue组件模型更为实用。其中一些关键点包括： Vue组件提供了更多功能，如方便的模板系统、管理状态的方法，以及在服务器上渲染组件的高效方式。这些功能对于构建复杂的应用程序是必要的。 Vue组件支持强大的组合机制，而自定义元素在这方面有一些局限。这意味着使用Vue，你更容易构建灵活而强大的组件结构。使用Vue，你能够借助一个成熟的框架和庞大的社区，而不必自己构建和维护一套内部框架。 自定义元素和 Vue 组件之间确实存在一定程度的功能重叠：它们都允许我们定义具有数据传递、事件发出和生命周期管理的可重用组件。然而，Web 组件 API 的级别相对较低且简单。要构建实际的应用程序，我们需要一些该平台未涵盖的附加功能： 声明性且高效的模板系统； 反应式状态管理系统，有利于跨组件逻辑提取和重用； 一种在服务器上渲染组件并在客户端 (SSR) 上进行组合的高性能方法，这对于 SEO 和LCP 等 Web Vitals 指标非常重要。原生自定义元素 SSR 通常涉及在 Node.js 中模拟 DOM，然后序列化变异的 DOM，而 Vue SSR 会尽可能编译为字符串连接，这更加高效。 defineCustomElement API Vue 组件转化使用 defineCustomElement API 将 Vue 组件转化为可以注册的自定义元素类有一些好处： 跨框架集成： 通过将 Vue 组件转化为自定义元素类，你可以在不同的前端框架和库中使用这个组件。这种方式使得你的组件更具通用性，可以与其他技术栈集成。 独立使用： 将 Vue 组件注册为自定义元素后，它可以独立于 Vue 应用使用。这意味着你可以在没有整个 Vue 应用的情况下使用该组件，以及在不同的构建系统和模块系统中引入它。 逐步迁移： 如果你的应用是逐步迁移到 Vue 的，你可以通过将某些组件转化为自定义元素来实现渐进式迁移。这使得你可以逐步地将 Vue 组件引入到一个已经存在的项目中，而无需一次性重写整个应用。 Web Components 标准兼容性： 将 Vue 组件注册为自定义元素使其与 Web Components 标准兼容。这意味着你可以利用 Web Components 生态系统的其他工具和库，使你的组件更具互操作性。 也就是说defineCustomElement API 的作用是将 Vue 组件编译为可以在浏览器中使用的自定义元素（Custom Element）。这意味着你不需要依赖 Vue 编译器在浏览器端实时编译 Vue 组件。 在使用 defineCustomElement API 时，Vue 组件会被提前编译成原生的自定义元素，这样就可以在浏览器中直接使用，而无需在运行时进行编译。 总体而言，通过使用 defineCustomElement API，你可以将 Vue 组件与自定义元素相结合，从而在更广泛的上下文中使用和共享这些组件，提高了组件的可复用性和灵活性。这在跨端组件开发集成上有很大的好处，你大可以先将组件开发成自定义元素，然后再在不同的端中使用。一个很典型的例子是我们之前提到的vue2和vue3的集成实现，这意味着你只需要将vue3的组件编译成自定义元素，然后在vue2中使用即可。","link":"/2023/11/29/Custom-Elements/"},{"title":"浏览器事件的冒泡和捕获","text":"前言让我们从一个示例开始。 处理程序（handler）被分配给了 &lt;div&gt;，但是如果你点击任何嵌套的标签（例如 &lt;em&gt; 或 &lt;code&gt;），该处理程序也会运行： &lt;div onclick=\"alert('The handler!')\"> &lt;em>If you click on &lt;code>EM&lt;/code>, the handler on &lt;code>DIV&lt;/code> runs.&lt;/em> &lt;/div> So, if you click on EM, the handler on DIV runs. 冒泡冒泡（bubbling）原理很简单。 当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。 假设我们有 3 层嵌套 FORM &gt; DIV &gt; P ，它们各自拥有一个处理程序： &lt;style> body * &#123; margin: 10px; border: 1px solid blue; &#125; &lt;/style> &lt;form onclick=\"alert('form')\">FORM &lt;div onclick=\"alert('div')\">DIV &lt;p onclick=\"alert('p')\">P&lt;/p> &lt;/div> &lt;/form> 现在，如果你点击 &lt;p&gt;，那么会发生什么？ 首先，处理程序在 &lt;p&gt; 上运行。 然后，它在 &lt;div&gt; 上运行。 然后，它在 &lt;form&gt; 上运行。 最后，它在 document 上运行。 这种行为被称为“事件冒泡”，因为它像气泡一样从元素冒出来。 因此，如果我们点击 &lt;p&gt;，那么我们将看到 3 个 alert：p → div → form。 event.target父元素上的处理程序始终可以获取事件实际发生位置的详细信息。 引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过 event.target 访问。 注意与 this（&#x3D;event.currentTarget）之间的区别： this 是在处理程序运行时的“当前”元素，它始终相同。 event.target 是在事件发生时的“目标”元素，它可以是任何元素，它在冒泡过程中改变。 那我们来举个例子吧！ 例如，如果我们有一个处理程序 form.onclick，那么它可以“捕获”表单内的所有点击。无论点击发生在哪里，它都会冒泡到 &lt;form&gt; 并运行处理程序。 注意哈！这边是将所有的事件都绑定到了 form 上，而不是每个元素上。 在 form.onclick 处理程序中： this（&#x3D;event.currentTarget）是 &lt;form&gt; 元素，因为处理程序在它上面运行。event.target 是表单中实际被点击的元素。 A click shows both event.target and this to compare: FORM DIV P form=document.querySelector('form'); form.onclick = function(event) { // 输出事件目标和当前元素 // （this=事件当前元素=form，event.target=事件目标=实际点击的元素） alert(\"target = \" + event.target.tagName + \", this=\" + this.tagName); }; 停止冒泡冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到 &lt;html&gt;，然后再到 document 对象，有些事件甚至会到达 window，它们会调用路径上所有的处理程序。 但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。 用于停止冒泡的方法是 event.stopPropagation()。 例如，如果你点击 &lt;button&gt;，这里的 body.onclick 不会工作： &lt;body onclick=\"alert(`the bubbling doesn't reach here`)\"> &lt;button onclick=\"event.stopPropagation()\">Click me&lt;/button> &lt;/body> Click me 捕获事件处理的另一个阶段被称为“捕获（capturing）”。 DOM 事件标准描述了事件传播的 3 个阶段： 捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。 目标阶段（Target phase）—— 事件到达目标元素。 冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。 下面是在表格中点击 &lt;td&gt; 的图片，摘自规范： 也就是说：点击 &lt;td&gt;，事件首先通过祖先链向下到达元素（捕获阶段），然后到达目标（目标阶段），最后上升（冒泡阶段），在途中调用处理程序。 之前，我们只讨论了冒泡，因为捕获阶段很少被使用。通常我们看不到它。 使用 on&lt;event&gt; 属性或使用 HTML 特性（attribute）或使用两个参数的 addEventListener(event, handler) 添加的处理程序，对捕获一无所知，它们仅在第二阶段和第三阶段运行。 总结当一个事件发生时 —— 发生该事件的嵌套最深的元素被标记为“目标元素”（event.target）。 然后，事件从文档根节点向下移动到 event.target，并在途中调用分配了 addEventListener(…, true) 的处理程序（true 是 {capture: true} 的一个简写形式）。 然后，在目标元素自身上调用处理程序。 然后，事件从 event.target 冒泡到根，调用使用 on&lt;event&gt;、HTML 特性（attribute）和没有第三个参数的，或者第三个参数为 false&#x2F;{capture:false} 的addEventListener 分配的处理程序。 每个处理程序都可以访问 event 对象的属性： event.target —— 引发事件的层级最深的元素。 event.currentTarget（&#x3D;this）—— 处理事件的当前元素（具有处理程序的元素） event.eventPhase —— 当前阶段（capturing&#x3D;1，target&#x3D;2，bubbling&#x3D;3）。 任何事件处理程序都可以通过调用 event.stopPropagation() 来停止事件，但不建议这样做，因为我们不确定是否确实不需要冒泡上来的事件，也许是用于完全不同的事情。 捕获阶段很少使用，通常我们会在冒泡时处理事件。这背后有一个逻辑。 事件处理程序也是如此。在特定元素上设置处理程序的代码，了解有关该元素最详尽的信息。特定于 的处理程序可能恰好适合于该 ，这个处理程序知道关于该元素的所有信息。所以该处理程序应该首先获得机会。然后，它的直接父元素也了解相关上下文，但了解的内容会少一些，以此类推，直到处理一般性概念并运行最后一个处理程序的最顶部的元素为止。","link":"/2023/12/05/Event-Bubbling/"},{"title":"浏览器事件委托","text":"前言捕获和冒泡允许我们实现最强大的事件处理模式之一，即 事件委托 模式。 这个想法是，如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是将单个处理程序放在它们的共同祖先上。 在处理程序中，我们获取 event.target 以查看事件实际发生的位置并进行处理。 事件委托简介 Bagua Chart: Direction, Element, Color, Meaning Northwest Metal Silver Elders North Water Blue Change Northeast Earth Yellow Direction West Metal Gold Youth Center All Purple Harmony East Wood Blue Future Southwest Earth Brown Tranquility South Fire Orange Fame Southeast Wood Green Romance let table = document.getElementById('bagua-table'); let selectedTd; table.onclick = function(event) { let target = event.target; while (target != this) { if (target.tagName == 'TD') { highlight(target); return; } target = target.parentNode; } } function highlight(node) { if (selectedTd) { selectedTd.classList.remove('highlight'); } selectedTd = node; selectedTd.classList.add('highlight'); } #bagua-table th { text-align: center; font-weight: bold; } #bagua-table td { width: 150px; white-space: nowrap; text-align: center; vertical-align: bottom; padding-top: 5px; padding-bottom: 12px; } #bagua-table .nw { background: #999; } #bagua-table .n { background: #03f; color: #fff; } #bagua-table .ne { background: #ff6; } #bagua-table .w { background: #ff0; } #bagua-table .c { background: #60c; color: #fff; } #bagua-table .e { background: #09f; color: #fff; } #bagua-table .sw { background: #963; color: #fff; } #bagua-table .s { background: #f60; color: #fff; } #bagua-table .se { background: #0c3; color: #fff; } #bagua-table .highlight { background: red; } 该表格有 9 个单元格（cell），但可以有 99 个或 9999 个单元格，这都不重要。 我们的任务是在点击时高亮显示被点击的单元格 &lt;td&gt;。 与其为每个 &lt;td&gt;（可能有很多）分配一个 onclick 处理程序 —— 我们可以在&lt;table&gt;元素上设置一个“捕获所有”的处理程序。 它将使用 event.target 来获取点击的元素并高亮显示它。 代码如下： let selectedTd; table.onclick = function(event) &#123; let target = event.target; // 在哪里点击的？ if (target.tagName != 'TD') return; // 不在 TD 上？那么我们就不会在意 highlight(target); // 高亮显示它 &#125;; function highlight(td) &#123; if (selectedTd) &#123; // 移除现有的高亮显示，如果有的话 selectedTd.classList.remove('highlight'); &#125; selectedTd = td; selectedTd.classList.add('highlight'); // 高亮显示新的 td &#125; 此代码不会关心在表格中有多少个单元格。我们可以随时动态添加&#x2F;移除 &lt;td&gt;，高亮显示仍然有效。 尽管如此，但还是存在缺陷。 点击可能不是发生在 &lt;td&gt; 上，而是发生在其内部。 在我们的例子中，如果我们看一下 HTML 内部，我们可以看到 &lt;td&gt; 内还有嵌套的标签，例如 &lt;strong&gt;： 在处理程序 table.onclick 中，我们应该接受这样的 event.target，并确定该点击是否在 &lt;td&gt; 内。 下面是改进后的代码： table.onclick = function(event) &#123; let td = event.target.closest('td'); // (1) if (!td) return; // (2) if (!table.contains(td)) return; // (3) highlight(td); // (4) &#125;; 解释： elem.closest(selector) 方法返回与 selector 匹配的最近的祖先。在我们的例子中，我们从源元素开始向上寻找 &lt;td&gt;。 如果 event.target 不在任何 &lt;td&gt; 中，那么调用将立即返回，因为这里没有什么事儿可做。 对于嵌套的表格，event.target 可能是一个 &lt;td&gt;，但位于当前表格之外。因此我们需要检查它是否是我们的表格中的 &lt;td&gt;。如果是的话，就高亮显示它。 委托示例：标记中的行为事件委托还有其他用途。（译注：本节标题中的“标记中的行为”即 action in markup） 例如，我们想要编写一个有“保存”、“加载”和“搜索”等按钮的菜单。并且，这里有一个具有 save、load 和 search 等方法的对象。如何匹配它们？ 第一个想法可能是为每个按钮分配一个单独的处理程序。但是有一个更优雅的解决方案。 我们可以为整个菜单添加一个处理程序，并为具有方法调用的按钮添加 data-action 特性（attribute）： &lt;button data-action=&quot;save&quot;&gt;Click to Save&lt;/button&gt; 处理程序读取特性（attribute）并执行该方法。工作示例如下： &lt;div id=\"menu\"> &lt;button data-action=\"save\">Save&lt;/button> &lt;button data-action=\"load\">Load&lt;/button> &lt;button data-action=\"search\">Search&lt;/button> &lt;/div> &lt;script> class Menu &#123; constructor(elem) &#123; this._elem = elem; elem.onclick = this.onClick.bind(this); // (*) &#125; save() &#123; alert('saving'); &#125; load() &#123; alert('loading'); &#125; search() &#123; alert('searching'); &#125; onClick(event) &#123; let action = event.target.dataset.action; if (action) &#123; this[action](); &#125; &#125;; &#125; new Menu(menu); &lt;/script> Save Load Search class Menu { constructor(elem) { this._elem = elem; elem.onclick = this.onClick.bind(this); // (*) } save() { alert('saving'); } load() { alert('loading'); } search() { alert('searching'); } onClick(event) { let action = event.target.dataset.action; if (action) { this[action](); } }; } new Menu(menu); 请注意，this.onClick 在 (*) 行中被绑定到了 this。这很重要，因为否则内部的 this 将引用 DOM 元素（elem），而不是 Menu 对象，那样的话，this[action] 将不是我们所需要的。 那么，这里的委托给我们带来了什么好处？ 我们不需要编写代码来为每个按钮分配一个处理程序。只需要创建一个方法并将其放入标记（markup）中即可。 HTML 结构非常灵活，我们可以随时添加&#x2F;移除按钮。 我们也可以使用 .action-save，.action-load 类，但 data-action 特性（attribute）在语义上更好。我们也可以在 CSS 规则中使用它。 “行为”模式我们还可以使用事件委托将“行为（behavior）”以 声明方式 添加到具有特殊特性（attribute）和类的元素中。 行为模式分为两个部分： 我们将自定义特性添加到描述其行为的元素。 用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上 —— 则执行行为（action）。 行为：计数器例如，这里的特性 data-counter 给按钮添加了一个“点击增加”的行为。 &lt;script> document.addEventListener('click', function(event) &#123; if (event.target.dataset.counter != undefined) &#123; // 如果这个特性存在... event.target.value++; &#125; &#125;); &lt;/script> Counter: One more counter: document.addEventListener('click', function(event) { if (event.target.dataset.counter != undefined) { // 如果这个特性存在... event.target.value++; } }); 总结事件委托真的很酷！这是 DOM 事件最有用的模式之一。 它通常用于为许多相似的元素添加相同的处理，但不仅限于此。 算法 在容器（container）上放一个处理程序。 在处理程序中 —— 检查源元素 event.target。 如果事件发生在我们感兴趣的元素内，那么处理该事件。 好处 简化初始化并节省内存：无需添加许多处理程序。 更少的代码：添加或移除元素时，无需添加&#x2F;移除处理程序。 DOM 修改 ：我们可以使用 innerHTML 等，来批量添加&#x2F;移除元素。 事件委托也有其局限性首先，事件必须冒泡。而有些事件不会冒泡。此外，低级别的处理程序不应该使用 event.stopPropagation()。其次，委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。但是，通常负载可以忽略不计，所以我们不考虑它。","link":"/2023/12/05/Event-Delegation/"},{"title":"FE-interview-guide","text":"CodeWaveCodeWave: 汇集开发者线下技术会议的导航，链接你与技术界的最新动态和机遇。 技术会议主页国内 GIAC全球互联网架构大会 - 集中探讨互联网架构的发展趋势，邀请业内顶尖的架构师分享他们的经验和见解。 QCon全球软件开发大会 - 聚焦软件开发的最新趋势和技术，旨在为软件开发者提供一个学习和交流的平台。 D2 终端技术大会 - 由阿里巴巴主办，专注于前端及移动开发领域的技术创新和实践交流。 稀土开发者大会 - 面向广大开发者，分享最前沿的技术动态和开发经验。 GMTC全球大前端技术大会 - 聚焦大前端领域的最新技术和应用实践，旨在推动前端技术的创新和发展。 ArchSummit全球架构师峰会 - 针对软件架构领域，邀请知名架构师分享架构设计的最佳实践和经验。 前端早早聊大会 - 一个面向前端社区的分享和交流平台，旨在促进前端技术和经验的分享。 VueConf - 面向Vue.js社区的开发者和爱好者，分享Vue.js的最新进展和应用案例。 CssConf - 集中探讨CSS相关的技术、工具和最佳实践，旨在推动CSS技术的发展。 Web前沿技术论坛 - 由W3C主办，探讨Web技术的最新标准和发展趋势。 中国软件研发管理行业技术峰会 - 聚焦软件研发管理领域，分享管理实践和创新方法。 中国DevOps社区, 近期活动 - 专注于DevOps文化和实践的推广，组织相关的活动和交流。 Elastic Meetup - Elastic 官方中文社区定期举办的线下交流活动 - 面向Elasticsearch用户和开发者的交流活动，分享使用经验和最佳实践。 JS World - 世界上最大的 JavaScript 会议，涵盖 JavaScript 的各个方面，邀请业界知名公司和组织的演讲嘉宾，提供技术更新和案例研究。最近一次举办于 2024.2.28。 VueJS Amsterdam - 规模最大的 Vue 会议，汇集全球参与者，与 Vue 创作者和维护者互动，建立联系并获得终生难忘的体验。最近一次举办于 2024.2.28。 VueConf US - Vue.js 社区组织的年度会议，由 Vue.js 创建者和核心团队主持，聚集全球 Vue.js 开发者和爱好者，分享最新技术和经验。最近一次举办于 2023.5.24。 React Summit, React Summit US - 全球最大的 React 会议，汇集 React 开发者、工程师和专家，分享 React 相关的技术和行业动态。最近一次举办于 2023.5.24 和 2023.11.13。 React Live - 与 500 名 React 开发人员一起参加一天的 React 庆典，深入探讨 React 相关的最新主题。最近一次举办于 2023.9.29。 DEV WORLD - 全球排名第一的开发者大会，提供与 7500 名开发人员面对面交流的机会，涵盖多个技术领域。最近一次举办于 2024.2.29。 Vite Conf - 沉浸式互动在线活动，面向前端团队，探讨使用 Vite 构建下一代网络。最近一次举办于 2023.10.5。 CSS Day - 高级 CSS 会议，提供轻松氛围和深入的讨论。最近一次举办于 2024.6.8。 FEday ReactNext - 以色列最大的 React 框架会议，汇集本地和国际演讲者，分享高级主题。最近一次举办于 2024.6.24。 JSHeroes - 非营利性社区组织的会议，汇集全球 JS 和 Web&#x2F;前端开发爱好者，提供演讲和网络活动。最近一次举办于 2024.5.23。 iJS - 国际 JavaScript 大会，关注 JavaScript 的最新趋势和变革。最近一次举办于 2023.10.23。 ng-conf - Angular 社区最大规模的年度技术峰会，邀请知名演讲嘉宾分享 Angular 相关经验和最佳实践。最近一次举办于 2023.6.14。 GOPS 2023全球运维大会 - 全球运维领域的年度大会，聚焦于最新的运维技术和实践。 DTCC 中国数据库技术大会 - 专注于数据库技术的交流和分享，汇集众多数据库领域的专家和技术爱好者。 Gdevops 全球敏捷运维峰会 - 探讨敏捷运维的最佳实践和前沿技术，旨在提高运维效率和质量。 ArchSummit 全球架构师峰会 - 集结全球顶尖架构师，分享架构设计的最新理念和技术。 KubeCon + CloudNativeCon - Kubernetes和云原生社区的年度聚会，分享云原生技术的最新进展。 2019产品经理大会 - 针对产品经理的专业大会，探讨产品管理的理念、工具和最佳实践。 WOT 全球人工智能技术峰会 - 聚焦人工智能技术的前沿进展，汇集AI领域的研究者和实践者。 NSC中国网络安全大会 - 专注于网络安全领域的交流和分享，旨在提升网络安全意识和技能。 DOIS 2019运维开发国际峰会 - 探讨运维与开发的融合，促进DevOps文化和实践的发展。 GTLC全球技术领导力大会 - 聚焦技术领导力的培养和发展，为技术领导者提供交流和学习的平台。 活动发布平台 hopin Meetup: We are what we do Eventbrite - Discover Great Events or Create Your Own &amp; Sell Tickets 腾讯云+社区沙龙 活动行-可以多留意这里 segmentfault-活动 掘金-活动 活动家 ，有会议PPT区 百格活动 又拍云OpenTalk 互动吧 友付活动票务 组织 Linux基金会 云原生软件基金会 CNCF D2 前端技术论坛 - 阿里经济体前端委员会主办的面向全球前端领域的技术论坛 相关资源推荐 SpringCloud中国社区 2017-2018活动汇总","link":"/2024/02/28/FE-interview-guide/"},{"title":"ModernWeb-有关于Chrome本地代码调试的简单记录","text":"引言自从上周去开了个前端的会议之后，对于前端的一些新技术有了一些新的认识，其中就有关于Chrome本地代码调试的一些新的认识，所以这里就简单的记录一下。这边先贴一个链接：youtube-ChromeDevs 这边要先感谢下chrome的devtools团队，他们的工作真的是太棒了，但是在 jecfish 的前端会议技术分享之前我却并不知道有这么多友好的web调试工具和性能测试手段，所以这里就简单的记录一下，大家要是有兴趣的话可以去看看上面的链接，里面有很多有用的东西，也欢迎给他们团队贴贴关注。 下面将先给出本章的大纲，然后再逐步展开。 本地代码调试这边的内容将是有关于本地代码调试，主要是有关于source-map的一些内容，这边将会有一些简单的介绍，然后再给出一些简单的例子。 对源代码映射source-map的需求 这边先给出一个链接：source-map 这个链接是jecfish写的有关于source-map的一些内容要是大家有兴趣的话，可以去里面看看，要是文章太长大家看不下去的话，可以直接看下面的内容。 今天，我们要讨论的是源代码映射，这是一种现代 Web 开发中的重要工具，可大幅简化调试工作。在本文中，我们将探讨源代码映射的基础知识、源代码映射的生成方式以及源代码映射如何改善调试体验。 好嘟，要进入source-map的学习认知，我们得先要对Modern Web有一个最基本的认识。那我们来看看当我说到Modern Web的时候我们该聊些什么？ 我们可以看到控制台打印了一些BaseOn Css样式的一些内容，但我们今天虽然并不准备着重讲这个console的Css样式，但你依然可以在console定义一些样式让你的console打印的更漂亮！ 时隔15年的时间，我们可以看到chrome开发者模式的调试工具从原来的寥寥几种，到现在的丰富多彩，这其中的变化是非常大的，所以我们今天就来聊聊这32种调试工具在chrome之中具体的应用。 我们知道浏览器只认识HTML &lt;&#x2F;&gt; CSS {;} JavaScript (,) Wasm（当然是现在浏览器引擎默认都内置了对Wasm模块的支持） 这几种语言，但是我们的前端框架却异常的丰富 ，涉及到的语言：ts、less、sass，框架：Vue、React，Meta 框架：nust.js、next.js，这些框架都是在我们的前端代码中使用的，但是浏览器并不认识这些语言，所以我们需要将这些语言转换成浏览器认识的语言。 我们正在构建更复杂的 Web 应用，您的开发工作流可能会涉及到使用各种工具。例如： 模板语言和 HTML 预处理器：Pug、Nunjucks、Markdown。 CSS 预处理器：SCSS、LESS、PostCSS。 JavaScript 框架：Angular、React、Vue、Svelte。 JavaScript 元框架：Next.js、Nuxt、Astro。 高级编程语言：TypeScript、Dart、CoffeeScript。等等。这个名单还在不断加长！ 这些工具需要一个构建流程，以将代码转译为浏览器可以理解的标准 HTML、JavaScript 和 CSS。此外，为了优化性能，通常的做法是压缩（例如，使用 Terser 缩减和破坏 JavaScript）和合并这些文件，以缩减其大小并提高 Web 效率。 而将这众多的模板语言和预处理器、元框架转化成浏览器可以看得懂的 HTML、JavaScript 和 CSS，这个过程就是编译，而编译的过程中就会产生一些中间代码，这些中间代码就是我们的源代码映射，这个 源代码映射 就是我们今天要讲的内容。 例如，使用构建工具，我们可以将以下 TypeScript 文件转译并压缩为一行 JavaScript。这个demo在github上面也有：parcel-demo &#x2F;* A TypeScript demo: example.ts *&#x2F; document.querySelector(&#39;button&#39;)?.addEventListener(&#39;click&#39;, () &#x3D;&gt; &#123; const num: number &#x3D; Math.floor(Math.random() * 101); const greet: string &#x3D; &#39;Hello&#39;; (document.querySelector(&#39;p&#39;) as HTMLParagraphElement).innerText &#x3D; &#96;$&#123;greet&#125;, you are no. $&#123;num&#125;!&#96;; console.log(num); &#125;); 压缩版本如下所示： /* A compressed JavaScript version of the TypeScript demo: example.min.js */ document.querySelector(\"button\")?.addEventListener(\"click\",(()=>&#123;const e=Math.floor(101*Math.random());document.querySelector(\"p\").innerText=`Hello, you are no. $&#123;e&#125;!`,console.log(e)&#125;)); 不过，这项优化会增加调试难度。如果压缩代码将所有内容放在一行中，并且变量名称较短，则很难查明问题的根源。这正是源映射的用武之地，它们会将编译后的代码映射回原始代码。 我们现在来具体看一个例子，这个例子是一个用ts代码写的简单的click事件触发的xhr，其中报了404错误。 哎？发生什么事了，注意看红色箭头处，看来我们浏览器看得懂ts代码？ 其实不然，看着这贴着的这张图，其实这个ts是从main.js里面解析过来的 了解源代码映射source-map 这些源映射文件包含关于已编译代码如何映射到原始代码的基本信息，让开发者能够轻松地进行调试。下面是一个源映射的示例。 &#123; &quot;mappings&quot;: &quot;AAAAA,SAASC,cAAc,WAAWC, ...&quot;, &quot;sources&quot;: [&quot;src&#x2F;script.ts&quot;], &quot;sourcesContent&quot;: [&quot;document.querySelector(&#39;button&#39;)...&quot;], &quot;names&quot;: [&quot;document&quot;,&quot;querySelector&quot;, ...], &quot;version&quot;: 3, &quot;file&quot;: &quot;example.min.js.map&quot; &#125; 要了解其中每个字段，您可以阅读源映射规范或这篇关于源映射剖析的经典文章。 源映射最重要的方面是 mappings 字段。它使用 VLQ base 64 编码字符串将已编译文件中的行和位置映射到对应的原始文件。可使用 source-map-visualization 和来源映射可视化等来源映射可视化工具直观呈现此映射。 左侧的生成的列会显示压缩内容，而原始列会显示原始来源。 可视化工具会以颜色代码对 original 列中的每一行以及 generated 列中的相应代码进行颜色编码。 mapping 部分显示了已解码的代码映射。例如，条目 65-&gt; 2:2 表示： 生成的代码：const 一词在压缩内容中的位置 65 处开始。 原始代码：const 一词从原始内容中的第 2 行和第 2 列开始。 这样一来，开发者便可以快速识别缩减后的代码与原始代码之间的关系，从而使调试过程更加顺畅。 浏览器开发者工具应用这些源代码映射，帮助您直接在浏览器中更快地查明调试问题。 DevTools 怎么知道该隐藏啥？Source maps 实用的chrome调试技巧请求 你可以在Network面板中查看请求的详细信息，包括请求头、响应头、请求体、响应体、Cookies、Timing等等。 同时，devTools devtools&#x2F;overrides 也提供了通过本地覆盖，可以覆盖 HTTP 响应标头和Web 内容（包括XHR 和获取请求）来模拟远程资源，即使您无权访问它们。这使您可以对更改进行原型设计，而无需等待后端支持它们。本地覆盖还允许您在页面加载期间保留在 DevTools 中所做的更改。 这个东西在什么情况特别有用呢？ 比如说，前端向后端发起的请求，后端返回的结果，可能还未进行跨域的处理（当然跨域的处理在后端做），那前端拿到的这个结果其实已经访问成功了，拿到了正确的数据，但是由于浏览器的安全策略，将此文件报告为不可信赖，这个时候我们就可以通过本地覆盖，来模拟后端返回的结果，这样就可以在前端进行调试了。 或者说有些数据在后端还未修改，前端拿到的数据是旧的，那我要干巴巴跟后端工程师小眼瞪大眼等着他们把数据改好了我们再进行工作嘛？这样实在是有点蠢hhhhh，我们可以通过重写content进行修改，这样就可以在前端进行调试了。 那这个devtools&#x2F;overrides确实是有点牛逼的，那它是怎么运行的： 当您在 DevTools 中进行更改时，DevTools 会将修改后的文件的副本保存到您指定的文件夹中。 当您重新加载页面时，DevTools 会提供本地修改后的文件，而不是网络资源。 覆盖网页内容设置文件夹 设置本地覆盖。 对文件进行更改并将其保存在 DevTools 中。 例如，您可以在“源”中编辑文件，或在“元素” &gt; “样式”中编辑 CSS，除非 CSS 位于HTML 文件中。 DevTools 保存修改后的文件，在Sources &gt; Overrides 中列出它们，并在相关面板和窗格中显示已保存。被覆盖文件旁边的图标：Elements &gt; Styles、Network 和Sources &gt; Overrides 。 覆盖 XHR 或获取请求以模拟远程资源通过本地覆盖，您不需要访问后端，也不必等待它支持您的更改。即时模拟和实验： 设置本地覆盖。 在Network中，过滤XHR&#x2F;fetch requests，找到您需要的请求，右键单击它，然后选择Override content。 对获取的数据进行更改并保存文件。 刷新。 刷新页面并观察应用的更改。 要了解此工作流程，请观看以下视频： 覆盖 HTTP 响应标头在“网络”面板中，您可以覆盖 HTTP 响应标头，而无需访问 Web 服务器。 通过响应标头覆盖，您可以在本地对各种标头进行原型修复，包括但不限于： 跨源资源共享 (CORS) 标头 权限-策略标头 跨源隔离标头 要覆盖响应标头： 设置本地覆盖并检查。 转到Network，找到请求，右键单击它，然后选择Override headers。DevTools 将带您进入标头&gt;响应标头编辑器 。 录制器，有利于调试和测试基于Chrome DevTools Recorder 的自定义和自动化用户流 编写自动化测试并不是开发人员生活中最有趣的事情。作为开发人员，事实上确实需要功能、修复错误并改善世界！然而，当我们的工作流程中没有自动化测试时，从长远来看，事情可能会变得相当“错误”。所以，我们也认为编写自动化测试很重要。 使用Chrome DevTools 中的Recorder 面板，您可以录制和重放用户流程，通过不同的第三方扩展和库将其导出为各种格式（例如测试脚本），使用 Puppeteer Replay 库自定义用户流程，并将其与您现有的工作流程。 在这篇博文中，我们将讨论： 如何以编程方式导出和重放用户流。 如何借助 Puppeteer Replay 自定义用户流程。 如何与您的CI&#x2F;CD工作流程集成。 以编程方式导出用户流并重播默认情况下，Recorder 使您能够将这些录音导出为Puppeteer或Puppeteer Replay脚本，或者导出为纯 JSON 文件。 使用 Puppeteer Replay 进行重播将用户流导出为 JSON 文件后，您可以选择将其导入回记录器面板并重播，或使用外部库来重播。Puppeteer Replay库是可用的库之一。 Puppeteer Replay 是一个库，可帮助您重播用户流程。它是一个基于 Puppeteer 的库，它允许您在浏览器中重播用户流程，而无需编写任何代码。您可以使用 Puppeteer Replay 重播您的用户流程，以确保您的应用程序在不同的环境中运行良好。 与 CI&#x2F;CD 管道集成有多种方法可以做到这一点，并且有很多工具。以下是使用GitHub Actions自动执行此过程的示例： # .github&#x2F;node.js.yml name: Replay recordings on: push: branches: [ &quot;main&quot; ] schedule: - cron: &#39;30 12 * * *&#39; # daily 12:30pm jobs: build: runs-on: ubuntu-latest steps: - uses: actions&#x2F;checkout@v3 - name: Use Node.js uses: actions&#x2F;setup-node@v3 with: node-version: 18.x cache: &#39;npm&#39; - run: npm install puppeteer - run: npm run replay-all - run: npm run start 在此示例中，我们将在以下情况下重播用户流： 新的变更推送到main分支每天中午 12:30除了 GitHub Actions 之外，您还可以与您最喜欢的云提供商集成。","link":"/2023/11/20/ModernWeb-Debugging1/"},{"title":"Webpack 性能优化-1","text":"前言先来说说为什么要优化？当然如果你的项目很小，构建很快，其实不需要特别关注性能方面的问题。 但是随着项目涉及到的页面越来越多，功能和业务代码也会越来越多，相应的 webpack 的构建时间也会越来越久，这个时候我们就不得不考虑性能优化的事情了。 webpack 的性能优化较多，我们考虑从两方面入手：优化一：打包后的结果，上线时的性能优化。（比如分包处理、减小包体积、CDN服务器等）优化二：优化打包速度，开发或者构建时优化打包速度。（比如 exclude 、cache-loader等） 因为这个上线时的性能是直接影响到用户使用体验的，而构建时间与我们的日常开发是密切相关，当我们本地开发启动 devServer 或者 build 的时候，如果时间过长，会大大降低我们的工作效率。 性能优化 - 代码分离代码分离（Code Splitting）是 webpack 一个非常重要的特性： 它主要的目的是将代码分离到不同的 bundle 中，之后我们可以按需加载，或者并行加载这些文件；比如默认情况下，所有的 JavaScript 代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度；代码分离可以分出更小的 bundle ，以及控制资源加载优先级，提供代码的加载性能； Webpack中常用的代码分离有三种： 入口起点：使用entry配置手动分离代码； 防止重复：使用Entry Dependencies或者SplitChunksPlugin去重和分离代码； 动态导入：通过模块的内联函数调用来分离代码； 入口起点优化-Entry Dependencies(入口依赖)当项目拥有多个入口点（entry points）时，可能会遇到一些重复依赖的问题。某些模块可能在多个入口点中被引用，导致这些模块被重复打包，增加了最终输出文件的体积。dependon-shared模块解决重复依赖 module.exports = &#123; entry: &#123; page1: &#123; import: './src/page1.js', dependOn: 'shared', &#125;, page2: &#123; import: './src/page2.js', dependOn: 'shared', &#125;, shared: './src/shared.js', &#125;, output: &#123; filename: '[name].bundle.js', path: __dirname + '/dist', &#125;, &#125;; 动态导入(dynamic import)动态导入是一种在Webpack中实现按需加载（Lazy Loading）的技术，允许在运行时异步加载模块，而不是在应用初始化时就把所有模块打包到一个大文件中。可以提高应用的初始加载速度，并且减小了初始包的体积。 const path = require('path'); module.exports = &#123; entry: &#123; main: './src/index.js', &#125;, output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist'), publicPath: '/', &#125;, module: &#123; rules: [ // 添加你的Loader规则 ], &#125;, optimization: &#123; splitChunks: &#123; chunks: 'all', &#125;, &#125;, &#125;; 在上述配置中，通过 optimization.splitChunks 进行代码分割，它的 chunks: &#39;all&#39; 选项表示对所有模块进行代码分割。 然后，在代码中使用 import() 函数进行动态导入： // 在需要的地方使用动态导入 const loadModule = () => import('./Module'); loadModule().then(module => &#123; // 使用加载的模块 &#125;); Webpack会将使用 import() 函数引入的模块进行代码分割，生成单独的文件。在运行时，这些文件会在需要的时候异步加载。 自定义分包-SplitChunks分包（code splitting）是一种优化策略，它允许将代码分割成小块，使得应用在加载时能够更快地显示内容。 Webpack提供了多种分包的模式，其中一种是使用SplitChunksPlugin插件来实现的，这个模式叫做splitChunks。 module.exports = &#123; // ...其他配置 optimization: &#123; splitChunks: &#123; chunks: 'all', minSize: 30000, // 模块的最小体积 minChunks: 1, // 模块的最小被引用次数 maxAsyncRequests: 5, // 按需加载时的最大并行请求数 maxInitialRequests: 3, // 入口点的最大并行请求数 automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10, reuseExistingChunk: true, &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true, &#125;, &#125;, &#125;, &#125;, &#125;; webpack-split-chunks-plugin 性能优化-CDNCDN称之为内容分发网络（Content Delivery Network或Content Distribution Network，缩写：CDN）， 它是指通过相互连接的网络系统，利用最靠近每个用户的服务器； 更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户； 来提供高性能、可扩展性及低成本的网络内容传递给用户； 在开发中，我们使用CDN主要是两种方式： 打包的所有静态资源，放到CDN服务器， 用户所有资源都是通过CDN服务器加载的； 一些第三方资源放到CDN服务器上； 使用CDN（Content Delivery Network，内容分发网络）是一种非常有效的性能优化策略，特别是在Webpack中。CDN可以加速网站的加载速度，减轻服务器负担，并提高用户体验。以下是如何在Webpack中配置和使用CDN的方法： 将第三方库引入CDN将你的项目中用到的第三方库（例如React、Vue、jQuery等）引入CDN。可以选择在HTML文件中直接引入CDN链接： &lt;script src=\"https://cdn.jsdelivr.net/npm/react@版本号/dist/react.min.js\">&lt;/script> &lt;script src=\"https://cdn.jsdelivr.net/npm/react-dom@版本号/dist/react-dom.min.js\">&lt;/script> 在Webpack中配置externals在Webpack的配置中使用externals字段，告诉Webpack哪些模块是外部引入的，不需要打包。 module.exports = &#123; // ...其他配置 externals: &#123; react: 'React', 'react-dom': 'ReactDOM', &#125;, &#125;; 然后在HTML文件中通过script标签引入CDN： &lt;script src=\"https://cdn.jsdelivr.net/npm/react@版本号/dist/react.min.js\">&lt;/script> &lt;script src=\"https://cdn.jsdelivr.net/npm/react-dom@版本号/dist/react-dom.min.js\">&lt;/script> 配置CDN的publicPath在Webpack的output字段中配置publicPath，指定在引入资源时使用的URL前缀，通常设置为CDN的地址： module.exports = &#123; // ...其他配置 output: &#123; // ...其他output配置 publicPath: 'https://cdn.example.com/', &#125;, &#125;; 这样在Webpack构建时，所有的资源引用路径都会加上CDN的地址前缀。 性能优化-提取css文件将CSS文件从JavaScript打包文件中提取出来是一种常见的性能优化策略。这样做的好处是可以减小JavaScript文件的体积，加快页面加载速度，并且使浏览器能够并行下载CSS和JavaScript文件，提高加载性能。在Webpack中，你可以使用mini-css-extract-plugin插件来实现CSS文件的提取。 配置Webpack 在Webpack配置文件中引入mini-css-extract-plugin插件，然后配置module.rules来处理CSS文件。 const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = &#123; // ...其他配置 module: &#123; rules: [ &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', // 可以加入其他的CSS处理loader，比如postcss-loader和sass-loader ], &#125;, ], &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: 'styles.css', // 提取出的CSS文件的文件名 &#125;), ], &#125;; 引入CSS文件 在JavaScript文件或者入口文件中引入CSS文件： import './styles.css'; 或者在HTML文件中使用link标签引入提取出来的CSS文件： &lt;link rel=\"stylesheet\" href=\"styles.css\"> 性能优化-打包文件命名(Hash,ContentHash,ChunkHash)在Webpack中，打包文件的命名是一个重要的性能优化策略。合适的命名方案可以确保浏览器能够正确地缓存文件，避免不必要的网络请求，提高应用的加载速度。以下是三种常见的打包文件命名方式：Hash、ContentHash 和 ChunkHash。 Hash（哈希）Hash 是根据文件内容生成的哈希值，当文件内容发生改变时，其对应的 Hash 值也会改变。在Webpack中，可以使用 [hash] 占位符来表示 Hash 值。 output: &#123; filename: 'bundle.[hash].js', &#125; ContentHash（内容哈希）ContentHash 是根据文件内容生成的哈希值，但是不同于 Hash 的是，ContentHash 只会受到文件内容的影响，不会受到文件名或路径等其他因素的影响。在Webpack中，可以使用 [contenthash] 占位符来表示 ContentHash 值。 output: &#123; filename: 'bundle.[contenthash].js', &#125; ChunkHash（块哈希）ChunkHash 是根据模块内容生成的哈希值，不同模块的内容不同，它们的 ChunkHash 值也会不同。在Webpack中，可以使用 [chunkhash] 占位符来表示 ChunkHash 值。 output: &#123; filename: '[name].[chunkhash].js', &#125; 性能优化-webpack实现Tree ShakingJavaScript的Tree Shaking： 对JavaScript进行Tree Shaking是源自打包工具rollup（后面我们也会讲的构建工具）； 这是因为Tree Shaking依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）； webpack2正式内置支持了ES2015模块，和检测未使用模块的能力； 在webpack4正式扩展了这个能力，并且通过 package.json的 sideEffects属性作为标记，告知webpack在编译时，哪里文 件可以安全的删除掉； webpack5中，也提供了对部分CommonJS的tree shaking的支持； commonjs-tree-shaking JS实现Tree Shakingwebpack实现Tree Shaking采用了两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的； sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用； CSS进行Tree ShakingCSS的Tree Shaking需要借助于一些其他的插件； 在早期的时候，我们使用PurifyCss插件来完成CSS的tree shaking，但是目前该库已经不再维护； 目前我们可以使用另外一个库来完成CSS的Tree Shaking：PurgeCSS，也是一个帮助我们删除未使用的CSS的工具: PurgeCss","link":"/2023/10/26/Webpack-optimization-1/"},{"title":"Webpack 性能优化-2","text":"性能优化 - JS-CSS代码压缩 Terser是一个JavaScript的解释（Parser）、Mangler（绞肉机）&#x2F;Compressor（压缩机）的工具集； 早期我们会使用 uglify-js来压缩、丑化我们的JavaScript代码，但是目前已经不再维护，并且不支持ES6+的语法； Terser是从 uglify-es fork 过来的，并且保留它原来的大部分API以及适配 uglify-es和uglify-js@3等； webpack-terser JavaScript 代码压缩Webpack 提供了terser-webpack-plugin 插件进行代码优化和压缩。 在production模式下，默认就是使用TerserPlugin来处理代码。 const TerserPlugin = require('terser-webpack-plugin'); module.exports = &#123; // 配置其他Webpack选项... optimization: &#123; minimizer: [new TerserPlugin()], &#125;, &#125;; CSS 代码压缩除了JavaScript代码，CSS代码也可以通过Webpack进行压缩。使用css-minimizer-webpack-plugin 进行压缩CSS代码。 const CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); module.exports = &#123; // 配置其他Webpack选项... optimization: &#123; minimizer: [ new CssMinimizerPlugin(), // 可以继续添加其他压缩插件... ], &#125;, &#125;; webpack实现Tree Shakingtree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。 Webpack 实现 Tree Shaking在现代的前端开发中，代码体积优化是一个关键的议题。Tree Shaking 是一种用于消除未引用代码的优化技术，它可以帮助我们剔除项目中未使用的 JavaScript 模块，从而减小打包后的文件体积。Webpack 提供了内置的支持，使得 Tree Shaking 在项目中变得非常容易实现。 开启 ES 模块化首先，确保你的 JavaScript 代码采用了 ES 模块化的方式，因为Webpack 的 Tree Shaking 功能仅对 ES 模块有效。你可以在项目中使用 import 和 export 语法来定义模块。 // math.js export function square(x) &#123; return x * x; &#125; export function cube(x) &#123; return x * x * x; &#125; Webpack 配置在 Webpack 的配置文件中，确保以下几点设置，以启用 Tree Shaking： 将 mode 设置为 &#39;production&#39;，Webpack 会自动启用相关的优化，包括 Tree Shaking。 JS实现Tree Shakingwebpack实现Tree Shaking采用了两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的； sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用； 使用usedExports实现Tree Sharking配置模式为production module.exports = &#123; mode: 'production', // ...其他配置 &#125;; 配置optimization里面的usedExports const path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), &#125;, mode: 'development', optimization: &#123; usedExports: true, &#125;, &#125;; 使用sideEffect实现Tree Sharking在package.json中设置sideEffects的值： 如果我们将sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports； 如果有一些我们希望保留，可以设置为数组； &#123; &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: [&quot;.&#x2F;src&#x2F;some-side-effectful-file.js&quot;] &#125; Webpack 中的 sideEffects 解释 tree shaking 和 sideEffectssideEffects 和 usedExports（更多被认为是 tree shaking）是两种不同的优化方式。 sideEffects 更为有效 是因为它允许跳过整个模块&#x2F;文件和整个文件子树。 usedExports 依赖于 terser 去检测语句中的副作用。它是一个 JavaScript 任务而且没有像 sideEffects 一样简单直接。而且它不能跳转子树&#x2F;依赖由于细则中说副作用需要被评估。尽管导出函数能运作如常，但 React 框架的高阶函数（HOC）在这种情况下是会出问题的。 CSS实现TreeShakingCSS的Tree Shaking需要借助于一些其他的插件； 在早期的时候，我们会使用PurifyCss插件来完成CSS的tree shaking，但是目前该库已经不再维护了（最新更新也是在4年前 了）； 目前我们可以使用另外一个库来完成CSS的Tree Shaking：PurgeCSS，也是一个帮助我们删除未使用的CSS的工具； Webpack对文件压缩什么是HTTP压缩HTTP压缩是一种内置在 服务器 和 客户端 之间的，以改进传输速度和带宽利用率的方式；HTTP压缩的流程什么呢？第一步：HTTP数据在服务器发送前就已经被压缩了；（可以在webpack中完成）第二步：兼容的浏览器在向服务器发送请求时，会告知服务器自己支持哪些压缩格式；第三步：服务器在浏览器支持的压缩格式下，直接返回对应的压缩后的文件，并且在响应头中告知浏览器； 目前的流行压缩格式目前的压缩格式非常的多：compress – UNIX的“compress”程序的方法（历史性原因，不推荐大多数应用使用，应该使用gzip或deflate）；deflate – 基于deflate算法（定义于RFC 1951）的压缩，使用zlib数据格式封装；gzip – GNU zip格式（定义于RFC 1952），是目前使用比较广泛的压缩算法；br – 一种新的开源压缩算法，专为HTTP内容的编码而设计； Webpack配置文件压缩webpack中相当于是实现了HTTP压缩的第一步操作，我们可以使用CompressionPlugin。 第一步，安装CompressionPlugin： npm install compression-webpack-plugin -D 第二步，使用CompressionPlugin即可 module.exports = &#123; plugins: [ new CompressionPlugin(&#123; test: /\\.js(\\?.*)?$/i, &#125;), ], &#125;;","link":"/2023/10/27/Webpack-optimization-2/"},{"title":"Webpack 中的 sideEffects 该怎么用","text":"webpack v4 开始新增了一个 sideEffects 特性，通过给 package.json 加入 sideEffects 声明该 包&#x2F;模块 是否包含 sideEffects(副作用)，从而可以为 tree-shaking 提供更大的优化空间。 基于我们对 side effect 的常规理解，我们可以认为，只要我们确定当前包里的模块不包含副作用，然后将发布到 npm 里的包标注为 sideEffects: false ，我们就能为使用方提供更好的打包体验。原理是 webpack 能将标记为 side-effects-free 的包由 import &#123;a&#125; from xx 转换为 import &#123;a&#125; from &#39;xx/a&#39;，从而自动修剪掉不必要的 import，作用同 babel-plugin-import。 Tree Shaking 与副作用Tree-Shaking在前端界由rollup首先提出并实现，后续webpack在2.x版本也借助于UglifyJS实现了。自那以后，在各类讨论优化打包的文章中，都能看到Tree-Shaking的身影。 Tree-Shaking的原理ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。 分析程序流，判断哪些变量未被使用、引用，进而删除此代码。 很好，原理非常完美，那为什么有时候我们项目里面多余的的代码又删不掉呢？ 先说原因：都是副作用的锅！ 副作用了解过函数式编程的同学对副作用这词肯定不陌生。它大致可以理解成：一个函数会、或者可能会对函数外部变量产生影响的行为。 举个例子，比如这个函数： function go (url) &#123; window.location.href = url &#125; 这个函数修改了全局变量location，甚至还让浏览器发生了跳转，这就是一个有副作用的函数。 // componetns.js export class Person &#123; constructor (&#123; name &#125;) &#123; this.className = 'Person' this.name = name &#125; getName () &#123; return this.name &#125; &#125; export class Apple &#123; constructor (&#123; model &#125;) &#123; this.className = 'Apple' this.model = model &#125; getModel () &#123; return this.model &#125; &#125; // main.js import &#123; Apple &#125; from './components' const appleModel = new Apple(&#123; model: 'IphoneX' &#125;).getModel() console.log(appleModel) 很显然这个Person类是无用的代码 而为什么有时候别的工具，比如rollup在线repl尝试了下tree-shaking，也确实删掉了无用的代码 而使用webpack打包工具却不能进行有效的代码消除呢？ 答案是：babel编译 + webpack打包 在这边贴一个链接，是有关于详细介绍babel编译 + webpack打包是怎么让你无效的代码消除不掉的。你的Tree-Shaking并没什么卵用 如果不想看文章的话，这边直接简单说一下原理：babel编译会使得Person类被封装成了一个IIFE(立即执行函数)，然后返回一个构造函数，在这边就产生了一个副作用。 这边有个Issues，IIFE 中的类声明被视为副作用 当我在 IIFE 中声明一个类，但没有使用类时，它不会被 UglifyJS 剥离，因为它被认为是副作用。 var V6Engine = (function () &#123; function V6Engine() &#123; &#125; V6Engine.prototype.toString = function () &#123; return 'V6'; &#125;; return V6Engine; &#125;()); 编译时收到这样的警告：WARN: Side effects in initialization of unused variable V6Engine [./dist/car.bundle.js:74,4] 下面给出的回复：Uglify 没做执行程序流分析。它并不会因为你注意到的副作用而删除代码。你要是想弄个完善一点的摇树，去隔壁rollup呗！ issue中总结下几点关键信息： 函数的参数若是引用类型，对于它属性的操作，都是有可能会产生副作用的。因为首先它是引用类型，对它属性的任何修改其实都是改变了函数外部的数据。其次获取或修改它的属性，会触发getter或者setter，而getter、setter是不透明的，有可能会产生副作用。 uglify没有完善的程序流分析。它可以简单的判断变量后续是否被引用、修改，但是不能判断一个变量完整的修改过程，不知道它是否已经指向了外部变量，所以很多有可能会产生副作用的代码，都只能保守的不删除。 rollup有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。 但这已经是很久之前的版本问题，现在的webpack tree shaking已经做了很多的优化，足够的程序流分析进行tree shaking webpack 的 tree shaking 的作用是可以将未被使用的 exported member 标记为 unused 同时在将其 re-export 的模块中不再 export。说起来很拗口，看代码： // a.js export function a() &#123;&#125; // b.js export function b()&#123;&#125; // package/index.js import a from './a' import b from './b' export &#123; a, b &#125; // app.js import &#123;a&#125; from 'package' console.log(a) 当我们以 app.js 为 entry 时，经过摇树后的代码会变成这样： // a.js export function a() &#123;&#125; // b.js 不再导出 function b()&#123;&#125; function b() &#123;&#125; // package/index.js 不再导出 b 模块 import a from './a' import './b' export &#123; a &#125; // app.js import &#123;a&#125; from 'package' console.log(a) 配合 webpack 的 scope hoisting 和 uglify 之后，b 模块的痕迹会被完全抹杀掉。 但是如果 b 模块中添加了一些副作用，比如一个简单的 log： // b.js export function b(v) &#123; reutrn v &#125; console.log(b(1)) webpack 之后会发现 b 模块内容变成了： // b.js console.log(function (v)&#123;return v&#125;(1)) 虽然 b 模块的导出是被忽略了，但是副作用代码被保留下来了。 由于目前 transformer 转换后可能引入的各种奇怪操作引发的副作用，很多时候我们会发现就算有了 tree shaking 我们的 bundle size 还是没有明显的减小。 而通常我们期望的是 b 模块既然不被使用了，其中所有的代码应该不被引入才对。 这个时候 sideEffects 的作用就显现出来了：如果我们引入的 包&#x2F;模块 被标记为 sideEffects: false 了，那么不管它是否真的有副作用，只要它没有被引用到，整个 模块&#x2F;包 都会被完整的移除。 以 mobx-react-devtool 为例，我们通常这样去用： import DevTools from 'mobx-react-devtools'; class MyApp extends React.Component &#123; render() &#123; return ( &lt;div> ... &#123; process.env.NODE_ENV === 'production' ? null : &lt;DevTools /> &#125; &lt;/div> ); &#125; &#125; 这是一个很常见的按需导入场景，然而在没有 sideEffects: false 配置时，即便 NODE_ENV 设为 production ，打包后的代码里依然会包含 mobx-react-devtools 包，虽然我们没使用过其导出成员，但是 mobx-react-devtools 还是会被 import，因为里面“可能”会有副作用。 但当我们加上 sideEffects false 之后，tree shaking 就能安全的把它从 bundle 里完整的移除掉了。 sideEffects 的使用场景上面也说到，通常我们发布到 npm 上的包很难保证其是否包含副作用（可能是代码的锅可能是 transformer 的锅），但是我们基本能确保这个包是否会对包以外的对象产生影响，比如是否修改了 window 上的属性，是否复写了原生对象方法等。如果我们能保证这一点，其实我们就能知道整个包是否能设置 sideEffects: false了，至于是不是真的有副作用则并不重要，这对于 webpack 而言都是可以接受的。 这也就能解释为什么能给 vue 这个本身充满副作用的包加上 sideEffects: false 了。 所以其实 webpack 里的 sideEffects: false 的意思并不是我这个模块真的没有副作用，而只是为了在摇树时告诉 webpack：我这个包在设计的时候就是期望没有副作用的，即使他打完包后是有副作用的。","link":"/2023/10/27/Webpack-optimization-3/"},{"title":"Webpack HMR 原理解析","text":"前言Hot Module Replacement（以下简称 HMR）是 Webpack 发展至今一大特性 ，当你对代码进行修改并保存后，Webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。 例如，在开发 Web 页面过程中，当你点击按钮，出现一个弹窗的时候，发现弹窗标题没有对齐，这时候你修改 CSS 样式，然后保存，在浏览器没有刷新的前提下，标题样式发生了改变。感觉就像在 Chrome 的开发者工具中直接修改元素样式一样。 模块热替换(hot module replacement)模块热替换(HMR - hot module replacement)功能会在应用程序运行过程中，替换、添加或删除 模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面期间丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 在源代码中 CSS&#x2F;JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。 为什么需要 HMR在 webpack HMR 功能之前，已经有很多 live reload 的工具或库，比如 live-server，这些库监控文件的变化，然后通知浏览器端刷新页面，那么我们为什么还需要 HMR 呢？答案其实在上文中已经提及一些。 live reload 工具并不能够保存应用的状态（states），当刷新页面后，应用之前状态丢失，还是上文中的例子，点击按钮出现弹窗，当浏览器刷新后，弹窗也随即消失，要恢复到之前状态，还需再次点击按钮。而 webapck HMR 则不会刷新浏览器，而是运行时对模块进行热替换，保证了应用状态不会丢失，提升了开发效率。 在古老的开发流程中，我们可能需要手动运行命令对代码进行打包，并且打包后再手动刷新浏览器页面，而这一系列重复的工作都可以通过 HMR 工作流来自动化完成，让更多的精力投入到业务中，而不是把时间浪费在重复的工作上。 HMR 兼容市面上大多前端框架或库，比如 React Hot Loader，Vue-loader，能够监听 React 或者 Vue 组件的变化，实时将最新的组件更新到浏览器端。Elm Hot Loader 支持通过 webpack 对 Elm 语言代码进行转译并打包，当然它也实现了 HMR 功能。 HMR 的工作原理图解初识 HMR 的时候觉得其很神奇，一直有一些疑问萦绕在脑海。 webpack 可以将不同的模块打包成 bundle 文件或者几个 chunk 文件，但是当我通过 webpack HMR 进行开发的过程中，我并没有在我的 dist 目录中找到 webpack 打包好的文件，它们去哪呢？ 通过查看 webpack-dev-server 的 package.json 文件，我们知道其依赖于 webpack-dev-middleware 库，那么 webpack-dev-middleware 在 HMR 过程中扮演什么角色？ 使用 HMR 的过程中，通过 Chrome 开发者工具我知道浏览器是通过 websocket 和 webpack-dev-server 进行通信的，但是 websocket 的 message 中并没有发现新模块代码。打包后的新模块又是通过什么方式发送到浏览器端的呢？为什么新的模块不通过 websocket 随消息一起发送到浏览器端呢？ 浏览器拿到最新的模块代码，HMR 又是怎么将老的模块替换成新的模块，在替换的过程中怎样处理模块之间的依赖关系？ 当模块的热替换过程中，如果替换模块失败，有什么回退机制吗？ 带着上面的问题，于是决定深入到 webpack 源码，寻找 HMR 底层的奥秘。 图一：HMR 工作流程图解 上图是webpack 配合 webpack-dev-server 进行应用开发的模块热更新流程图。 上图底部红色框内是服务端，而上面的橙色框是浏览器端。 绿色的方框是 webpack 代码控制的区域。蓝色方框是 webpack-dev-server 代码控制的区域，洋红色的方框是文件系统，文件修改后的变化就发生在这，而青色的方框是应用本身。 上图显示了我们修改代码到模块热更新完成的一个周期，通过深绿色的阿拉伯数字符号已经将 HMR 的整个过程标识了出来。 第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。 第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。 第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。 第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。 webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack ，webpack/hot/dev-server 的工作就是根据webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。 HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。 而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。 最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。 运用 HMR 的简单例子在上一个部分，通过一张 HMR 流程图，简要的说明了 HMR 进行模块热更新的过程。当然你可能感觉还是很迷糊，对上面出现的一些英文名词也可能比较陌生（上面这些英文名词代表着代码仓库或者仓库中的文件模块），没关系，在这一部分，我将通过一个最简单最纯粹的例子，通过分析 wepack及 webpack-dev-server 源码详细说明各个库在 HMR 过程中的具体职责。 这边我通过一个简单的vue例子示例一下，这边贴一个仓库的连接github.com&#x2F;ikkkp&#x2F;webpack-vue-demo 在开始这个例子之前简单对这个仓库文件进行下说明，仓库中包含文件如下： const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const &#123; VueLoaderPlugin &#125; = require('vue-loader'); const webpack = require('webpack'); // 引入 webpack const AutoImport = require('unplugin-auto-import/webpack') const Components = require('unplugin-vue-components/webpack') const &#123; ElementPlusResolver &#125; = require('unplugin-vue-components/resolvers') /** * @description * @version 1.0 * @author Huangzl * @fileName webpack.base.config.js * @date 2023/11/10 11:00:59 */ module.exports = &#123; entry: &#123; main: './src/main', //单页应用开发模式禁用多入口 &#125;, resolveLoader: &#123; modules: [ 'node_modules', path.resolve(__dirname, './src/loader') ] &#125;, output: &#123; filename: '[id].[fullhash].js', // 使用 [fullhash] 替代 [hash]，这是新版本 webpack 的写法 path: path.join(__dirname, 'dist'), publicPath: './' &#125;, module: &#123; rules: [&#123; test: /\\.vue$/, loader: 'vue-loader' &#125;, &#123; test: /\\.css$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, 'postcss-loader' ] &#125;, &#123; test: /\\.js$/, use: ['babel-loader', &#123; loader: 'company-loader', options: &#123; sign: 'we-doctor@2021', &#125;, &#125;,], exclude: /node_modules/, &#125;, &#123; test: /\\.(ico|png|jpg|gif|svg|eot|woff|woff2|ttf)$/, loader: 'file-loader', options: &#123; name: '[name].[ext]?[hash]' &#125; &#125;, ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './public/index.html' &#125;), new VueLoaderPlugin(), new webpack.DefinePlugin(&#123; BASE_URL: JSON.stringify('./') // 这里定义了 BASE_URL 为根路径 '/' &#125;), AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver()], &#125;), ], optimization: &#123; splitChunks: &#123; chunks: 'all', // 只处理异步模块 maxSize: 20000000, // 设置最大的chunk大小为2MB &#125;, &#125;, &#125;; 值得一提的是，在上面的配置中并没有配置 HotModuleReplacementPlugin，原因在于当我们设置 devServer.hot 为 true 后，并且在package.json 文件中添加如下的 script 脚本： “start”: “webpack-dev-server –hot –open” 添加 —hot 配置项后，devServer 会告诉 webpack 自动引入 HotModuleReplacementPlugin 插件，而不用我们再手动引入了。 上面给的是webpack.base.config.js的内容，我们下面通过修改App.vue的内容进行: - &lt;div&gt;hello&lt;&#x2F;div&gt; &#x2F;&#x2F; 将 hello 字符串修改为 hello world + &lt;div&gt;hello world&lt;&#x2F;div&gt; 第一步：webpack 对文件系统进行 watch 打包到内存中 webpack-dev-middleware 调用 webpack 的 api 对文件系统 watch，当 hello.js 文件发生改变后，webpack 重新对文件进行编译打包，然后保存到内存中。 // webpack-dev-middleware/lib/Shared.js if(!options.lazy) &#123; var watching = compiler.watch(options.watchOptions, share.handleCompilerCallback); context.watching = watching; &#125; 你可能会疑问了，为什么 webpack 没有将文件直接打包到 output.path 目录下呢？文件又去了哪儿？原来 webpack 将 bundle.js 文件打包到了内存中，不生成文件的原因就在于访问内存中的代码比访问文件系统中的文件更快，而且也减少了代码写入文件的开销，这一切都归功于memory-fs，memory-fs 是 webpack-dev-middleware 的一个依赖库，webpack-dev-middleware 将 webpack 原本的 outputFileSystem 替换成了MemoryFileSystem 实例，这样代码就将输出到内存中。webpack-dev-middleware 中该部分源码如下： // webpack-dev-middleware/lib/Shared.js var isMemoryFs = !compiler.compilers &amp;&amp; compiler.outputFileSystem instanceof MemoryFileSystem; if(isMemoryFs) &#123; fs = compiler.outputFileSystem; &#125; else &#123; fs = compiler.outputFileSystem = new MemoryFileSystem(); &#125; 首先判断当前 fileSystem 是否已经是 MemoryFileSystem 的实例，如果不是，用 MemoryFileSystem 的实例替换 compiler 之前的 outputFileSystem。这样 bundle.js 文件代码就作为一个简单 javascript 对象保存在了内存中，当浏览器请求 bundle.js 文件时，devServer就直接去内存中找到上面保存的 javascript 对象返回给浏览器端。 第二步：devServer 通知浏览器端文件发生改变 在这一阶段，sockjs 是服务端和浏览器端之间的桥梁，在启动 devServer 的时候，sockjs 在服务端和浏览器端建立了一个 webSocket 长连接，以便将 webpack 编译和打包的各个阶段状态告知浏览器，最关键的步骤还是 webpack-dev-server 调用 webpack api 监听 compile的 done 事件，当compile 完成后，webpack-dev-server通过 _sendStatus 方法将编译打包后的新模块 hash 值发送到浏览器端。 // webpack-dev-server/lib/Server.js compiler.plugin('done', (stats) => &#123; // stats.hash 是最新打包文件的 hash 值 this._sendStats(this.sockets, stats.toJson(clientStats)); this._stats = stats; &#125;); ... Server.prototype._sendStats = function (sockets, stats, force) &#123; if (!force &amp;&amp; stats &amp;&amp; (!stats.errors || stats.errors.length === 0) &amp;&amp; stats.assets &amp;&amp; stats.assets.every(asset => !asset.emitted) ) &#123; return this.sockWrite(sockets, 'still-ok'); &#125; // 调用 sockWrite 方法将 hash 值通过 websocket 发送到浏览器端 this.sockWrite(sockets, 'hash', stats.hash); if (stats.errors.length > 0) &#123; this.sockWrite(sockets, 'errors', stats.errors); &#125; else if (stats.warnings.length > 0) &#123; this.sockWrite(sockets, 'warnings', stats.warnings); &#125; else &#123; this.sockWrite(sockets, 'ok'); &#125; &#125;; 第三步：webpack-dev-server&#x2F;client 接收到服务端消息做出响应 可能你又会有疑问，我并没有在业务代码里面添加接收 websocket 消息的代码，也没有在 webpack.config.js 中的 entry 属性中添加新的入口文件，那么 bundle.js 中接收 websocket 消息的代码从哪来的呢？原来是 webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。 webpack-dev-server&#x2F;client 当接收到 type 为 hash 消息后会将 hash 值暂存起来，当接收到 type 为 ok 的消息后对应用执行 reload 操作，如下图所示，hash 消息是在 ok 消息之前。 在 reload 操作中，webpack-dev-server&#x2F;client 会根据 hot 配置决定是刷新浏览器还是对代码进行热更新（HMR）。 首先将 hash 值暂存到 currentHash 变量，当接收到 ok 消息后，对 App 进行 reload。如果配置了模块热更新，就调用 webpack&#x2F;hot&#x2F;emitter 将最新 hash 值发送给 webpack，然后将控制权交给 webpack 客户端代码。如果没有配置模块热更新，就直接调用 location.reload 方法刷新页面。 第四步：webpack 接收到最新 hash 值验证并请求模块代码 在这一步，其实是 webpack 中三个模块（三个文件，后面英文名对应文件路径）之间配合的结果，首先是 webpack/hot/dev-server（以下简称 dev-server） 监听第三步 webpack-dev-server/client 发送的 webpackHotUpdate 消息，调用 webpack&#x2F;lib&#x2F;HotModuleReplacement.runtime（简称 HMR runtime）中的 check 方法，检测是否有新的更新，在 check 过程中会利用 webpack&#x2F;lib&#x2F;JsonpMainTemplate.runtime（简称 jsonp runtime）中的两个方法 hotDownloadUpdateChunk 和 hotDownloadManifest ， 第二个方法是调用 AJAX 向服务端请求是否有更新的文件，如果有将发更新的文件列表返回浏览器端，而第一个方法是通过 jsonp 请求最新的模块代码，然后将代码返回给 HMR runtime，HMR runtime 会根据返回的新模块代码做进一步处理，可能是刷新页面，也可能是对模块进行热更新。 值得注意的是，两次请求的都是使用上一次的 hash 值拼接的请求文件名，hotDownloadManifest 方法返回的是最新的 hash 值，hotDownloadUpdateChunk 方法返回的就是最新 hash 值对应的代码块。然后将新的代码块返回给 HMR runtime，进行模块热更新 第五步：HotModuleReplacement.runtime 对模块进行热更新 这一步是整个模块热更新（HMR）的关键步骤，而且模块热更新都是发生在HMR runtime 中的 hotApply 方法中 // webpack/lib/HotModuleReplacement.runtime function hotApply() &#123; // ... var idx; var queue = outdatedModules.slice(); while(queue.length > 0) &#123; moduleId = queue.pop(); module = installedModules[moduleId]; // ... // remove module from cache delete installedModules[moduleId]; // when disposing there is no need to call dispose handler delete outdatedDependencies[moduleId]; // remove \"parents\" references from all children for(j = 0; j &lt; module.children.length; j++) &#123; var child = installedModules[module.children[j]]; if(!child) continue; idx = child.parents.indexOf(moduleId); if(idx >= 0) &#123; child.parents.splice(idx, 1); &#125; &#125; &#125; // ... // insert new code for(moduleId in appliedUpdate) &#123; if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) &#123; modules[moduleId] = appliedUpdate[moduleId]; &#125; &#125; // ... &#125; 从上面 hotApply 方法可以看出，模块热替换主要分三个阶段，第一个阶段是找出 outdatedModules 和 outdatedDependencies，这儿我没有贴这部分代码，有兴趣可以自己阅读源码。第二个阶段从缓存中删除过期的模块和依赖，如下： delete installedModules[moduleId]; delete outdatedDependencies[moduleId]; 第三个阶段是将新的模块添加到 modules 中，当下次调用 webpack_require (webpack 重写的 require 方法)方法的时候，就是获取到了新的模块代码了。 模块热更新的错误处理，如果在热更新过程中出现错误，热更新将回退到刷新浏览器，这部分代码在 dev-server 代码中，简要代码如下： module.hot.check(true).then(function(updatedModules) &#123; if(!updatedModules) &#123; return window.location.reload(); &#125; // ... &#125;).catch(function(err) &#123; var status = module.hot.status(); if([\"abort\", \"fail\"].indexOf(status) >= 0) &#123; window.location.reload(); &#125; &#125;); dev-server 先验证是否有更新，没有代码更新的话，重载浏览器。如果在 hotApply 的过程中出现 abort 或者 fail 错误，也进行重载浏览器。","link":"/2023/11/10/Webpack-optimization-4/"},{"title":"輕鬆理解 Ajax 與跨來源請求","text":"前言一般來說在學習寫網頁的時候，最先碰到的會是 HTML 與 CSS，負責把版面刻出來以及美化版面，當基礎打穩之後，會開始學習 JavaScript，試著做出一點互動性的效果。而「互動」除了使用者跟瀏覽器的互動以外，別忘了還有 Client 端跟 Server 端的互動，也就是必須要學會從瀏覽器用 JavaScript 跟後端 Server 拿資料，否則你的網頁資料都只能是寫死的。 這篇的主要預設讀者是網頁前端的初學者，希望能讓本來不太理解怎麼跟 Server 交換資料或是怎麼串 APi 的讀者看完之後，能夠更了解該怎麼跟後端串接。 先從舉例開始在開始之前，我們可以先想想一個問題： 為什麼前端必須跟後端交換資料？ 其實這跟你做的網頁類型有關，假如說你今天做的是一個官方網站，很可能整個網站都是靜態的，只要 HTML 跟 CSS 就可以了，並不需要跟後端 Server 拿資料。 那我們先假設今天要做的是一個可以瀏覽現在 Twitch 實況列表的網頁好了，如下圖。 如果這個網頁不跟後端拿資料，就代表說網頁的內容都是固定的，無論什麼時候看都一樣。可是這樣的話就不對了嘛，因為這個網頁的目標是顯示出「現在有在開實況的頻道」，所以內容是會跟著改變的。 既然會跟著改變，就必須不斷的去更新資料，從 Server 那邊拿資料回來，接著在前端處理過後顯示。 已經確認有拿資料的必要性之後，就可以問自己兩個問題： 要跟誰拿資料？ 要怎麼拿資料？ 第一個問題，很明顯的就是跟 Twitch，因為 Twitch 才有你要的這些資料嘛！ 那第二個問題，要怎麼拿資料呢？就必須透過 Twitch API 了。 API什麼是 API？你可能已經聽過很多次這個名詞，但還是不知道是什麼。先來講講它的全名吧，它的全名是「Application Programming Interface」，中文翻作應用程式介面。 你可能會想說這是什麼鬼東西，怎麼中文英文我都看不懂在幹嘛。但其實這幾個字裡面，最重要的是「介面」兩個字。 介面是什麼？介面就是拿來串接用的，我舉一個例子你就知道了。 電腦上不是有一個 USB 插槽嗎？然後你只要是看到市面上有賣 USB 隨身碟的，都可以買來以後插到 USB 插槽，你的電腦就可以讀取得到。你有想過為什麼嗎？明明就是不同廠商做的東西，可是卻都可以讀得到、都可以插到 USB 插槽裡面。 因為有一項標準叫做 USB 介面，當這套標準訂出來以後，所有廠商只要按照這一套標準來開發，就可以保證能夠連接電腦跟 USB 隨身碟。 API 也是這樣，只是變成程式跟程式之間的串接。例如說今天我寫程式需要讀取檔案好了，我要怎麼讀取檔案？讀取檔案是作業系統提供的功能，因此我可以去串接「讀取檔案的 API」，就可以在我的程式裡面也使用這個功能了。 再多舉幾個例子你可能會更有感覺。 例如說今天我想要讓我的網頁能夠用 Facebook 登入，那要怎麼辦？我就要去串接「Facebook 提供的 API」，就等於說是 Facebook 向外提供給大家的一套介面、一套標準，任何想要接入 Facebook 服務的開發者們，都可以遵循著那套規範拿到自己想要的資料，這個東西就叫做 API。 或是你可能今天是一個飯店管理系統的開發者，你們公司做了一套給飯店用的 ERP，可以管理飯店的訂房狀態等等，就能知道說現在有哪些房間是空的。 而這些資料如果只有自己用太可惜了，於是公司決定把這些資料提供給大型訂房網站，在那些網站上能夠即時顯示這間飯店的房間狀況。所以就必須交換資料，你要提供一個「查詢房間情形的 API」給其他網站，讓他們能夠去串接，才能獲得這些資訊。 講到這邊，大家應該對 API 已經有一些 sense 了，我再多舉幾個例子： 我想要抓到 flickr 上面的照片，所以我要去串接 flickr 的 API Google 要開放讓其他 App 也能用 Google 登入驗證，所以 Google 要提供「Google 登入 API」 我要抓 Twitch 上面現在有哪些頻道，所以要串 Twitch API API Documentation既然已經知道 API 是什麼了，也知道要串接 API，那下一個問題就是「那要怎麼串呢？」 剛剛前面有提過檔案存取的例子，其實這個比較像是呼叫作業系統或是程式語言的函式庫提供的 Function，而這些 Function 你通常都可以在官方文件上查到更詳細的說明，例如說 Node.js 的讀取檔案： （來源：https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback） 上面就有寫說你應該呼叫哪一個 Function，應該傳入哪些參數。 API 的串接也是一樣，一定要有文件你才知道怎麼串，不然根本串不起來，因為你連要傳什麼參數都不知道。 我們可以先來看看Twitch API 文件是怎麼寫的。 裡面說明了你必須要有一個Client ID，然後 API Root 的 URL 是 https://api.twitch.tv/kraken 等等，這些都是與 API 相關的基本資訊。如果你在左側欄隨便點一個 API，會看到個別 API 的詳細資訊： 這邊就有寫說網址是什麼，你應該傳的參數是什麼等等，下面還有附上參考範例，這就是一個很完整的 API 文件。 通常在寫網頁的時候，我們都會直接講 API，但其實我們指的是 Web API，也就是透過網路來傳輸的 API。那有沒有非 Web API 呢？有，像我們前面提到的跟作業系統要讀檔的 API，就都是在本機底下執行的，沒有透過任何網路。 不過這其實也不用太在意，反正大家都習慣講 API，聽得懂就好。 現在有了 API 文件，我們就有了所有我們需要的資訊。以上面這個 Twitch 的例子來講，我們只要能夠發送 Request 到https://api.twitch.tv/kraken/games/top?client_id=xxx，Twitch 就會傳回目前最熱門的遊戲列表。 我們已經把問題的範圍一步步給縮小了，一開始是「要怎麼跟 Twitch 拿資料」，現在則更細的切分為：「要怎麼利用 JavaScript 發送 Reuqest」 Ajax要在瀏覽器上面發送 Request，必須應用到一種技術叫做 Ajax，全名是「Asynchronous JavaScript and XML」，重點在於Asynchronous這個單字，非同步。 在講什麼是非同步之前，就要先來提一下什麼是同步。你原本寫的 JavaScript 就幾乎都是同步執行的。意思是他執行到某一行的時候，會等這行執行完畢，才執行到下一行，確保執行順序。 也就是說下面這段程式碼，最後一行需要等很長一段時間才能執行到： var count = 10000000; while(count--) &#123; // 做一些耗時的操作 &#125; // 等很久才被執行到 console.log('done') 看起來滿有道理的，程式本來不就是一行一行執行的嗎？可是如果今天牽涉到網路操作的話，大家可以思考看看下面這個例子： // 假設有個發送 Request 的函式叫做 sendRequest var result = sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx'); // 等很久才被執行到 console.log(result); 當 JavaScript 執行到sendRequest的時候，由於是同步的，就會等待 Response 回來才繼續做事。換句話說，在 Response 還沒回來之前，整個 JavaScript 引擎是不會執行任何東西的！很可怕對吧，你點任何有牽涉到 JavaScript 的東西，都不會有反應，因為 JavaScript 還在等 Response 回來。 所以呢，像是這種已經預期到可能非常耗時間，非常不穩定的操作，就不能用同步的方式來執行，而是要用非同步。 非同步是什麼意思呢？就是執行完之後就不管它了，不等結果回來就繼續執行下一行： // 假設有個發送 Request 的函式叫做 sendRequest var result = sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx'); // 上面 Request 發送完之後就執行到這一行，所以 result 不會有東西 // 因為 Response 根本沒有回來 console.log(result); 這邊需要特別注意的是「非同步的 Function 不能直接透過 return 把結果傳回來」，為什麼？因為像上面這個例子，它發送 Request 之後就會執行到下一行了，這個時候根本就還沒有 Response，是要回傳什麼？ 那怎麼辦呢？先聽我舉個很常見的小例子吧！ 我之前在新加坡的 Food Court 吃飯的時候，那邊每一張桌子上面都會有桌號。你去點餐的時候，只要跟老闆講說你坐哪一桌，等餐點完成之後老闆就會自己主動送過來。 所以我不需要站在店家門口等，我只要在位子上繼續坐我的事情，反正餐點好了之後老闆會送過來。 非同步的概念也是這樣，我發送 Request 之後（我點餐之後），我不用等 Response 回來（不用等老闆做好），可以繼續做自己的事，等 Response 回來之後（等餐點做好之後），會自己幫我把結果送過來（老闆會自己送過來）。 在點餐的例子中，老闆可以透過桌號知道應該把資料送到哪邊，那在 JavaScript 裡面呢？可以透過 Function！而這個 Function，我們就稱作 Callback Function，回呼函式。 當非同步的操作完成時，就可以呼叫這個 Function，並且把資料帶進來。 // 假設有個發送 Request 的函式叫做 sendRequest sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx', callMe); function callMe (response) &#123; console.log(response); &#125; // 或者寫成匿名函式 sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx', function (response) &#123; console.log(response); &#125;); 現在你就知道為什麼網路的操作是非同步，以及什麼是 callback function 了。 XMLHttpRequest方才提到 Ajax、非同步以及 callback function 的概念，但還是沒講到要怎麼發送 Request，只寫了一個假的sendRequest函式當作參考而已。 要發送 Request 的話，就要透過瀏覽器幫我們準備好的一個物件，叫做XMLHttpRequest，範例程式碼如下： var request = new XMLHttpRequest(); request.open('GET', `https://api.twitch.tv/kraken/games/top?client_id=xxx`, true); request.onload = function() &#123; if (request.status >= 200 &amp;&amp; request.status &lt; 400) &#123; // Success! console.log(request.responseText); &#125; &#125;; request.send(); 上面的request.onload其實就是在指定說當資料回來的時候，要用哪一個 function 去處理。 有了上面這一段程式碼之後，你終於大功告成，終於可以串接 Twitch API，從那邊拿資料下來了！真是可喜可賀，從此之後，你就跟「串接 API」這個技能過著幸福快樂的生活… 才怪。 Same Origin Policy正當你以為自己已經對串接 API 駕輕就熟，想說去串接別的 API 試試看好了的時候，才發現一串就出問題了： XMLHttpRequest cannot load http:&#x2F;&#x2F;odata.tn.edu.tw&#x2F;ebookapi&#x2F;api&#x2F;getOdataJH&#x2F;?level&#x3D;all. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;null&#39; is therefore not allowed access. 咦？為什麼會有這個錯誤呢？ 其實是瀏覽器因為安全性的考量，有一個東西叫做同源政策，Same-origin policy。 意思就是說如果你現在這個網站的跟你要呼叫的 API 的網站「不同源」的時候，瀏覽器一樣會幫你發 Request，但是會把 Response 給擋下來，不讓你的 JavaScript 拿到並且傳回錯誤。 什麼是不同源呢？其實你想簡單一點，只要是 Domain 不一樣就是不同源，或者是一個用http一個用https也是不同源，端口號不一樣也是不同源。 所以如果你是接別人 API 的話，大多數情形都是不同源的。 這邊我想再強調一點，「你的 Request 還是有發出去的」，而且瀏覽器也「確實有收到 Response」，重點是「瀏覽器因為同源政策，不把結果傳回給你的 JavaScript」。如果沒有瀏覽器的話其實就沒有這些問題，你愛發給誰就發給誰，不管怎樣都拿得到 Response。 好，既然剛剛說了不同源會被擋下來，那 Twitch API 不是也不同源嗎，是怎麼串接成功的？ CORS大家都知道其實在不同源之間互相傳輸資料是很常有的事情，像我們串接 Twitch API 就是，我們怎麼可能跟 Twitch API 在同一個 Domain 底下呢？ 因此，同源政策的確是規範非同源就被擋下來，但與此同時其實又有另外一個規範，是說：「如果你想在不同 origin 之間傳輸資料的話，你應該怎麼做」，這規範就叫做 CORS。 CORS，全名為 Cross-Origin Resource Sharing，跨來源資源共用。 這套規範跟你說，如果你想開啟跨來源 HTTP 請求的話，Server 必須在 Response 的 Header 裡面加上Access-Control-Allow-Origin。 這個字段你應該不陌生才對，覺得陌生的可以拉回去上面看，剛剛的錯誤訊息其實就有講到這一個 Header。 當瀏覽器收到 Response 之後，會先檢查Access-Control-Allow-Origin裡面的內容，如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。 如果你打開 Devtool 仔細看一開始我們發給 Twitch 的 Request，你會發現 Response 的 Header 大概是長這樣： Content-Type: application&#x2F;json Content-Length: 71 Connection: keep-alive Server: nginx Access-Control-Allow-Origin: * Cache-Control: no-cache, no-store, must-revalidate, private Expires: 0 Pragma: no-cache Twitch-Trace-Id: e316ddcf2fa38a659fa95af9012c9358 X-Ctxlog-Logid: 1-5920052c-446a91950e3abed21a360bd5 Timing-Allow-Origin: https:&#x2F;&#x2F;www.twitch.tv 重點是這一行：Access-Control-Allow-Origin: *，星號就代表萬用字元，意思是任何一個 Origin 都接受。所以當瀏覽器接收到這個 Response 之後，比對目前的 Origin 符合*這個規則，檢驗通過，允許我們接受跨來源請求的回應。 除了這個 Header 以外，其實還有其他的可以用，例如說Access-Control-Allow-Headers跟Access-Control-Allow-Methods，就可以定義接受哪些 Request Header 以及接受哪些 Method。 總結一下，如果你想要發起跨來源 HTTP 請求並且順利收到回應的話，需要確保 Server 端有加上Access-Control-Allow-Origin，不然 Response 會被瀏覽器給擋下來並且顯示出錯誤訊息。 Preflight Request還記得 Twitch 的 API 文件嗎？裡面需要帶一個client-id的參數，而文件裡面寫說你可以帶在 GET 的參數上面，也可以帶在 Header 裡，我們來試試看帶在 Header 裡會怎樣吧！打開 Devtool，你會看到一個神奇的現象： 咦？我明明只發了一個 Request，怎麼變兩個了？而且第一個的 Method 居然是OPTIONS。只是多加了一個 Header 就多了一個 Request，是為什麼呢？ 其實這又跟上面講的 CORS 有關了，CORS 把 Request 分成兩種，一種是簡單請求（simple requests）。什麼是簡單請求呢？其實定義有滿長一串的，我認為有需要用到的時候再看就好，但總之如果你沒有加任何自定義的 Header，而且又是 GET 的話，絕對是簡單請求（這個夠簡單了吧） 反之呢，如果你有加一些自定義的 Header，例如說我們剛剛加的Client-ID，這個 Request 就絕對不是簡單請求。 （定義可參考：MDN: 簡單請求） 從上述分類可知，我們剛剛發起的 Request 因為有帶了 Custom header，所以不會是簡單請求，那為什麼會多一個 Request 呢？ 這一個 Request 叫做 Preflight Request，中文翻作「預檢請求」，因為非簡單請求可能會帶有一些使用者資料，因此會先透過 Preflight Request 去確認後續的請求能否送出。 如果這個 Preflight Request 沒有過的話，真的 Request 也就不會發送了，這就是預檢請求的目的。 我舉一個例子，你就會知道為什麼需要這個 Preflight Request 了。 假設今天某個 Server 提供了一個 API 網址叫做：https://example.com/data/16，你只要對它發送 GET，就能夠拿到 id 是 16 的資料，只要對它發送 DELETE，就可以把這筆資料刪除。 如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。 因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。 如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。 先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。 JSONP最後來講一下 JSONP，這是跨來源請求除了 CORS 以外的另外一種方法，全名叫做：JSON with Padding。 還記得一開始提到的同源政策吧？仔細思考一下會發現，其實有些東西是不受同源政策限制的，例如說&lt;script&gt;這個 Tag，我們不是常常引用 CDN 或是 Google Analytics 之類的第三方套件嗎？網址都是其他 Domain 的，但是卻能正常載入。 JSONP 就是利用&lt;script&gt;的這個特性來達成跨來源請求的。 今天先想像你有一段 HTML 長這樣： &lt;script> var response = &#123; data: 'test' &#125;; &lt;/script> &lt;script> console.log(response); &lt;/script> 很好懂的一段程式碼，我就不多做解釋了。那如果今天把上面那一段換成一串網址呢？ &lt;script src=\"https://another-origin.com/api/games\">&lt;/script> &lt;script> console.log(response); &lt;/script> 如果https://another-origin.com/api/games這個網址返回的內容就是剛剛的： var response = &#123; data: 'test' &#125;; 那我不就一樣可以拿到資料了嗎？而且這些資料還是 Server 端控制的，所以 Server 可以給我任何資料。但是這樣用全域變數其實不太好，我們可以借用剛剛的 Callback Function 的概念，改成這樣： &lt;script> receiveData(&#123; data: 'test' &#125;); &lt;/script> &lt;script> function receiveData (response) &#123; console.log(response); &#125; &lt;/script> 所以 JSONP 是什麼？JSONP 其實就是透過上面這種形式，利用&lt;script&gt;裡面放資料，透過指定好的 function 把資料給帶回去。你只要把第一段的&lt;script&gt;那邊想成是 Server 的回傳值，你就可以理解了。 實務上在操作 JSONP 的時候，Server 通常會提供一個callback的參數讓 client 端帶過去。Twitch API 有提供 JSONP 的版本，我們可以直接來看範例： URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=aaa&amp;limit=1 aaa(&#123;\"_total\":1069,\"_links\":&#123;\"self\":\"https://api.twitch.tv/kraken/games/top?limit=1\",\"next\":\"https://api.twitch.tv/kraken/games/top?limit=1\\u0026offset=1\"&#125;,\"top\":[&#123;\"game\":&#123;\"name\":\"Dota 2\",\"popularity\":63361,\"_id\":29595,\"giantbomb_id\":32887,\"box\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"logo\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"_links\":&#123;&#125;,\"localized_name\":\"Dota 2\",\"locale\":\"zh-tw\"&#125;,\"viewers\":65243,\"channels\":373&#125;]&#125;) URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1 receiveData(&#123;\"_total\":1067,\"_links\":&#123;\"self\":\"https://api.twitch.tv/kraken/games/top?limit=1\",\"next\":\"https://api.twitch.tv/kraken/games/top?limit=1\\u0026offset=1\"&#125;,\"top\":[&#123;\"game\":&#123;\"name\":\"Dota 2\",\"popularity\":63361,\"_id\":29595,\"giantbomb_id\":32887,\"box\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"logo\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"_links\":&#123;&#125;,\"localized_name\":\"Dota 2\",\"locale\":\"zh-tw\"&#125;,\"viewers\":65622,\"channels\":376&#125;]&#125;) 有發現了嗎？它就是透過你帶過去的callback這個參數當作函式名稱，把 JavaScript 物件整個傳到 Function 裡面，你就可以在 Function 裡面拿到資料。 結合起來會變這樣： &lt;script src=\"https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1\">&lt;/script> &lt;script> function receiveData (response) &#123; console.log(response); &#125; &lt;/script> 利用 JSONP，也可以存取跨來源的資料。但 JSONP 的缺點就是你要帶的那些參數永遠都只能用附加在網址上的方式（GET）帶過去，沒辦法用 POST。 如果能用 CORS 的話，還是應該優先考慮 CORS。 總結今天這篇文章的內容就是從抓資料這件事情開始，一步步告訴你應該去哪裡抓？應該怎麼抓？用 API 抓，那什麼是 API？怎麼在 JavaScript 裡面呼叫 Web API？怎麼樣存取跨來源的資料？ 一般來說，跟前端抓資料有關的東西我基本上都提到了，不過有個遺珠之憾是沒有提到Fetch API，這是比較新的標準，也是拿來抓資料用的，MDN 上面的介紹是： The Fetch API provides an interface for fetching resources (including across the network). It will seem familiar to anyone who has used XMLHttpRequest, but the new API provides a more powerful and flexible feature set. 有興趣的讀者們可以自己去看一下。 希望大家看完這篇之後，會更了解怎麼樣串接後端 API，以及串接的時候可能會碰到哪些困難。","link":"/2017/08/27/ajax-and-cors/"},{"title":"记录一次向elementUI提PR的过程","text":"前言24年的年度目标其中就有一个是进入开源社区，而万事开头难，一开始选了VueCore和ElementUI作为我的开始，也向VueCore交了一个PR，但是没发现这个issue上一周就被修复了，所以就没了下文。 但是ElementUI的issue挺有意思的，下面我们来细说下： 问题issue长这样：牙齿尖尖的 这边也贴一个SFC的链接吧：SFC 刚看到这个issue还挺有意思的：这个bug是在菜单组件过多时，elementUI会将过长的menu进行收纳进一个展开栏中： 也就是上图中的省略号那个区域 当我们hover或者click那个区域时，会弹出一个展开栏，里面包含了所有的菜单 但是这个issue的问题是，当我们点击展开栏，当菜单栏的长度过多，会导致展开栏的长度过长，页面会往下拓展，导致页面的滚动条出现，后面页面的视宽内容会被挤压。 挤压不要紧，这个应该是符合预期的，因为当菜单栏过多时，我们的展开栏的长度也会变长，他就需要有地方进行拓展。 但是问题是，这个组件有一个节流函数： const getIndexPath = (index: string) => subMenus.value[index].indexPath // Common computer monitor FPS is 60Hz, which means 60 redraws per second. Calculation formula: 1000ms/60 ≈ 16.67ms, In order to avoid certain chance of repeated triggering when `resize`, set wait to 16.67 * 2 = 33.34 const debounce = (fn: () => void, wait = 33.34) => &#123; let timmer: ReturnType&lt;typeof setTimeout> | null return () => &#123; timmer &amp;&amp; clearTimeout(timmer) timmer = setTimeout(() => &#123; fn() &#125;, wait) &#125; &#125; let isFirstTimeRender = true const handleResize = () => &#123; if (sliceIndex.value === calcSliceIndex()) return const callback = () => &#123; sliceIndex.value = -1 nextTick(() => &#123; sliceIndex.value = calcSliceIndex() &#125;) &#125; // execute callback directly when first time resize to avoid shaking isFirstTimeRender ? callback() : debounce(callback)() isFirstTimeRender = false &#125; 他是这样的：当我们页面的视宽发生变化时，会触发resize事件，然后会执行handleResize函数，这个函数会计算当前的菜单栏的长度，然后会执行一个节流函数，这个节流函数会在一定的时间内，只执行一次回调函数，这个回调函数就是计算当前的菜单栏的长度，然后将这个长度赋值给sliceIndex，然后页面就会根据这个长度来进行展开栏的展开。 搞笑的就来了：刚刚我们触发的滚动条，使得这个节流函数的触发，页面就开始抽搐了 ，因为这个节流函数的节流时间是33.34ms，而我们的滚动条的触发频率是16.67ms，所以这个节流函数就会被频繁的触发，导致页面的抽搐。 解决那么怎么solve这个问题呢： 我一开始想到的是改这个scss的样式，但是这个样式是根据菜单栏的长度来进行展开的，所以改样式是不行的。 后面我发现这个节流函数的触发应该是来解决拖动视窗时组件的销毁和重建，那么我们有必要这么频繁的触发这个节流函数吗？我们是否可以将当他改变组件数量的时候再进行触发呢？ 所以在原来的代码中加了一行： if (sliceIndex.value === calcSliceIndex()) return 这个问题整体来说还算简单，但是我觉得这个问题还是挺有意思的，所以就记录下来了。 提了这个PR也让我复习了一下git的操作，以及体验到了开源项目的PR流程和规范，还是挺有意思的。 下一个阶段的小目标：向Vue和elementUI提PR，看能不能有机会进core team！","link":"/2024/02/08/elementUI-1/"},{"title":"一文读懂什么是Hadoop","text":"Hadoop是什么？Hadoop是一个由Apache基金会所开发的分布式系统基础架构，是一个存储系统+计算框架的软件框架。主要解决海量数据存储与计算的问题，是大数据技术中的基石。Hadoop以一种可靠、高效、可伸缩的方式进行数据处理，用户可以在不了解分布式底层细节的情况下，开发分布式程序，用户可以轻松地在Hadoop上开发和运行处理海量数据的应用程序。 Hadoop能解决什么问题 海量数据存储 HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（High throughput）来访问数据，适合那些有着超大数据集（large data set）的应用程序,它由n台运行着DataNode的机器组成和1台（另外一个standby）运行NameNode进程一起构成。每个DataNode 管理一部分数据，然后NameNode负责管理整个HDFS 集群的信息（存储元数据）。 资源管理，调度和分配 Apache Hadoop YARN（Yet Another Resource Negotiator，另一种资源协调者）是一种新的 Hadoop 资源管理器，它是一个通用资源管理系统和调度平台，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。 Hadoop的由来 Hadoop的核心架构Hadoop的核心，说白了，就是HDFS和MapReduce。HDFS为海量数据提供了存储，而MapReduce为海量数据提供了计算框架。 HDFS 整个HDFS有三个重要角色：NameNode（名称节点）、DataNode（数据节点）和Client（客户机）。 典型的主从架构，用TCP&#x2F;IP通信 NameNode：是Master节点（主节点），可以看作是分布式文件系统中的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等。NameNode会将文件系统的Meta-data存储在内存中，这些信息主要包括了文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode的信息等。 DataNode：是Slave节点（从节点），是文件存储的基本单元，它将Block存储在本地文件系统中，保存了Block的Meta-data，同时周期性地将所有存在的Block信息发送给NameNode。 Client：切分文件；访问HDFS；与NameNode交互，获得文件位置信息；与DataNode交互，读取和写入数据。 还有一个Block（块）的概念：Block是HDFS中的基本读写单元；HDFS中的文件都是被切割为block（块）进行存储的；这些块被复制到多个DataNode中；块的大小（通常为64MB）和复制的块数量在创建文件时由Client决定。 MapReduceMapReduce是一种分布式计算模型，它将大规模数据集（大于1TB）分成许多小数据块，然后在集群中的各个节点上进行并行处理，最后将结果汇总。MapReduce的计算过程可以分为两个阶段：Map阶段和Reduce阶段。 Map阶段：将输入数据切分成若干个小数据块，然后由多个Map任务并行处理，每个Map任务将处理结果输出为若干个键值对。 Reduce阶段：将Map阶段的输出结果按照键值对中的键进行分组，然后由多个Reduce任务并行处理，每个Reduce任务将处理结果输出为若干个键值对。 总结Hadoop是一个分布式系统基础架构，主要解决海量数据存储与计算的问题。它的核心是HDFS和MapReduce，其中HDFS为海量数据提供了存储，而MapReduce为海量数据提供了计算框架。除此之外，Hadoop还有一个重要的组件——YARN，它是一个通用资源管理系统和调度平台，可为上层应用提供统一的资源管理和调度。","link":"/2023/11/08/hadoop-1/"},{"title":"hadoop之MapReduce工作原理","text":"MapReduce 定义MapReduce 是一个分布式运算程序的编程框架，是用户开发“基于hadoop的数据分析应用”的核心框架，其核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个hadoop集群上。 MapReduce 产生缘由为什么需要MapReduce？ 海量数据在单机上处理因为硬件资源限制，无法胜任。 而一旦将单机版程序扩展到集群来分布式运行，将极大增加程序的复杂度和开发难度。 引入MapReduce框架后，开发人员可以将绝大部分工作集中在业务逻辑的开发上，而将分布式计算中的复杂性交由框架来处理。 设想一个海量数据场景下的wordcount需求： 单机版：内存受限，磁盘受限，运算能力受限 分布式：文件分布式存储（HDFS）、运算逻辑需要至少分成2个阶段（一个阶段独立并发，一个阶段汇聚）、运算程序如何分发、程序如何分配运算任务（切片）、两阶段的程序如何启动？如何协调？、整个程序运行过程中的监控？容错？重试？ 可见在程序由单机版扩成分布式时，会引入大量的复杂工作。 MapReduce与Yarn的关系Yarn 是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台。而MapReduce等运算程序则相当于运行于操作系统之上的应用程序。 YARN的重要概念： yarn并不清楚用户提交的程序的运行机制； yarn只提供运算资源的调度（用户程序向yarn申请资源，yarn就负责分配资源）； yarn中的主管角色叫ResourceManager； yarn中具体提供运算资源的角色叫NodeManager； 这样一来，yarn其实就与运行的用户程序完全解耦，就意味着yarn上可以运行各种类型的分布式运算程序（MapReduce只是其中的一种），比如MapReduce、storm程序，spark程序，tez……； 所以，spark、storm等运算框架都可以整合在yarn上运行，只要他们各自的框架中有符合yarn规范的资源请求机制即可； Yarn就成为一个通用的资源调度平台，从此，企业中以前存在的各种运算集群都可以整合在一个物理集群上，提高资源利用率，方便数据共享。 MapReduce 工作原理严格说起来MapReduce并不是一种算法， 而是一个计算思想。它由map和reduce两个阶段组成。 MapReduce 进程为了提高开发效率，可以将分布式程序中的公共功能封装成框架，让开发人员可以将精力集中于业务逻辑。 而MapReduce就是这样一个分布式程序的通用框架，整体结构如下（在分布式运行时有三类实例进程）： MRAppMaster：负责整个程序的过程调度及状态协调 MapTask：负责map阶段的整个数据处理流程 ReduceTask：负责reduce阶段的整个数据处理流程 MapReduce 运行机制 流程描述如下： 一个MR程序启动的时候，最先启动的是MRAppMaster，MRAppMaster启动后根据本次job的描述信息，计算出需要的MapTask实例数量，然后向集群申请机器启动相应数量的MapTask进程； MapTask进程启动之后，根据给定的数据切片范围进行数据处理，主体流程为： 利用客户指定的inputformat来获取RecordReader读取数据，形成输入KV对； 将输入KV对传递给客户定义的map()方法，做逻辑运算，并将map()方法输出的KV对收集到缓存； 将缓存中的KV对按照K分区排序后不断溢写到磁盘文件。 MRAppMaster监控到所有MapTask进程任务完成之后，会根据客户指定的参数启动相应数量的ReduceTask进程，并告知ReduceTask进程要处理的数据范围（数据分区）； ReduceTask进程启动之后，根据MRAppMaster告知的待处理数据所在位置，从若干台MapTask运行所在机器上获取到若干个MapTask输出结果文件，并在本地进行重新归并排序，然后按照相同key的KV为一个组，调用客户定义的reduce()方法进行逻辑运算，并收集运算输出的结果KV，然后调用客户指定的outputformat将结果数据输出到外部存储。 我们来举个例子。 上图是一个统计词频的任务。 Hadoop将输入数据切成若干个分片，并将每个split（分割）交给一个map task（Map任务）处理。 Mapping之后，相当于得出这个task里面，每个词以及它出现的次数。 shuffle（拖移）将相同的词放在一起，并对它们进行排序，分成若干个分片。 根据这些分片，进行reduce（归约）。 统计出reduce task的结果，输出到文件。 在MapReduce里，为了完成上面这些过程，需要两个角色：JobTracker和TaskTracker。 JobTracker用于调度和管理其它的TaskTracker。JobTracker可以运行于集群中任一台计算机上。TaskTracker 负责执行任务，必须运行于 DataNode 上。 现在这边给出一个简单的mapreduce实现示例： 用于统计输入文件中每个单词的出现次数。 导入必要的包： import java.io.IOException; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.Reducer; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; 定义Mapper类： public static class MyMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123; protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123; String line &#x3D; value.toString(); &#x2F;&#x2F; 将每行文本拆分为单词，然后发送到Reducer String[] words &#x3D; line.split(&quot;\\\\s+&quot;); for (String word : words) &#123; context.write(new Text(word), new IntWritable(1)); &#125; &#125; &#125; Mapper类的作用是将输入的文本数据拆分成单词，然后为每个单词输出一个键-值对（单词, 1）。 定义Reducer类： public static class MyReduce extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123; protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123; int sum &#x3D; 0; &#x2F;&#x2F; 对相同单词的出现次数进行累加 for (IntWritable value : values) &#123; sum +&#x3D; value.get(); &#125; &#x2F;&#x2F; 输出单词和其出现的总次数 context.write(key, new IntWritable(sum)); &#125; &#125; Reducer类的作用是接收来自Mapper的键-值对，对相同键的值进行累加，然后输出单词和其总出现次数。 主函数（main方法）： public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException &#123; Configuration conf &#x3D; new Configuration(); Job job &#x3D; Job.getInstance(conf, &quot;word count&quot;); job.setJarByClass(word.class); job.setMapperClass(MyMapper.class); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(IntWritable.class); job.setReducerClass(MyReduce.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); &#x2F;&#x2F; 设置输入路径和输出路径 FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); &#x2F;&#x2F; 提交作业并等待完成 job.waitForCompletion(true); &#125; 在整个Hadoop架构中，计算框架起到承上启下的作用，一方面可以操作HDFS中的数据，另一方面可以被封装，提供Hive、Pig这样的上层组件的调用。 我们简单介绍一下其中几个比较重要的组件。 HBase：来源于Google的BigTable；是一个高可靠性、高性能、面向列、可伸缩的分布式数据库。 Hive：是一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 Pig：是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算。 ZooKeeper：来源于Google的Chubby；它主要是用来解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度。 Ambari：Hadoop管理工具，可以快捷地监控、部署、管理集群。 Sqoop：用于在Hadoop与传统的数据库间进行数据的传递。 Mahout：一个可扩展的机器学习和数据挖掘库。 Hadoop的优点和应用 总的来看，Hadoop有以下优点： 高可靠性：这个是由它的基因决定的。它的基因来自Google。Google最擅长的事情，就是“垃圾利用”。Google起家的时候就是穷，买不起高端服务器，所以，特别喜欢在普通电脑上部署这种大型系统。虽然硬件不可靠，但是系统非常可靠。 高扩展性：Hadoop是在可用的计算机集群间分配数据并完成计算任务的，这些集群可以方便地进行扩展。说白了，想变大很容易。 高效性：Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。 高容错性：Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。这个其实也算是高可靠性。 低成本：Hadoop是开源的，依赖于社区服务，使用成本比较低。 基于这些优点，Hadoop适合应用于大数据存储和大数据分析的应用，适合于服务器几千台到几万台的集群运行，支持PB级的存储容量。 Hadoop的应用非常广泛，包括：搜索、日志处理、推荐系统、数据分析、视频图像分析、数据保存等，都可以使用它进行部署。","link":"/2023/11/08/hadoop-2/"},{"title":"Hadoop 2.0体系架构之分布式文件系统HDFS","text":"HDFS设计原则设计目标存储非常大的文件：这里非常大指的是几百M、G、或者TB级别。 采用流式的数据访问方式: HDFS基于这样的一个假设：最有效的数据处理模式是一次写入、多次读取数据集经常从数据源生成或者拷贝一次，然后在其上做很多分析工作分析工作经常读取其中的大部分数据，即使不是全部。 因此读取整个数据集所需时间比读取第一条记录的延时更重要。 运行于商业硬件上: Hadoop不需要特别贵的、reliable的（可靠的）机器，可运行于普通商用机器（可以从多家供应商采购） ，商用机器不代表低端机器。在集群中（尤其是大的集群），节点失败率是比较高的HDFS的目标是确保集群在节点失败的时候不会让用户感觉到明显的中断。 HDFS不适合的应用类型有些场景不适合使用HDFS来存储数据。下面列举几个： 低延时的数据访问对延时要求在毫秒级别的应用，不适合采用HDFS。HDFS是为高吞吐数据传输设计的,因此可能牺牲延时HBase更适合低延时的数据访问。 大量小文件文件的元数据（如目录结构，文件block的节点列表，block-node mapping）保存在NameNode的内存中， 整个文件系统的文件数量会受限于NameNode的内存大小。经验而言，一个文件&#x2F;目录&#x2F;文件块一般占有150字节的元数据内存空间。如果有100万个文件，每个文件占用1个文件块，则需要大约300M的内存。因此十亿级别的文件数量在现有商用机器上难以支持。 多方读写，需要任意的文件修改HDFS采用追加（append-only）的方式写入数据。不支持文件任意offset的修改。不支持多个写入器（writer） HDFS定位为提高扩展性，HDFS采用了master&#x2F;slave架构来构建分布式存储集群，这种架构很容易向集群中任意添加或删除slave。 HDFS是Hadoop生态系统中的一个重要组件，它是一个分布式文件系统，旨在存储大量数据，并提供高吞吐量的数据访问。HDFS的设计目标是将数据存储在廉价的硬件上，并提供高容错性。它通过将数据分散到集群中的多个节点上来实现这一目标。HDFS的定位是作为一个批处理系统，适用于大规模数据的离线处理。 HDFS的主要特点包括： 高容错性：HDFS将数据分散到多个节点上，因此即使某个节点出现故障，数据仍然可以通过其他节点进行访问。 高吞吐量：HDFS的设计目标是支持大规模数据的批处理，因此它提供了高吞吐量的数据访问。 适用于大文件：HDFS适用于存储大文件，因为它将文件分成多个块进行存储，并将这些块分散到多个节点上。 流式数据访问：HDFS支持流式数据访问，这意味着它可以高效地处理大量的数据流。 HDFS体系架构HDFS采用master&#x2F;slave体系来构建分布式存储服务，提高了HDFS的可扩展性又简化了架构设计。HDFS里将文件分块存储，优化存储颗粒度。namenode统一管理所有slave机器datanode存储空间，datanode以块为单位存储实际的数据。真正的文件I&#x2F;O操作时客户端直接和datanode交互。 HDFS核心概念Blocks物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。 HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。 HDFS的Block为什么这么大？是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M&#x2F;s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。 Block抽象的好处 Block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。 Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。 Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。 Namenode &amp; Datanode整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode负责构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。 NamenodeNamenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式： namespace image edit log 但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： 备份持久化元数据将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。 Secondary NamenodeSecondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。下图为Secondary Namenode的管理界面： Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。在HA（High Availability高可用性）中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。 Datanode数据节点负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。 经典HDFS体系架构NameNode负责管理文件系统的元数据信息，而DataNode则负责存储文件块的实际数据。 这种分工使得HDFS能够高效地存储和管理大规模数据。 具体来说，当一个客户端需要读取或写入一个文件时，它会向NameNode发送请求。NameNode会返回文件的元数据信息和文件块的位置信息。客户端根据这些信息与DataNode进行通信，从而读取或写入文件块的实际数据。 因此，NameNode和DataNode在HDFS体系架构中扮演着不同的角色。 作用上的区别是什么？ HDFS是Hadoop分布式文件系统的缩写，是Hadoop生态系统中的一个重要组件。HDFS的体系架构包括一个NameNode和多个DataNode。NameNode是HDFS的主节点，负责管理文件系统的命名空间、文件的元数据信息以及文件块的位置信息。而DataNode则是HDFS的从节点，负责存储文件块的实际数据。 具体来说，当一个客户端需要读取或写入一个文件时，它会向NameNode发送请求。NameNode会返回文件的元数据信息和文件块的位置信息。客户端根据这些信息与DataNode进行通信，从而读取或写入文件块的实际数据。 一般拓扑只有单个NameNode节点，使用SecondaryNameNode或BackupNode节点实时获取NameNode元数据信息，备份元数据。 商用拓扑有两个NameNode节点，并使用ZooKeeper实现NameNode节点间的热切换。 命令行接口HDFS提供了各种交互方式，例如通过Java API、HTTP、shell命令行的。命令行的交互主要通过hadoop fs来操作。例如： hadoop fs -copyFromLocal &#x2F;&#x2F; 从本地复制文件到HDFS hadoop fs mkdir &#x2F;&#x2F; 创建目录 hadoop fs -ls &#x2F;&#x2F; 列出文件列表 Hadoop中，文件和目录的权限类似于POSIX模型，包括读、写、执行3种权限： 读权限（r）：用于读取文件或者列出目录中的内容写权限（w）：对于文件，就是文件的写权限。目录的写权限指在该目录下创建或者删除文件（目录）的权限。执行权限（x）：文件没有所谓的执行权限，被忽略。对于目录，执行权限用于访问器目录下的内容。 每个文件或目录都有owner，group，mode三个属性: owner：指文件的所有者group：为权限组mode：由所有者权限、文件所属的组中组员的权限、非所有者非组员的权限组成。 数据流（读写流程）读文件大致读文件的流程如下： 客户端传递一个文件Path给FileSystem的open方法 DFS采用RPC远程获取文件最开始的几个block的datanode地址。Namenode会根据网络拓扑结构决定返回哪些节点（前提是节点有block副本），如果客户端本身是Datanode并且节点上刚好有block副本，直接从本地读取。 客户端使用open方法返回的FSDataInputStream对象读取数据（调用read方法） DFSInputStream（FSDataInputStream实现了改类）连接持有第一个block的、最近的节点，反复调用read方法读取数据 第一个block读取完毕之后，寻找下一个block的最佳datanode，读取数据。如果有必要，DFSInputStream会联系Namenode获取下一批Block 的节点信息（存放于内存，不持久化），这些寻址过程对客户端都是不可见的。 数据读取完毕，客户端调用close方法关闭流对象 在读数据过程中，如果与Datanode的通信发生错误，DFSInputStream对象会尝试从下一个最佳节点读取数据，并且记住该失败节点， 后续Block的读取不会再连接该节点 读取一个Block之后，DFSInputStram会进行检验和验证，如果Block损坏，尝试从其他节点读取数据，并且将损坏的block汇报给Namenode。 客户端连接哪个datanode获取数据，是由namenode来指导的，这样可以支持大量并发的客户端请求，namenode尽可能将流量均匀分布到整个集群。 Block的位置信息是存储在namenode的内存中，因此相应位置请求非常高效，不会成为瓶颈。 写文件 步骤分解 客户端调用DistributedFileSystem的create方法 DistributedFileSystem远程RPC调用Namenode在文件系统的命名空间中创建一个新文件，此时该文件没有关联到任何block。 这个过程中，Namenode会做很多校验工作，例如是否已经存在同名文件，是否有权限，如果验证通过，返回一个FSDataOutputStream对象。 如果验证不通过，抛出异常到客户端。 客户端写入数据的时候，DFSOutputStream分解为packets（数据包），并写入到一个数据队列中，该队列由DataStreamer消费。 DateStreamer负责请求Namenode分配新的block存放的数据节点。这些节点存放同一个Block的副本，构成一个管道。 DataStreamer将packet写入到管道的第一个节点，第一个节点存放好packet之后，转发给下一个节点，下一个节点存放 之后继续往下传递。 DFSOutputStream同时维护一个ack queue队列，等待来自datanode确认消息。当管道上的所有datanode都确认之后，packet从ack队列中移除。 数据写入完毕，客户端close输出流。将所有的packet刷新到管道中，然后安心等待来自datanode的确认消息。全部得到确认之后告知Namenode文件是完整的。 Namenode此时已经知道文件的所有Block信息（因为DataStreamer是请求Namenode分配block的），只需等待达到最小副本数要求，然后返回成功信息给客户端。 Namenode如何决定副本存在哪个Datanode？ HDFS的副本的存放策略是可靠性、写带宽、读带宽之间的权衡。默认策略如下： 第一个副本放在客户端相同的机器上，如果机器在集群之外，随机选择一个（但是会尽可能选择容量不是太慢或者当前操作太繁忙的） 第二个副本随机放在不同于第一个副本的机架上。 第三个副本放在跟第二个副本同一机架上，但是不同的节点上，满足条件的节点中随机选择。 更多的副本在整个集群上随机选择，虽然会尽量避免太多副本在同一机架上。 副本的位置确定之后，在建立写入管道的时候，会考虑网络拓扑结构。下面是可能的一个存放策略： 这样选择很好的平衡了可靠性、读写性能 可靠性：Block分布在两个机架上 写带宽：写入管道的过程只需要跨越一个交换机 读带宽：可以从两个机架中任选一个读取 HDFS内部特性数据冗余 HDFS将每个文件存储成一系列数据块（Block），默认块大小为64MB（可配置）。 为了容错，文件的所有数据块都会有副本（副本数量即复制因子，可配置）。 HDFS的文件都是一次性写入的，并且严格限制为任何时候都只有一个写用户。 副本存放 HDFS集群一般运行在多个机架上，不同机架上机器的通信需要通过交换机。 HDFS采用机架感知（Rack-aware）的策略来改进数据的可靠性、可用性和网络带宽的利用率。 机架的错误远比节点的错误少，这个策略可以防止整个机架失效时数据丢失，提高数据的可靠性和可用性，又能保证性能。 副本选择 HDFS会尽量使用离程序最近的副本来满足用户请求，这样可以减少总带宽消耗和读延时。 HDFS的架构支持数据均衡策略。 心跳检测 NameNode周期性地从集群中的每个DataNode接受心跳包和块报告，收到心跳包说明该DataNode工作正常。 NameNode会标记最近没有心跳的DataNode为宕机，不会发给它们任何新的I&#x2F;O请求。 NameNode会不断检测这些需要复制的数据块，并在需要的时候重新复制。 数据完整性检测 多种原因可能造成从DataNode获取的数据块有损坏。 HDFS客户端软件实现了对HDFS文件内容的校验和检查（Checksum）。 DataNode获得的数据块对应的校验和隐藏文件中的不同，客户端就会判定数据块有损坏，将从其他DataNode获取该数据块的副本。 简单一致性模型、流式数据访问 HDFS的应用程序一般对文件实行一次写、多次读的访问模式。 文件一旦创建、写入和关闭之后就不需要再更改了。 这样就简化了数据一致性问题，高吞吐量的数据访问才成为可能；运行在HDFS上的应用主要以流式读为主，做批量处理；更注重数据访问的高吞吐量。 客户端缓存 客户端创建文件的请求不是立即到达NameNode，HDFS客户端先把数据缓存到本地的一个临时文件，程序的写操作透明地重定向到这个临时文件。 当这个临时文件累积的数据超过一个块的大小（64MB）时，客户端才会联系NameNode。 如果NameNode在文件关闭之前死机，那么文件将会丢失。 如果不采用客户端缓存，网络速度和拥塞都会对输出产生很大的影响。","link":"/2023/11/09/hadoop-3/"},{"title":"Hadoop 2.0体系架构之分布式文件系统Yarn","text":"Hadoop Yarn 是什么在古老的 Hadoop1.0 中，MapReduce 的 JobTracker 负责了太多的工作，包括资源调度，管理众多的 TaskTracker 等工作。这自然是不合理的，于是 Hadoop 在 1.0 到 2.0 的升级过程中，便将 JobTracker 的资源调度工作独立了出来，而这一改动，直接让 Hadoop 成为大数据中最稳固的那一块基石。，而这个独立出来的资源管理框架，就是 Yarn 。 在详细介绍 Yarn 之前，我们先简单聊聊 Yarn ，Yarn 的全称是 Yet Another Resource Negotiator ，意思是“另一种资源调度器”，这种命名和“有间客栈”这种可谓是异曲同工之妙。这里多说一句，以前 Java 有一个项目编译工具，叫做 Ant，他的命名也是类似的，叫做 “Another Neat Tool”的缩写，翻译过来是“另一种整理工具”。 既然都叫做资源调度器了，那么自然，它的功能也是负责资源管理和调度的，接下来，我们就深入到 Yarn 这个东西内部一探究竟吧。 Yarn 架构 ① Client：客户端，负责向集群提交作业。 ② ResourceManager：集群主进程，仲裁中心，负责集群资源管理和任务调度。 ③ Scheduler：资源仲裁模块。 ④ ApplicationManager：选定，启动和监管ApplicationMaster。 ⑤ NodeManager：集群从进程，管理监视Containers，执行具体任务。 ⑥ Container：本机资源集合体，如某Container为4个CPU，8GB内存。 ⑦ ApplicationMaster：任务执行和监管中心。 三个主要组件再看最上面的图，我们能直观发现的两个主要的组件是 ResourceManager 和 NodeManager ，但其实还有一个 ApplicationMaster 在图中没有直观显示。我们分别来看这三个组件。 ResourceManager我们先来说说上图中最中央的那个 ResourceManager（RM）。从名字上我们就能知道这个组件是负责资源管理的，整个系统有且只有一个 RM ，来负责资源的调度。 它也包含了两个主要的组件：定时调用器(Scheduler)以及应用管理器(ApplicationManager)。 定时调度器(Scheduler)：从本质上来说，定时调度器就是一种策略，或者说一种算法。当 Client 提交一个任务的时候，它会根据所需要的资源以及当前集群的资源状况进行分配。注意，它只负责向应用程序分配资源，并不做监控以及应用程序的状态跟踪。 应用管理器(ApplicationManager)：同样，听名字就能大概知道它是干嘛的。应用管理器就是负责管理 Client 用户提交的应用。上面不是说到定时调度器（Scheduler）不对用户提交的程序监控嘛，其实啊，监控应用的工作正是由应用管理器（ApplicationManager）完成的。 ApplicationMaster每当 Client 提交一个 Application 时候，就会新建一个 ApplicationMaster 。由这个 ApplicationMaster 去与 ResourceManager 申请容器资源，获得资源后会将要运行的程序发送到容器上启动，然后进行分布式计算。 这里可能有些难以理解，为什么是把运行程序发送到容器上去运行？如果以传统的思路来看，是程序运行着不动，然后数据进进出出不停流转。但当数据量大的时候就没法这么玩了，因为海量数据移动成本太大，时间太长。但是中国有一句老话山不过来，我就过去。大数据分布式计算就是这种思想，既然大数据难以移动，那我就把容易移动的应用程序发布到各个节点进行计算呗，这就是大数据分布式计算的思路。 NodeManagerNodeManager 是 ResourceManager 在每台机器的上代理，负责容器的管理，并监控他们的资源使用情况（cpu，内存，磁盘及网络等），以及向 ResourceManager&#x2F;Scheduler 提供这些资源使用报告。 Yarn的主要思想是将MRv1版JobTracker的两大功能——资源管理和任务调度，拆分成两个独立的进程： Yarn依旧是master&#x2F;slave结构 主进程ResourceManager是整个集群资源仲裁中心 从进程NodeManager管理本机资源 ResourceManager和从属节点的进程NodeManager组成了Hadoop 2.0的分布式数据计算框架 提交一个 Application 到 Yarn 的流程 这张图简单地标明了提交一个程序所经历的流程，接下来我们来具体说说每一步的过程。 Client 向 Yarn 提交 Application，这里我们假设是一个 MapReduce 作业。 ResourceManager 向 NodeManager 通信，为该 Application 分配第一个容器。并在这个容器中运行这个应用程序对应的 ApplicationMaster。 ApplicationMaster 启动以后，对 作业（也就是 Application） 进行拆分，拆分 task 出来，这些 task 可以运行在一个或多个容器中。然后向ResourceManager 申请要运行程序的容器，并定时向 ResourceManager 发送心跳。 申请到容器后，ApplicationMaster 会去和容器对应的 NodeManager 通信，而后将作业分发到对应的 NodeManager 中的容器去运行，这里会将拆分后的 MapReduce 进行分发，对应容器中运行的可能是 Map 任务，也可能是 Reduce 任务。 容器中运行的任务会向 ApplicationMaster 发送心跳，汇报自身情况。当程序运行完成后， ApplicationMaster 再向 ResourceManager 注销并释放容器资源。以上就是一个作业的大体运行流程。 Yarn 架构典型拓扑除了ResourceManager和NodeManager两个实体外，Yarn还包括WebAppProxyServer和JobHistoryServer两个实体。 JobHistoryServer：管理已完成的Yarn任务 历史任务的日志和执行时的各种统计信息统一由JobTracker管理 Yarn将管理历史任务的功能抽象成一独立实体JobHistoryServer WebAppProxyServer：任务执行时的Web页面代理 通过使用代理，不仅进一步降低了ResourceManager的压力，还能降低Yarn受到的Web攻击 负责监管具体MapReduce任务执行全过程，将从Container那里收集过的任务执行信息汇总并显示到一个Web界面上 Yarn 调度策略容量调度算法CapacityScheduler是一种多用户多任务调度策略，它以队列为单位划分任务，以Container为单位分配资源 公平调度策略FairScheduler是一种允许多个Yarn任务公平使用集群资源的可插拔式调度策略","link":"/2023/11/09/hadoop-4/"},{"title":"HTTP/2 简介","text":"设计和技术目标早期版本的 HTTP 协议的设计初衷是为了简化实现：HTTP&#x2F;0.9 是用来引导万维网的一行协议；HTTP&#x2F;1.0 以信息性标准记录了 HTTP&#x2F;0.9 的热门扩展；HTTP&#x2F;1.1 则引入了官方 IETF 标准；请参阅 HTTP 简史 。因此，HTTP&#x2F;0.9-1.x 可以完全实现其预期用途：HTTP 是互联网上最广泛采用的应用协议之一。 遗憾的是，实现简单是以牺牲应用性能为代价的：HTTP&#x2F;1.x 客户端需要使用多个连接来实现并发并缩短延迟时间；HTTP&#x2F;1.x 不会压缩请求和响应标头，从而导致不必要的网络流量；HTTP&#x2F;1.x 不允许有效的资源优先级排序，从而导致底层 TCP 连接被滥用；等等。 这些限制并不是致命的，但随着 Web 应用的范围、复杂性和在我们日常生活中的重要性不断增长，它们给 Web 开发者和用户造成了越来越大的负担，而这正是 HTTP&#x2F;2 旨在解决的问题： HTTP&#x2F;2 通过引入标头字段压缩并允许在同一连接上交错进行多个并发交换，可以更高效地利用网络资源并减少对延迟的感知。具体而言，它允许在同一连接上交错请求和响应消息，并对 HTTP 标头字段使用高效的编码。它还允许对请求进行优先级排序，让更重要的请求更快速地完成，从而进一步提升性能。 生成的协议对网络更友好，因为与 HTTP&#x2F;1.x 相比，可以使用的 TCP 连接更少。这意味着与其他流的竞争更少，并且连接的持续时间更长，进而可以更好地利用可用网络容量。最后，HTTP&#x2F;2 还可以通过使用二进制消息分帧来更高效地处理消息。（超文本传输协议版本 2，草稿 17） 请务必注意，HTTP&#x2F;2 是对以前的 HTTP 标准的扩展，而不是取代。HTTP 的应用语义相同，提供的功能或核心概念（例如 HTTP 方法、状态代码、URI 和标头字段）没有发生任何变化。这些更改显然不在 HTTP&#x2F;2 工作的范围之内。也就是说，虽然高层级 API 保持不变，但了解低层级更改如何解决了先前协议的性能限制仍非常重要。我们来简单了解一下二进制分帧层及其功能。 二进制分帧层HTTP&#x2F;2 所有性能增强的核心是新的二进制分帧层，它规定了 HTTP 消息的封装方式，并在客户端和服务器之间传输。 “层”是指一种设计选择，用于在套接字接口与提供给应用的更高级别 HTTP API 之间引入一种经过优化的新编码机制：HTTP 语义（例如动词、方法和标头）不受影响，但其在传输过程中的编码方式有所不同。与以换行符分隔的 HTTP&#x2F;1.x 协议明文形式不同，所有 HTTP&#x2F;2 通信都会拆分为较小的消息和帧，其中的每个消息和帧都采用二进制格式进行编码。 因此，客户端和服务器都必须使用新的二进制编码机制来相互理解：HTTP&#x2F;1.x 客户端无法理解仅支持 HTTP&#x2F;2 的服务器，反之亦然。幸运的是，我们的应用仍可轻松了解所有这些变化，因为客户端和服务器会代表我们执行所有必要的取景工作。 Binary protocol versus text protocol isn’t really about how binary blobs are encoded. The difference is really whether the protocol is oriented around data structures or around text strings. Let me give an example: HTTP. HTTP is a text protocol, even though when it sends a jpeg image, it just sends the raw bytes, not a text encoding of them. 信息流、消息和帧 新的二进制分帧机制改变了客户端与服务器之间的数据交换方式。为了描述此过程，我们需要先熟悉 HTTP&#x2F;2 术语： 数据流：已建立的连接内的双向字节流，可承载一条或多条消息。 消息：映射到逻辑请求或响应消息的完整帧序列。 帧：HTTP&#x2F;2 中的最小通信单元，每个单元包含一个帧标头，至少标识该帧所属的数据流。 这些术语之间的关系可总结如下： 所有通信都在一个 TCP 连接上完成，该连接可以承载任意数量的双向数据流。 每个数据流都有一个唯一标识符和可选的优先级信息，用于承载双向消息。 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。 帧是最小的通信单位，承载着特定类型的数据，例如，HTTP 标头、邮件载荷等。来自不同数据流的帧可以交错，然后通过每个帧标头中的嵌入式数据流标识符重新组装。 也就是说，HTTP&#x2F;2 的每个消息都由一个或多个帧组成，这些帧可以交错发送，然后再在接收端重新组装。帧的顺序并不重要，因为每个帧都包含其相对位置的信息。 请求和响应多路复用使用 HTTP&#x2F;1.x 时，如果客户端想要发出多个并行请求以提高性能，则必须使用多个 TCP 连接（请参阅使用多个 TCP 连接）。 注意这里是并行！！客户端往往会为每个请求创建一个新的连接，以便并行发送请求，达到性能最大化。然而，这种方法会导致一些问题。 这是 HTTP&#x2F;1.x 传送模型的直接结果，该行为可确保每个连接一次只传送一个响应（响应排队）。更糟糕的是，这也会导致队首阻塞，以及底层 TCP 连接的效率低下。 HTTP&#x2F;2 中新的二进制分帧层消除了这些限制并实现了完整的请求和响应多路复用，方法是允许客户端和服务器将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装这些帧。 该快照捕捉了同一连接内传输的多个数据流。客户端正在向服务器传输 DATA 帧（流 5），而服务器正在将交错的帧序列发送到客户端，以便流 1 和流 3。因此，正在传输三个并行流。 能够将 HTTP 消息分解为独立的帧，交错这些帧，然后在另一端重新组装这些帧，是 HTTP&#x2F;2 最重要的增强功能。事实上，它在所有 Web 技术的整个堆栈中带来了众多性能优势的连锁效应，使我们能够： 并行交错地发送多个请求，请求之间互不影响。 并行交错地发送多个响应，响应之间互不影响。 使用一个连接并行发送多个请求和响应。 移除了不必要的 HTTP&#x2F;1.x 权宜解决方法（请参阅针对 HTTP&#x2F;1.x 进行优化，例如串联文件、image sprites 和网域分片）。 消除不必要的延迟并提高可用网络容量的利用率，从而缩短网页加载时间。 等等… HTTP&#x2F;2 中新的二进制分帧层解决了 HTTP&#x2F;1.x 中存在的队首阻塞问题，并且消除了并行处理及传送请求和响应所需的多个连接。因此，我们的应用部署速度更快、操作更简单、部署成本更低。 数据流优先级一旦 HTTP 消息可以拆分为多个单独的帧，并且我们允许对来自多个数据流的帧进行多路复用，那么客户端和服务器交错和传送这些帧的顺序就成为关键的性能考虑因素。为了方便起见，HTTP&#x2F;2 标准允许每个数据流具有关联的权重和依赖关系： 可以为每个数据流分配一个介于 1 到 256 之间的整数。 每个数据流都可以显式依赖于另一个数据流。 通过结合使用数据流依赖关系和权重，客户端可以构建和传递“优先级树”，表明其希望如何接收响应。反过来，服务器可以使用这些信息通过控制 CPU、内存和其他资源的分配来确定流处理的优先级，并在响应数据可用后分配带宽，以确保将高优先级响应以最优方式传递给客户端。 每个源一个连接有了新的二进制分帧机制，HTTP&#x2F;2 不再需要多个 TCP 连接来并行复用数据流；每个数据流都会拆分为许多帧，这些帧可以交错并设定优先级。因此，所有 HTTP&#x2F;2 连接都是永久性的，并且每个来源只需要一个连接，从而提供大量性能优势。 SPDY 和 HTTP&#x2F;2 的杀手级功能是，在单个拥塞受控的通道上任意进行多路复用。它的重要性和良好运作机制让我惊叹不已我喜欢的一个重要指标是创建的连接所占的比例，这些连接仅承载单个 HTTP 事务（因此该事务承担所有开销）。对于 HTTP&#x2F;1，我们 74% 的活动连接只承载一个事务 - 持久性连接没有我们所有人想要的那样帮助。但在 HTTP&#x2F;2 中，这一比例下降至 25%。 这在减少开销方面是一项巨大的成功。（HTTP&#x2F;2 已在 Firefox 中推出，Patrick McManus） 大多数 HTTP 传输都是短暂的且具有突发性的，而 TCP 则针对长期的批量数据传输进行了优化。通过重复使用同一连接，HTTP&#x2F;2 既可以更有效地利用每个 TCP 连接，也可以显著降低整体协议开销。此外，使用较少的连接可以减少整个连接路径（即客户端、中间服务器和源服务器）上的内存和处理占用空间。这样可以降低整体运营费用，并提高网络利用率和容量。因此，改用 HTTP&#x2F;2 不仅可以减少网络延迟，还有助于提高吞吐量并降低运营费用。","link":"/2024/04/14/http2-0/"},{"title":"JIT (just-in-time) compiler 是怎么工作的","text":"引言在谈到JIT前，还是需要对编译过程有一些简单的了解。 在编译原理中，把源代码翻译成机器指令，一般要经过以下几个重要步骤： JIT简介JIT是just in time的缩写，也就是即时编译。 通过JIT技术，能够做到Java程序执行速度的加速。那么，是怎么做到的呢？ 我们都知道，Java是一门解释型语言（或者说是半编译，半解释型语言）。Java通过编译器javac先将源程序编译成与平台无关的Java字节码文件（.class），再由JVM解释执行字节码文件，从而做到平台无关。 但是，有利必有弊。对字节码的解释执行过程实质为：JVM先将字节码翻译为对应的机器指令，然后执行机器指令。很显然，这样经过解释执行，其执行速度必然不如直接执行二进制字节码文件。 而为了提高执行速度，便引入了 JIT 技术。当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code）。然后JIT会把部分“热点代码”编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。 Hot Spot编译当 JVM 执行代码时，它并不是立即开始编译代码的。这主要有两个原因： 首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。 当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能 ，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。 第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。 JavaScript 编译 - JIT (just-in-time) compiler 是怎么工作的大体来说，有两种方式可以将程序翻译成机器可执行的指令，使用编译器 (Compiler) 或者是 解释器 (Interpreter)。 解释器解释器是边翻译，边执行。 优缺点 优点：快速执行，不需要等待编译 缺点：相同的代码可能被翻译多次，比如循环内部的代码 编译器而编译器则是提前将结果翻译出来，并生成一个可执行程序。 优缺点 优点：不需要重复编译，并且可以在编译时对代码做优化 缺点：需要提前编译 JITJavaScript 刚出现的时候，是一个典型的解释型语言，因此运行速度极慢，后来浏览器引入了 JIT compiler，大幅提高了 JavaScript 的运行速度。 原理：They added a new part to the JavaScript engine, called a monitor (aka a profiler). That monitor watches the code as it runs, and makes a note of how many times it is run and what types are used. 简单来说，浏览器在 JavaScript engine 中加入了一个 monitor，用来观察运行的代码。并记录下每段代码运行的次数和代码中的变量的类型。 那么问题来了，为什么这样做能提高运行速度？ 后面的所有内容都以下面这个函数的运行为例： function arraySum(arr) &#123; var sum = 0; for (var i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; &#125; 1st step - Interpreter 一开始只是简单的使用解释器执行，当某一行代码被执行了几次，这行代码会被打上 Warm 的标签；当某一行代码被执行了很多次，这行代码会被打上 Hot 的标签 2nd step - Baseline compiler 被打上 Warm 标签的代码会被传给Baseline Compiler编译且储存，同时按照行数 (Line number) 和变量类型 (Variable type) 被索引（为什么会引入变量类型做索引很重要，后面会讲） 当发现执行的代码命中索引，会直接取出编译后的代码执行，从而不需要重复编译已经编译过的代码 3rd step - Optimizing compiler 被打上 Hot 标签的代码会被传给 Optimizing compiler，这里会对这部分带码做更优化的编译。怎么样做更优化的编译呢？关键点就在这里，没有别的办法，只能用概率模型做一些合理的 假设 (Assumptions)。比如我们上面的循环中的代码 sum +&#x3D; arr[i]，尽管这里只是简单的 + 运算和赋值，但是因为 JavaScript 的动态类型 (Dynamic typing)，对应的编译结果有很多种可能（这个角度能很明显的暴露动态类型的缺点） 比如: sum 是 Int，arr 是 Array，i 是 Int，这里的 + 就是加法运算，对应其中一种编译结果 sum 是 string，arr 是 Array，i 是 Int，这里的 + 就是字符串拼接，并且需要把 i 转换为 string 类型… 下面的图可以看出，这么简单的一行代码对应有 2^4 &#x3D; 16 种可能的编译结果 前面第二步的 Baseline compiler 做的就是这件事，所以上面说编译后的代码需要使用line number和variable type一起做索引，因为不同的 variable type 对应不同的编译结果。 如果代码是 “Warm” 的，JIT 的任务也就到此为止，后面每次执行的时候，需要先判断类型，再使用对应类型的编译结果就好。 但是上面我们说，当代码变成 “hot” 的时候，会做更多的优化。这里的优化其实指的就是 JIT 直接假设一个前提，比如这里我们直接假设 sum 是 Int，i 也是 Int，arr 是 Array，于是就只用一种编译结果就好了。 实际上，在执行前会做类型检查，看是假设是否成立，如果不成立执行就会被打回interpreter或者baseline compiler的版本，这个操作叫做 &quot;反优化 (deoptimization)&quot;。 可以看出，只要假设的成功率足够高，那么代码的执行速度就会快。但是如果假设的成功率很低，那么会导致比没有任何优化的时候还要慢（因为要经历optimize =&gt; deoptimize的过程） 结论简而言之，这就是 JIT运行时所做的事情。它通过监控正在运行的代码并发送要优化的热代码路径，使 JavaScript 运行得更快。这使得大多数 JavaScript 应用程序的性能提高了许多倍。 然而，即使有了这些改进，JavaScript 的性能仍然无法预测。为了使速度更快，JIT 在运行时增加了一些开销，包括： 优化和反优化 用于监视器和发生信息丢失时恢复信息的内存 用于存储函数的基线和优化版本的内存 这里还有改进的空间：可以消除开销，使性能更加可预测。","link":"/2023/11/04/just-in-time-compilers/"},{"title":"构建工具之Rspack和Vite","text":"试了试把真实项目从 Vite 迁移到 Rspack，Build 速度从 125 秒缩短到了 17 秒，开发中刷新页面的速度也提升了 64 %，不过 HMR 时间比 Vite 慢多了。 如果开发过程中触发 HMR 比较多，而刷新页面比较少，Vite 还是有开发体验的优势。如果是复杂项目，刷新页面更常用，那 Rspack 的开发体验反而会更好。 前端构建的工具实在是太多了，rolldown、rollup、Rspack、Vite…… 先提前插个眼","link":"/2023/10/27/pack-tool-preview/"},{"title":"基于Vue3和MathJax渲染的Latex富文本公式编辑器完美实践","text":"前言做项目需要用到富文本编辑器，但是看了很多的富文本编辑器都很少支持公式编辑，但项目有要用到，怎么办呢？先写一个显然并不现实。于是使用easy-formula-editor和wangeditor写了一个功能小插件，是 基于Vue3和MathJax渲染的Latex富文本公式编辑器，支持零基础即可编辑公式，支持自定义编辑器配置和风格，支持二次编辑公式，支持作为插件和富文本编辑器一起使用。 零基础即可编辑公式 支持自定义编辑器配置和风格 支持二次编辑公式 支持作为插件和富文本编辑器一起使用 安装和使用NPMnpm i easy-formula-editor 或 import formulaEditor from \"easy-formula-editor\"; const editor = new formulaEditor(); editor.create('#test'); CDN&lt;script type=\"text/javascript\" src=\"../dist/formula-editor.min.js\">&lt;/script> &lt;script type=\"text/javascript\"> const editor = new formulaEditor(); editor.create('#test'); &lt;/script> 导出// latex 公式 editor.latex.text() // html 公式 editor.$textSvgElem.html() 富文本编辑器菜单栏扩展注册菜单【注意】 推荐使用全局模式来注册菜单。 如果有多个编辑器，每个编辑器的自定义菜单不一样，则使用实例的方式来注册菜单 全局模式// 菜单 key ，各个菜单不能重复 const menuKey = 'alertMenuKey' // 注册菜单 E.registerMenu(menuKey, AlertMenu) const editor = new E('#div1') editor.create() const editor2 = new E('#div2') editor2.create() 实例模式// 菜单 key ，各个菜单不能重复 const menuKey = 'alertMenuKey' const menuKey2 = 'alertMenuKey2' const editor = new E('#div1') // 注册菜单 editor.menus.extend(menuKey, AlertMenu) // 将菜单加入到 editor.config.menus 中 const menuKey = 'alertMenuKey' // 也可以通过配置 menus 调整菜单的顺序，参考【配置菜单】部分的文档 editor.config.menus.push(menuKey) editor.config.menus = editor.config.menus.concat(menuKey) // 注册完菜单，再创建编辑器，顺序很重要！！ editor.create() const editor2 = new E('#div2') editor2.menus.extend(menuKey2, AlertMenu) editor2.config.menus.push(menuKey2) editor2.create() 实际项目结合示例import E from \"wangeditor\"; import formulaEditor from \"easy-formula-editor\"; import createPanelConf from \"./create-panel-conf\"; const &#123; PanelMenu, Panel &#125; = E; class AlertMenu extends PanelMenu &#123; constructor(editor) &#123; // data-title属性表示当鼠标悬停在该按钮上时提示该按钮的功能简述 const $elem = E.$( `&lt;div class=\"w-e-menu\" data-title=\"数学公式\"> &lt;span>公式&lt;/span> &lt;/div>` ); super($elem, editor); &#125; /** * 菜单点击事件 */ clickHandler() &#123; const formula = new formulaEditor(); const conf = createPanelConf(this.editor, formula); const panel = new Panel(this, conf); panel.create(); formula.create(\"#edit-content\"); &#125; tryChangeActive() &#123;&#125; &#125; const menuKey = \"alertMenuKey\"; // 注册菜单 E.registerMenu(menuKey, AlertMenu); export default E; &#x2F;&#x2F;create-panel-conf.ts export default function (wangEditor, formulaEditor) &#123; const btnOkId &#x3D; &#39;btn-ok&#39; &#x2F;** * 插入公式 *&#x2F; function insertFomule() &#123; const formula &#x3D; formulaEditor.latex.text() &#x2F;&#x2F; 注意插入wangEditor时左右两边的空格不能去掉，不然会导致无法获取焦点 wangEditor.txt.append(&#39;&lt;p&gt;&#39;+formula+&#39;&lt;&#x2F;p&gt;&#39;) return true &#125; &#x2F;&#x2F; tabs配置 const tabsConf &#x3D; [ &#123; &#x2F;&#x2F; tab 的标题 title: &quot;插入数学公式&quot;, &#x2F;&#x2F; 模板 tpl: &#96;&lt;div&gt; &lt;div id&#x3D;&quot;edit-content&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;w-e-button-container&quot;&gt; &lt;button type&#x3D;&quot;button&quot; id&#x3D;&quot;$&#123;btnOkId&#125;&quot; class&#x3D;&quot;right&quot;&gt;插入&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&#96;, &#x2F;&#x2F; 事件绑定 events: [ &#x2F;&#x2F; 插入视频 &#123; selector: &#39;#&#39; + btnOkId, type: &#39;click&#39;, fn: insertFomule, bindEnter: true, &#125;, ], &#125;, &#x2F;&#x2F; tab end ] return &#123; width: 660, height: 0, &#x2F;&#x2F; panel 中可包含多个 tab tabs: tabsConf, &#x2F;&#x2F; tabs end &#125; &#125; 使用上面的代码，就可以在富文本编辑器中添加一个公式编辑器的菜单了： &lt;template&gt; &lt;div class&#x3D;&quot;formula-container&quot;&gt; &lt;v-card elevation&#x3D;&quot;0&quot; class&#x3D;&quot;formula-card&quot; title&#x3D;&quot;输出区域&quot; subtitle&#x3D;&quot;Output&quot;&gt; &lt;div id&#x3D;&quot;formula&quot; class&#x3D;&quot;formula-content&quot;&gt; &#123;&#123; renderedFormula ? &#96;$$&#123;renderedFormula&#125;$&#96; : &#39;&#39; &#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;v-card&gt; &lt;div class&#x3D;&quot;editor-area&quot;&gt; &lt;div id&#x3D;&quot;wang-editor&quot; class&#x3D;&quot;editor&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script setup&gt; import E from &quot;..&#x2F;utils&#x2F;formula-menu-conf&quot;; import &#123; ref, onMounted, nextTick, defineProps, watchEffect &#125; from &quot;vue&quot;; &#x2F;&#x2F; 定义props const props &#x3D; defineProps(&#123; initMessage: &#123; type: String, default: &quot;&quot;, &#125; &#125;); watchEffect(() &#x3D;&gt; &#123; props.initMessage; &#125;); const editor &#x3D; ref(null); const renderedFormula &#x3D; ref(&quot;&quot;); function convert() &#123; MathJax.texReset(); MathJax.typesetClear(); MathJax.typesetPromise(); &#125; function updateFormula() &#123; renderedFormula.value &#x3D; editor.value.txt.text(); nextTick(convert); &#125; onMounted(() &#x3D;&gt; &#123; editor.value &#x3D; new E(&quot;#wang-editor&quot;); editor.value.config.height &#x3D; 360; editor.value.config.menus &#x3D; [&#39;head&#39;, &#39;bold&#39;, &#39;underline&#39;, &#39;strikeThrough&#39;,&#39;emoticon&#39;, &#39;undo&#39;, &#39;redo&#39;]; editor.value.config.onchange &#x3D; updateFormula; editor.value.config.onchangeTimeout &#x3D; 500; editor.value.create(); editor.value.txt.html(props.initMessage); &#125;); &lt;&#x2F;script&gt; 可以看到，我们的公式编辑器和富文本编辑器完美结合了，效果如下： 贴一个wangeditor的官方文档：www.wangeditor.com/v4","link":"/2024/01/31/mathjax-latex/"},{"title":"产品思考与产品用户体验优化","text":"产品用户体验优化自己做了独立开发，最多的问题就是：怎么推广，怎么获客？」但我遇到的绝大多数的提出这个问题的人，产品都发布了，都没有过太多思考。 问题之所以发生，是因为之前的问题没有解决。站在问题链末端，很多问题是无法解决的。这就像鲁伯特之泪，拿锤子拼命砸它，不如用钳子剪断末梢。 往往解决问题的方式并不是回答问题本身，而是从上游出发解决核心矛盾。 如果你的独立产品期望快速找到100个狂热用户，通过他们快速增长，那请牢牢记住这四件事，并围绕这四件事不断向自己提问，找到解决方案： 1、定位目标用户，勾勒画像，了解当下用户遇到的问题2、提供新解决方案，确定核心功能解决核心痛点3、包装，写广告语，做落地页4、冷启动，找到100个狂热用户 选择赛道，定义目标用户： 你的用户是谁？具体画像是什么样？他们兜里有钱吗？ 现在这个时间点做这个事情，是最佳时间吗？有没有什么时刻，比现在更容易做？ 有什么政策支持或政策风险吗？ 这个产品，只能你在其中挣钱吗？怎么能让别人，也通过你的产品挣钱？ 这件事只能你来做吗？你做这件事，有什么额外的优势吗？ 在你产品上线后，有可以合作进行销售的现成渠道资源吗？ 你觉得你的产品，是具有很直接价值感的产品吗？还是需要教育用户才能意识到产品价值的？ 和你做相同事情的竞品，多吗？他们做的如何？ 用户对竞品的差评里，在抱怨什么？ 定义产品核心功能 你的产品帮助他做了什么？这个过程，他现在是怎么完成的？ 现在在持续完成这个过程的人，在你的用户画像中，占比有多高？ 他如果不用你，想达到相同效果，还有什么其他替代方案？效率上和用你的产品相比，能相差多少？ 如果你只有一个核心功能或链路，用户为其付费，这个功能是什么？ 有什么现成工具，可以帮助你快速构建这个链路吗？（或者完成初步测试） 确定营销包装 你的用户，究竟为你产品的哪个点付费？该如何凸显，才能让用户感觉这个点对他们有用？ 请用一句话打动客户为你的产品付费，这句话是什么？ 竞品包装的打动用户的点是什么？和你有差异化吗？ 如果没有差异，竞品的劣势是什么？是否可以将它的劣势转化为你的优势？进行精准打击？用户在意这个点吗？ 冷启动与扩量 你的目标用户在哪里聚集？ 你初期如何找到他们？ 你能依靠哪些资源或人，来变相触及到他们？ 当他们想要找你这类产品时，最可能从哪些渠道发现？搜索的关键词是？ 竞品都在哪里做广告？ 最有可能帮你去卖你产品的人，是谁？ 天使投资选择：关注技术变革和应用场景如果去做天使投资，我现在会看什么类型的项目？ 天使投资是最难做的，很多基金DPI都小于1，投不好基本就融不到钱了。所以如果是我，我会怎么选择？ 我请教了一个朋友，朋友讲了一个技术变革周期的故事。 从上一轮苹果开始，先是科研人员有了一些成果，促使底层技术有了革命性进展。然后出现了iphone时刻。之后伴随着一路网络基础设施建设，以及一些底层开发生态的建设，把原来web时代的场景，迁移到了移动终端上。当越来越多的场景迁移完成，开始卷不动了，人们就开始去做新场景的创新，出现了抖音，拼多多这种巨头。应用侧没的卷了，就开始卷内容，无数多的人挤进去做内容创新。 这个路线，放到AI上也一样可以借鉴的。新技术变革就像GPT3.5出现时一样，前期也是在卷模型，RAG，infra，所以这种做底层基建的，是会考虑投入的。因为长期来看，生态需要它。在每个赛道总是能跑出1，2个头部并持续发展下去的。 然而目前我们还没进入旧场景迁移的时候，目测现在的应用层还远远达不到真正实用的要求，所以暂时也不会考虑投入。很可能技术的势头一到，重新做旧场景迁移，会比现在快的多。那现在创业者做的事情，往往就会成为技术债务，船大难掉头。所以目前不会投这块的项目。 我感觉大家思路都差不多，我考量的是AI应用不成熟，所以会选择做AI流量直接变现，或者toB去做服务解决方案，而不是自己做个东西。 但其实AI应用里也会拆分，往往也有底层的应用范畴。比如和infra层对接比较紧密的，抽象能力足够强以至于可以应对变化的这种项目，也是值得看的。 这个思路其实也适用于visionOS带来的空间计算变革，只是感觉visionOS才刚刚走到新技术变革—&gt;底层基础建设 这块。","link":"/2024/02/16/pm-post1/"},{"title":"React入门-第一篇","text":"前言最近面了得物春季青训营，项目要求掌握React。之前写过一段时间Next.js，对jsx的理解还算是有些片面，作为Vuejs转React的一个开发者，打算先将Vuejs和React的功能特性做一个对比，然后再根据项目入手React。 Vuejs和React的相同点 Vue和React相同点非常多： 都使用Virtural DOM 都使用组件化思想，流程基本一致 都是响应式，推崇单向数据流（Vue的v-model指令允许在表单元素上进行双向数据绑定。） 都有成熟的社区，都支持服务端渲染 Vue和React实现原理和流程基本一致，都是使用Virtual DOM + Diff算法。 不管是Vue的template模板 + options api写法（即使用SFC体系），还是React的Class或者Function（js 的class写法也是function函数的一种）的jsx写法，底层最终都是为了生成render函数。 render函数执行返回VNode（虚拟DOM树）。 当每一次UI更新时，总会根据render重新生成最新的VNode，然后跟以前缓存起来老的VNode进行比对，再使用Diff算法（框架核心）去真正更新真实DOM（虚拟DOM是JS对象结构，同样在JS引擎中，而真实DOM在浏览器渲染引擎中，所以操作虚拟DOM比操作真实DOM开销要小的多）。 Vue和React通用流程： vue template/react jsx -&gt; render函数 -&gt; 生成VNode -&gt; 当有变化时，新老VNode diff -&gt; diff算法对比，并真正去更新真实DOM。 核心还是Virtual DOM，VNode的好处不用多说： 减少直接操作DOM。框架给我们提供了屏蔽底层dom书写的方式，减少频繁的整更新dom，同时也使得数据驱动视图 为函数式UI编程提供可能（React核心思想） 可以跨平台，渲染到DOM（web）之外的平台。比如ReactNative，Weex Vue说自己是框架，是因为官方提供了从声明式渲染到构建工具一整套东西。 React说自己是库，是因为官方只提供了React.js这个核心库，路由、状态管理这些都是社区第三方提供了，最终整合成了一套方案。 Vue和React的区别组件实现不同Vuejs实现Vue源码实现是把options挂载到Vue核心类上，然后再new Vue({options})拿到实例（vue组件的script导出的是一个挂满options的纯对象而已）。 所以options api中的this指向内部Vue实例，对用户是不透明的，所以需要文档去说明this.$slot、this.$xxx这些api。另外Vue插件都是基于Vue原型类基础之上建立的，这也是Vue插件使用Vue.install的原因，因为要确保第三方库的Vue和当前应用的Vue对象是同一个。 React实现React内部实现比较简单，直接定义render函数以生成VNode ，而React内部使用了四大组件类包装VNode，不同类型的VNode使用相应的组件类处理，职责划分清晰明了（后面的Diff算法也非常清晰）。React类组件都是继承自React.Component类，其this指向用户自定义的类，对用户来说是透明的。 响应式原理不同Vuejs实现 Vue依赖收集，自动优化，数据可变。 Vue递归监听data的所有属性,直接修改。 当数据改变时，自动找到引用组件重新渲染。 React实现 React基于状态机，手动优化，数据不可变，需要setState驱动新的State替换老的State。 当数据改变时，以组件为根目录，默认全部重新渲染 diff算法不同Vue基于snabbdom库，它有较好的速度以及模块机制。Vue Diff使用双向链表，边对比，边更新DOM。 React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。 事件机制不同Vuejs实现 Vue原生事件使用标准Web事件 Vue组件自定义事件机制，是父子组件通信基础 Vue合理利用了snabbdom库的模块插件 React实现 React原生事件被包装，所有事件都冒泡到顶层document监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和Web DOM强绑定。 React组件上无事件，父子组件通信使用props","link":"/2024/01/20/react-1/"},{"title":"React入门-第二篇","text":"前言这一篇主要来聊一聊React的JSX如何被编译成VNode的。 Vue的render函数在此之前，我们都知道，Vue是使用Vue模板方法的方式进行组件的声明。我们先来回顾一下Vue是怎么处理的。 Vue模板经过Vue的编译器编译成render函数，最后render函数返回VNode，然后再通过patch函数将VNode渲染成真实DOM。 具体的renderer细节在以前的章节里面有提到过，这边就不再赘述了。 React的JSXreact通过将组件编写的JSX映射到屏幕，以及组件中的状态发生了变化之后 React会将这些「变化」更新到屏幕上 JSX通过babel最终转化成React.createElement这种形式,至于babel是具体怎么将JSX转化成React.createElement的，我们可以通过babel的在线编译器来查看。 &lt;div&gt; &lt; img src&#x3D;&quot;avatar.png&quot; className&#x3D;&quot;profile&quot; &#x2F;&gt; &lt;Hello &#x2F;&gt; &lt;&#x2F;div&gt; 会被bebel转化成如下： React.createElement( \"div\", null, React.createElement(\"img\", &#123; src: \"avatar.png\", className: \"profile\" &#125;), React.createElement(Hello, null) ); Babel提供一个REPL在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行,这边贴一个链接：https://babeljs.io/ 在转化过程中，babel在编译时会判断 JSX 中组件的首字母： 当首字母为小写时，其被认定为原生 DOM 标签，createElement 的第一个变量被编译为字符串 当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象 最终都会通过RenderDOM.render(...)方法进行挂载，如下： ReactDOM.render(&lt;App />, document.getElementById(\"root\")); React的JSX转换具体是怎么做的呢在react中，节点大致可以分成四个类别： 原生标签节点 文本节点 函数组件 类组件 如下所示： class ClassComponent extends Component &#123; static defaultProps = &#123; color: \"pink\" &#125;; render() &#123; return ( &lt;div className=\"border\"> &lt;h3>ClassComponent&lt;/h3> &lt;p className=&#123;this.props.color&#125;>&#123;this.props.name&#125;&lt;/p > &lt;/div> ); &#125; &#125; function FunctionComponent(props) &#123; return ( &lt;div className=\"border\"> FunctionComponent &lt;p>&#123;props.name&#125;&lt;/p > &lt;/div> ); &#125; const jsx = ( &lt;div className=\"border\"> &lt;p>xx&lt;/p > &lt; a href=\" \">xxx&lt;/ a> &lt;FunctionComponent name=\"函数组件\" /> &lt;ClassComponent name=\"类组件\" color=\"red\" /> &lt;/div> ); 这些类别最终都会被转化成React.createElement这种形式 React.createElement其被调用时会传⼊标签类型type，标签属性props及若干子元素children，作用是生成一个虚拟Dom对象，如下所示： function createElement(type, config, ...children) &#123; if (config) &#123; delete config.__self; delete config.__source; &#125; // ! 源码中做了详细处理，⽐如过滤掉key、ref等 const props = &#123; ...config, children: children.map(child => typeof child === \"object\" ? child : createTextNode(child) ) &#125;; return &#123; type, props &#125;; &#125; function createTextNode(text) &#123; return &#123; type: TEXT, props: &#123; children: [], nodeValue: text &#125; &#125;; &#125; export default &#123; createElement &#125;; createElement会根据传入的节点信息进行一个判断： 如果是原生标签节点， type 是字符串，如div、span 如果是文本节点， type就没有，这里是 TEXT 如果是函数组件，type 是函数名 如果是类组件，type 是类名 虚拟DOM会通过ReactDOM.render进行渲染成真实DOM，使用方法如下： ReactDOM.render(element, container[, callback]) 当首次调用时，容器节点里的所有 DOM 元素都会被替换，后续的调用则会使用 React 的 diff算法进行高效的更新 如果提供了可选的回调函数callback，该回调将在组件被渲染或更新之后被执行render大致实现方法如下： function render(vnode, container) &#123; console.log(\"vnode\", vnode); // 虚拟DOM对象 // vnode _> node const node = createNode(vnode, container); container.appendChild(node); &#125; // 创建真实DOM节点 function createNode(vnode, parentNode) &#123; let node = null; const &#123;type, props&#125; = vnode; if (type === TEXT) &#123; node = document.createTextNode(\"\"); &#125; else if (typeof type === \"string\") &#123; node = document.createElement(type); &#125; else if (typeof type === \"function\") &#123; node = type.isReactComponent ? updateClassComponent(vnode, parentNode) : updateFunctionComponent(vnode, parentNode); &#125; else &#123; node = document.createDocumentFragment(); &#125; reconcileChildren(props.children, node); updateNode(node, props); return node; &#125; // 遍历下子vnode，然后把子vnode->真实DOM节点，再插入父node中 function reconcileChildren(children, node) &#123; for (let i = 0; i &lt; children.length; i++) &#123; let child = children[i]; if (Array.isArray(child)) &#123; for (let j = 0; j &lt; child.length; j++) &#123; render(child[j], node); &#125; &#125; else &#123; render(child, node); &#125; &#125; &#125; function updateNode(node, nextVal) &#123; Object.keys(nextVal) .filter(k => k !== \"children\") .forEach(k => &#123; if (k.slice(0, 2) === \"on\") &#123; let eventName = k.slice(2).toLocaleLowerCase(); node.addEventListener(eventName, nextVal[k]); &#125; else &#123; node[k] = nextVal[k]; &#125; &#125;); &#125; // 返回真实dom节点 // 执行函数 function updateFunctionComponent(vnode, parentNode) &#123; const &#123;type, props&#125; = vnode; let vvnode = type(props); const node = createNode(vvnode, parentNode); return node; &#125; // 返回真实dom节点 // 先实例化，再执行render函数 function updateClassComponent(vnode, parentNode) &#123; const &#123;type, props&#125; = vnode; let cmp = new type(props); const vvnode = cmp.render(); const node = createNode(vvnode, parentNode); return node; &#125; export default &#123; render &#125;; 在react源码中，虚拟Dom转化成真实Dom整体流程如下图所示： 其渲染流程如下所示： 使用React.createElement或JSX编写React组件，实际上所有的 JSX 代码最后都会转换成React.createElement(...) ，Babel帮助我们完成了这个转换的过程。 createElement函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的孩子节点进行处理，最终构造成一个虚拟DOM对象 ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM","link":"/2024/01/20/react-2/"},{"title":"React入门-第三篇","text":"前言本篇主要对React的状态进行一个介绍。 声明式 UI 与命令式 UI 的比较 当你设计 UI 交互时，可能会去思考 UI 如何根据用户的操作而响应变化。想象一个允许用户提交一个答案的表单： 当你向表单输入数据时，“提交”按钮会随之变成可用状态 当你点击“提交”后，表单和提交按钮都会随之变成不可用状态，并且会加载动画会随之出现 如果网络请求成功，表单会随之隐藏，同时“提交成功”的信息会随之出现 如果网络请求失败，错误信息会随之出现，同时表单又变为可用状态 在 命令式编程 中，以上的过程直接告诉你如何去实现交互。你必须去根据要发生的事情写一些明确的命令去操作 UI。 而在Vuejs渐进式框架和React库里面都是采用的声明式编程。 声明式地考虑 UI你已经从上面的例子看到如何去实现一个表单了，为了更好地理解如何在 React 中思考，一般情况下要用 React 重新实现这个 UI就要经过这几个一般步骤： 定位你的组件中不同的视图状态 确定是什么触发了这些 state 的改变 表示内存中的 state（需要使用 useState） 删除任何不必要的 state 变量 连接事件处理函数去设置 state React的状态管理在React中，状态管理是一个非常重要的概念，React的状态管理是通过state来实现的。 statestate是React组件中的一个内置对象，用于存储组件内部的状态。state是一个普通的JavaScript对象，我们可以通过this.state来访问它。 React 会为 UI 中的组件结构构建 渲染树。 当向一个组件添加状态时，那么可能会认为状态“存在”在组件内。但实际上，状态是由 React 保存的。React 通过组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来。 这边与Vuejs的区别是，Vue的响应式系统是与组件进行隔离开来的，而React的状态是与组件进行绑定的。 我们将state嵌入进React的组件里面，作为组件vnode的一部分信息，当React的state更新时，也意味着组件的信息更新，会触发组件的重新渲染。 如果理解了这一点，那么我们就可以很轻易的理解React的响应式是怎么工作的了，React的状态是与组件绑定的，当状态更新时，组件也会更新，这也是React的响应式系统。 我们来具体给一个例子： import &#123; useState &#125; from 'react'; export default function App() &#123; const counter = &lt;Counter />; return ( &lt;div> &#123;counter&#125; &#123;counter&#125; &lt;/div> ); &#125; function Counter() &#123; const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) &#123; className += ' hover'; &#125; return ( &lt;div className=&#123;className&#125; onPointerEnter=&#123;() => setHover(true)&#125; onPointerLeave=&#123;() => setHover(false)&#125; > &lt;h1>&#123;score&#125;&lt;/h1> &lt;button onClick=&#123;() => setScore(score + 1)&#125;> 加一 &lt;/button> &lt;/div> ); &#125; 下面是它们的树形结构的样子： 这是两个独立的 counter，因为它们在树中被渲染在了各自的位置。 一般情况下你不用去考虑这些位置来使用 React，但知道它们是如何工作会很有用。 而他们有各自的状态，因为每个组件实例都有自己的 state。 你可以在一个组件中使用多个 state 变量。当我更新了state之后，会触发组件的重新渲染，这边我们可以看到，两个counter的状态是独立的，互不影响。 相同位置的相同组件会使得 state 被保留下来 import &#123; useState &#125; from 'react'; export default function App() &#123; const [isFancy, setIsFancy] = useState(false); return ( &lt;div> &#123;isFancy ? ( &lt;Counter isFancy=&#123;true&#125; /> ) : ( &lt;Counter isFancy=&#123;false&#125; /> )&#125; &lt;label> &lt;input type=\"checkbox\" checked=&#123;isFancy&#125; onChange=&#123;e => &#123; setIsFancy(e.target.checked) &#125;&#125; /> 使用好看的样式 &lt;/label> &lt;/div> ); &#125; function Counter(&#123; isFancy &#125;) &#123; const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) &#123; className += ' hover'; &#125; if (isFancy) &#123; className += ' fancy'; &#125; return ( &lt;div className=&#123;className&#125; onPointerEnter=&#123;() => setHover(true)&#125; onPointerLeave=&#123;() => setHover(false)&#125; > &lt;h1>&#123;score&#125;&lt;/h1> &lt;button onClick=&#123;() => setScore(score + 1)&#125;> 加一 &lt;/button> &lt;/div> ); &#125; 那么相同位置的不同组件会使 state 重置，这一点应该大家也能够知道为什么了。 再举一个例子：将一个&lt;Counter&gt; 替换为一个 &lt;p&gt; 当 Counter 变为 p 时，Counter 会被移除，同时 p 被添加。 当切换回来时，p 会被删除，而 Counter 会被添加 参考的React文档在这里：状态与渲染树中的位置相关 提取状态逻辑到 reducer 中对于那些需要更新多个状态的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以在组件外部将所有状态更新逻辑合并到一个称为 “reducer” 的函数中。这样，事件处理程序就会变得简洁，因为它们只需要指定用户的 “actions”。在文件的底部，reducer 函数指定状态应该如何更新以响应每个 action！ useReducer 是 React 中的一个 Hook，用于管理组件的状态逻辑。它提供了一种更复杂状态逻辑的组织方式，适用于那些包含多个子值或需要根据先前的状态来更新的状态。 useReducer 的使用方式类似于 Redux 中的 reducer 概念。 下面是 useReducer 的基本用法： import React, &#123; useReducer &#125; from 'react'; // reducer函数，接受当前state和action，返回新的state const reducer = (state, action) => &#123; switch (action.type) &#123; case 'INCREMENT': return &#123; count: state.count + 1 &#125;; case 'DECREMENT': return &#123; count: state.count - 1 &#125;; default: return state; &#125; &#125;; const initialState = &#123; count: 0 &#125;; const Counter = () => &#123; // 使用useReducer，传入reducer和初始state const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;div> Count: &#123;state.count&#125; &lt;button onClick=&#123;() => dispatch(&#123; type: 'INCREMENT' &#125;)&#125;>Increment&lt;/button> &lt;button onClick=&#123;() => dispatch(&#123; type: 'DECREMENT' &#125;)&#125;>Decrement&lt;/button> &lt;/div> ); &#125;; export default Counter; 主要的步骤包括： 定义 reducer 函数： 这个函数接收当前状态 state 和一个描述动作的 action，然后根据 action 的类型执行相应的逻辑，并返回新的状态。 初始化状态： 通过调用 useReducer(reducer, initialState) 来创建状态和 dispatch 函数。 在组件中使用状态和 dispatch： 通过 state 访问当前状态值，通过 dispatch 触发 reducer 执行。 使用 Context 进行深层数据传递通常，你会通过 props 将信息从父组件传递给子组件。 但是，如果要在组件树中深入传递一些 prop，或者树里的许多组件需要使用相同的 prop，那么传递 prop 可能会变得很麻烦。Context 允许父组件将一些信息提供给它下层的任何组件，不管该组件多深层也无需通过 props 逐层透传。 import React, &#123; createContext, useContext, useState &#125; from 'react'; // 创建一个Context const MyContext = createContext(); // 创建一个包含Provider和Consumer的组件 const MyProvider = (&#123; children &#125;) => &#123; const [data, setData] = useState('Hello from Context'); return ( &lt;MyContext.Provider value=&#123;&#123; data, setData &#125;&#125;> &#123;children&#125; &lt;/MyContext.Provider> ); &#125;; // 使用 useContext 获取Context中的值 const ChildComponent = () => &#123; const &#123; data, setData &#125; = useContext(MyContext); return ( &lt;div> &lt;p>&#123;data&#125;&lt;/p> &lt;button onClick=&#123;() => setData('Updated Context')&#125;>Update Context&lt;/button> &lt;/div> ); &#125;; // 在应用中使用Provider包裹需要共享数据的组件 const App = () => &#123; return ( &lt;MyProvider> &lt;ChildComponent /> &lt;/MyProvider> ); &#125;; export default App; 使用 Reducer 和 Context 进行状态扩展Reducer 帮助你合并组件的状态更新逻辑同时Context 帮助你将信息深入传递给其他组件。 你可以将 reducers 和 context 组合在一起使用，以管理复杂应用的状态。 基于这种想法，使用 reducer 来管理一个具有复杂状态的父组件。组件树中任何深度的其他组件都可以通过 context 读取其状态。还可以 dispatch 一些 action 来更新状态。 合理的使用 Reducer 和 Context 可以帮助你更好的管理状态，同时也可以让你的代码更加简洁。 相比于Vuejs基于Proxy的响应式系统，使用代理的方式，以及provide和inject的方式，Vuejs的状态管理是在一个单独的WeekMap里面进行管理的，当变量的状态进行改变，可以激活effect副作用函数，并进行值的更新。而React的状态管理是与组件绑定的，当状态更新时，组件也会更新，但是当我们要进行一个全局状态的管理时，就得进行在父组件里面定义。 能基于具体的情况进行React状态的定义，才能更好的进行状态的管理。","link":"/2024/01/23/react-3/"},{"title":"vue-Proxy和Reflect","text":"引言既然 Vue.js 3 的响应式数据是基于 Proxy 实现的，那么我们就有必要了解 Proxy 以及与之相关联的 Reflect。什么是 Proxy 呢？简单地说，使用 Proxy 可以创建一个代理对象。它能够实现对其他对象的代理，这里的关键词是其他对象，也就是说，Proxy 只能代理对象，无法代理非对象值，例如字符串、布尔值等。那么，代理指的是什么呢？所谓代理，指的是对一个对象基本语义的代理。它允许我们拦截并重新定义对一个对象的基本操作。 创建对象代理 Proxy 内置的对象 Reflect 当我们讨论编程语言中的”基本语义”时，我们指的是对数据进行读取和修改的最基本操作。在JavaScript中，这些操作通常包括读取属性值和设置属性值。例如，在给定一个对象obj的情况下，以下操作被认为是基本语义的操作： 读取属性值：obj.foo （读取属性foo的值） 设置属性值：obj.foo = newValue （设置属性foo的值） 在上述代码中，Proxy对象允许我们拦截（或者说重定义）这些基本语义的操作。Proxy的构造函数接受两个参数：被代理的对象和一个包含拦截器（也称为夹子或陷阱）的对象。在拦截器对象中，我们可以定义get方法来拦截读取属性操作，定义set方法来拦截设置属性操作。这样，我们就可以在这些操作发生时执行自定义的逻辑。 关于Reflect对象，它是JavaScript的一个全局对象，提供了与Proxy拦截器方法一一对应的方法。这些Reflect方法提供了默认的操作行为。例如，Reflect.get(target, key)方法提供了访问对象属性的默认行为，与直接使用target[key]是等价的。同时，Reflect方法还可以接受第三个参数，用来指定函数调用时的this值。 理解这些基本语义操作以及如何使用Proxy和Reflect来拦截和处理这些操作，是理解JavaScript中响应式数据（Reactive Data）实现的关键。在响应式数据中，我们可以利用Proxy和Reflect来追踪对象属性的读取和修改，从而实现数据的响应式更新。 Proxy 的基本用法当我们谈论基本语义时，我们指的是 JavaScript 中的一些基本操作，比如读取对象属性值和设置对象属性值。考虑下面的对象 obj： const obj = &#123; foo: 1 &#125;; 在这里，obj.foo 是一个读取属性的基本语义操作，obj.foo = newValue 是一个设置属性的基本语义操作。 现在，我们可以使用 Proxy 来拦截这些基本语义的操作。 const handler = &#123; get(target, key) &#123; console.log(`读取属性 $&#123;key&#125;`); return target[key]; &#125;, set(target, key, value) &#123; console.log(`设置属性 $&#123;key&#125; 为 $&#123;value&#125;`); target[key] = value; &#125; &#125;; const proxyObj = new Proxy(obj, handler); proxyObj.foo; // 输出：读取属性 foo proxyObj.foo = 2; // 输出：设置属性 foo 为 2 在上面的代码中，我们创建了一个 handler 对象，其中定义了 get 和 set 方法，用来拦截属性的读取和设置。然后，我们使用 Proxy 构造函数创建了一个代理对象 proxyObj，它会拦截 obj 对象上的读取和设置操作。当我们访问 proxyObj.foo 时，会触发 get 方法，输出相应的信息。当我们设置 proxyObj.foo 的值时，会触发 set 方法，同样输出相应的信息。 这样，Proxy 允许我们在基本语义操作发生时执行自定义的逻辑，而不需要直接操作原始对象。在实际应用中，这种能力可以用来实现响应式数据、数据验证、日志记录等功能。 当我们使用 Proxy 拦截对象属性的读取操作时，我们需要特别注意访问器属性（accessor properties）的情况，因为访问器属性使用 getter 函数来定义，而这个函数内部的 this 关键字会根据调用方式而变化。 Reflect 在响应式中的用法在拦截器函数中，我们希望建立副作用函数与响应式数据之间的关联，确保当属性被访问时，能够正确地进行依赖收集，以便在属性发生变化时触发副作用函数的重新执行。然而，如果我们直接使用 target[key] 来获取属性值，那么访问器属性内部的 this 关键字将指向原始对象，而不是代理对象，这会导致无法正确建立响应关系。 解决这个问题的方法是使用 Reflect.get(target, key, receiver) 来代替 target[key]。这样，Reflect.get 的第三个参数 receiver 就能正确地指向代理对象，而不是原始对象。这样一来，在访问器属性的 getter 函数内部，this 关键字就会指向代理对象，从而建立了正确的响应关系。 以下是使用 Reflect.get 的修正代码： const handler = &#123; get(target, key, receiver) &#123; track(target, key); // 响应式数据依赖收集 return Reflect.get(target, key, receiver); // 使用 Reflect.get 获取属性值 &#125;, // 其他拦截器方法... &#125;; const proxyObj = new Proxy(obj, handler); effect(() => &#123; console.log(proxyObj.bar); // 在副作用函数内部访问 bar 属性 &#125;); proxyObj.foo++; // 触发副作用函数的重新执行 我们可以再看一个简单一点的示例： 当使用代理对象时，receiver参数主要用于确保在代理的拦截函数内部，this指向代理对象，从而建立响应式联系。下面我将对比使用receiver参数和不使用的情况，以便更清楚地理解它的作用。 1. 使用receiver参数的情况：const data = &#123; foo: 1 &#125;; const proxy = new Proxy(data, &#123; get(target, key, receiver) &#123; // 使用 Reflect.get 保证 this 指向代理对象 const result = Reflect.get(target, key, receiver); // 在实际应用中，你可能还需要进行其他处理，例如触发更新操作等 console.log(`Accessed $&#123;key&#125; property with value $&#123;result&#125;`); return result; &#125; &#125;); console.log(proxy.foo); // 输出: Accessed foo property with value 1 在这个例子中，我们使用了receiver参数传递给Reflect.get，确保在get拦截函数内部，this指向代理对象proxy。当你访问proxy.foo时，get拦截函数被触发，并且this指向proxy对象。 2. 不使用receiver参数的情况：const data = &#123; foo: 1 &#125;; const proxy = new Proxy(data, &#123; get(target, key) &#123; // 不使用 receiver 参数，this 指向原始对象 data const result = target[key]; // 在实际应用中，你可能还需要进行其他处理，例如触发更新操作等 console.log(`Accessed $&#123;key&#125; property with value $&#123;result&#125;`); return result; &#125; &#125;); console.log(proxy.foo); // 输出: Accessed foo property with value 1 在这个例子中，我们没有使用receiver参数。由于没有传递receiver参数，this在get拦截函数内部指向的是原始对象data。虽然代理对象proxy被使用，但get拦截函数内部的this并不指向proxy，而是指向原始对象data。因此，这种情况下，响应式联系不会得到建立。 虽然说两个函数的输出是一致的，但显然没有使用receiver参数时响应式联系不会得到建立。也就是说在effect函数里面，对象不会得到正确的响应。","link":"/2023/11/01/vue-Proxy-and-Reflect/"},{"title":"Vuejs 组件的实现原理","text":"前言我们在前面讨论过了vue渲染器，渲染器主要负责将虚拟 DOM 渲染为真实 DOM ，我们只需要使用虚拟 DOM来描述最终呈现的内容即可。 但当我们编写比较复杂的页面时，用来描述页面结构的虚拟 DOM 的代码量会变得越来越多，或者说页面模板会变得越来越大。这时，我们就需要组件化的能力。 有了组件，我们就可以将一个大的页面拆分为多个部分，每一个部分都可以作为单独的组件，这些组件共同组成完整的页面。组件化的实现同样需要渲染器的支持 渲染组件从用户的角度来看，一个有状态组件就是一个选项对象，如下面的代码所示： // MyComponent 是一个组件，它的值是一个选项对象 const MyComponent = &#123; name: 'MyComponent', data()&#123; return &#123;foo: 1 &#125; &#125; &#125; 但是，如果从渲染器的内部实现来看，一个组件则是一个特殊类型的虚拟 DOM 节点。例如，为了描述普通标签，我们用虚拟节点的vnode.type 属性来存储标签名称，如下面的代码所示： // 该 vnode 用来描述普通标签 const vnode = &#123; type: 'div' // ... &#125; 为了描述片段，我们让虚拟节点的 vnode.type 属性的值为Fragment, 而为了描述文本，我们让虚拟节点的 vnode.type 属性的值为Text， 还记得我们之前在渲染器讨论过的patch函数吗？ 在patch函数中，Vue会根据新旧虚拟DOM节点的差异进行不同的处理逻辑。 如果是首次渲染，会执行首次渲染的逻辑；如果是更新渲染，会根据差异更新实际的DOM节点。 function patch(n1, n2, container, anchor) &#123; // 02. 如果新旧节点类型不同，执行卸载操作 if (n1 &amp;&amp; n1.type !== n2.type) &#123; unmount(n1); n1 = null; &#125; // 07. 获取节点类型 const &#123; type &#125; = n2; // 09. 判断节点类型 if (typeof type === 'string') &#123; // 10. 处理普通元素 // TODO: 处理普通元素的逻辑 &#125; else if (type === Text) &#123; // 11. 处理文本节点 // TODO: 处理文本节点的逻辑 &#125; else if (type === Fragment) &#123; // 13. 处理片段 // TODO: 处理片段的逻辑 &#125; // 返回新节点的实际DOM元素 return n2.el; &#125; 可以看到，渲染器会使用虚拟节点的 type 属性来区分其类型。对于不同类型的节点，需要采用不同的处理方法来完成挂载和更新。 实际上，对于组件来说也是一样的。为了使用虚拟节点来描述组件，我们可以用虚拟节点的 vnode.type 属性来存储组件的选项对象 function patch(n1, n2, container, anchor) &#123; // 02. 如果新旧节点类型不同，执行卸载操作 if (n1 &amp;&amp; n1.type !== n2.type) &#123; unmount(n1); n1 = null; &#125; // 07. 获取节点类型 const type = n2.type; // 09. 判断节点类型 if (typeof type === 'string') &#123; // 10. 处理普通元素 // TODO: 处理普通元素的逻辑 &#125; else if (type === Text) &#123; // 11. 处理文本节点 // TODO: 处理文本节点的逻辑 &#125; else if (type === Fragment) &#123; // 13. 处理片段 // TODO: 处理片段的逻辑 &#125; else if (typeof type === 'object') &#123; // 16. vnode.type 的值是选项对象，作为组件来处理 if (!n1) &#123; // 17. 挂载组件 mountComponent(n2, container, anchor); &#125; else &#123; // 21. 更新组件 patchComponent(n1, n2, anchor); &#125; &#125; // 返回新节点的实际DOM元素 return n2.el; &#125; 在上面这段代码中，我们新增了一个 else if 分支，用来处理虚拟节点的 vnode.type 属性值为对象的情况，即将该虚拟节点作为组件的描述来看待，并调用 mountComponent 和 patchComponent 函数来完成组件的挂载和更新。 上面我们回顾了有关于组件的一些基本概念，组件的挂载和更新是如何实现的，其实我们更关注的还应该是用户应该如何编写组件？组件的选项对象必须包含哪些内容？以及组件拥有哪些能力？ 因此，一个组件必须包含一个渲染函数，即 render 函数，并且渲染函数的返回值应该是虚拟 DOM。换句话说，组件的渲染函数就是用来描述组件所渲染内容的接口，如下面的代码所示： // MyComponent 组件定义 const MyComponent = &#123; // 组件名称，可选 name: 'MyComponent', // 组件的渲染函数，其返回值必须为虚拟 DOM,一个组件必须包含一个渲染函数，即 render 函数，并且渲染函数的返回值应该是虚拟 DOM render() &#123; // 返回虚拟 DOM return &#123; type: 'div', children: ['text content'] &#125;; &#125; &#125;; // 用来描述组件的 vnode 对象，type 属性值为组件的选项对象 const CompNode = &#123; type: MyComponent &#125;; // 调用渲染器来渲染组件 renderer.render(CompNode, document.querySelector('#app')); // 渲染器中真正完成组件渲染任务的是 mountComponent 函数 function mountComponent(vnode, container, anchor) &#123; // 通过 vnode 获取组件的选项对象，即 vnode.type const componentOptions = vnode.type; // 获取组件的渲染函数 render const render = componentOptions.render; // 执行渲染函数，获取组件要渲染的内容，即 render 函数返回的虚拟 DOM const subTree = render(); // 最后调用 patch 函数来挂载组件所描述的内容，即 subTree patch(null, subTree, container, anchor); &#125; 总结我们现在来回顾一下组件的基础，我们显式声明了一个组件的对象实例，该组件的选项对象必须包含一个渲染函数，即 render 函数，并且渲染函数的返回值应该是虚拟 DOM，之后我们再调用render和patch进行组件的更新和替换。换句话说，组件的渲染函数就是用来描述组件所渲染内容的接口，而渲染器的作用就是将组件的渲染函数的返回值渲染为真实 DOM。","link":"/2023/12/08/vue-component-1/"},{"title":"Vuejs 组件事件与 emit 的实现","text":"前言想把Vuejs 组件事件与 emit 的实现讲清楚，我先要把组件事件和emit的应用讲清楚，这样大家会更清楚的理解组件事件和emit的实现。 对于组件事件，我们其实之前就已经提到过了浏览器的事件机制： 浏览器事件回顾浏览器事件是指在 Web 页面中发生的各种交互和状态变化的信号。这些事件可以由用户的操作、浏览器的状态变化或其他一些因素触发。以下是一些常见的 DOM 事件和它们的简介： 鼠标事件： click： 当鼠标点击一个元素时触发。对于触摸屏设备，也会在触摸屏上进行点击时触发。 contextmenu： 当鼠标右键点击一个元素时触发。 mouseover &#x2F; mouseout： 当鼠标指针移入或离开一个元素时触发。 mousedown &#x2F; mouseup： 当在元素上按下或释放鼠标按钮时触发。 mousemove： 当鼠标移动时触发。 键盘事件： keydown 和 keyup： 当按下和松开一个按键时触发。 表单（form）元素事件： submit： 当访问者提交了一个 &lt;form&gt; 时触发。 focus： 当访问者聚焦于一个元素时触发，例如聚焦于一个 &lt;input&gt;。 Document 事件： DOMContentLoaded： 当 HTML 的加载和处理均完成，DOM 被完全构建完成时触发。 CSS 事件： transitionend： 当一个 CSS 动画完成时触发。 这些事件可以通过 JavaScript 中的事件监听器来捕获和处理。例如，通过给元素添加事件监听器，可以在特定事件发生时执行相应的代码。事件是 Web 开发中交互和响应的基础。 那我们所说的组件事件和浏览器事件有什么区别呢？ 对于事件这一个定义，我们可以这样理解：事件是指在特定的时间点上发生的事情，在某个时间点产生了一个信号，而信号可以被接收处理，这就是事件。 下面我们所说的组件事件，其实相对于浏览器事件来说更为宏观，它是指在Vue组件中，组件之间的通信方式，而这种通信方式是通过事件来实现的，这里的事件就是我们所说的组件事件。 Vue 组件之间通过事件进行通信的主要机制是通过 emit 和 on 方法。当子组件需要向父组件通信时，它会触发一个事件，并通过 emit 方法将事件发送出去；而父组件则通过在模板中使用 v-on 指令监听这个事件，从而执行相应的逻辑。 &lt;!-- 子组件 ChildComponent.vue --> &lt;template> &lt;button @click=\"sendMessage\">点击通知父组件&lt;/button> &lt;/template> &lt;script> export default &#123; methods: &#123; sendMessage() &#123; // 使用 emit 发送自定义事件 this.$emit('child-event', 'Hello from child!'); &#125; &#125; &#125; &lt;/script> &lt;!-- 父组件 ParentComponent.vue --> &lt;template> &lt;div> &lt;child-component @child-event=\"handleChildEvent\">&lt;/child-component> &lt;p>从子组件接收的消息: &#123;&#123; messageFromChild &#125;&#125;&lt;/p> &lt;/div> &lt;/template> &lt;script> import ChildComponent from './ChildComponent.vue'; export default &#123; components: &#123; ChildComponent &#125;, data() &#123; return &#123; messageFromChild: '' &#125;; &#125;, methods: &#123; handleChildEvent(message) &#123; // 使用 v-on 监听子组件的事件 this.messageFromChild = message; &#125; &#125; &#125; &lt;/script> Vue 的事件机制是通过发布&#x2F;订阅模式实现的。$emit 用于发布（触发）事件，而 v-on 则用于订阅（监听）事件。这使得不同组件之间可以相互通信，实现了组件之间的解耦。 首先，我们会注意到，子组件通过 this.$emit(‘child-event’, ‘Hello from child!’) 发送了一个自定义事件 child-event，而父组件则通过 @child-event&#x3D;”handleChildEvent” 监听了这个事件。 这里的 child-event 就是我们自定义的事件名，而 handleChildEvent 则是父组件中定义的一个方法，用于处理子组件发送过来的消息。 当使用一个自定义的MyComponent组件时，我们可以监听由 emit 函数发射的自定义事件 可以看到，自定义事件 change 被编译成名为 onChange 的属性，并存储在 props 数据对象中。这实际上是一种约定。作为框架设计者，也可以按照自己期望的方式来设计事件的编译结果。在具体的实现上，发射自定义事件的本质就是根据事件名称去props 数据对象中寻找对应的事件处理函数并执行，如下面的代码所示： emit的实现// MyComponent 组件定义 const MyComponent = &#123; name: 'MyComponent', setup(props, &#123; emit &#125;) &#123; // 发射 change 事件，并传递给事件处理函数两个参数 emit('change', 1, 2); return () => &#123; // 组件的渲染逻辑 return /* ... */; &#125;; &#125; &#125;; 上面这一段代码会被编译成一个节点 CompNode，它的类型为 MyComponent 组件，同时会将 emit 函数传递给组件的 setup 函数，如下所示： // 定义一个 Vue 组件节点 CompNode const CompNode = &#123; // 指定节点的类型为 MyComponent 组件 type: MyComponent, // 为组件传递的 props 对象 props: &#123; // 在 MyComponent 组件中，会有一个 onChange 的事件处理函数，其值为 handler onChange: handler &#125; &#125;; 可以看到，自定义事件 change 被编译成名为 onChange 的属性，并存储在 props 数据对象中。这实际上是一种约定。作为框架设计者，也可以按照自己期望的方式来设计事件的编译结果。 在具体的实现上，发射自定义事件的本质就是根据事件名称去props 数据对象中寻找对应的事件处理函数并执行，如下面的代码所示： // 挂载组件 function mountComponent(vnode, container, anchor) &#123; // 省略部分代码 const instance = &#123; state, // 状态 props: shallowReactive(props), // 响应式处理 props isMounted: false, subTree: null &#125;; // 定义 emit 函数，它接收两个参数 // event: 事件名称 // payload: 传递给事件处理函数的参数 function emit(event, ...payload) &#123; // 根据约定对事件名称进行处理，例如 change --> onChange const eventName = `on$&#123;event[0].toUpperCase()&#125;$&#123;event.slice(1)&#125;`; // 根据处理后的事件名称去 props 中寻找对应的事件处理函数 const handler = instance.props[eventName]; if (handler) &#123; // 调用事件处理函数并传递参数 handler(...payload); &#125; else &#123; console.error('事件不存在'); &#125; &#125; // 将 emit 函数添加到 setupContext 中 const setupContext = &#123; attrs, emit &#125;; // 省略部分代码 &#125; // 解析 props 数据的函数，对事件类型的 props 做特殊处理 function resolveProps(options, propsData) &#123; const props = &#123;&#125;; const attrs = &#123;&#125;; for (const key in propsData) &#123; // 以字符串 'on' 开头的 props 添加到 props 数据中，否则添加到 attrs 中 if (key in options || key.startsWith('on')) &#123; props[key] = propsData[key]; &#125; else &#123; attrs[key] = propsData[key]; &#125; &#125; return [props, attrs]; &#125; emit 的实现原理主要涉及两个方面：setupContext 的注入和事件名称的约定转换。 setupContext 的注入： 在 Vue 的组件中，setup 函数接收两个参数：props 和 context。context 中包含了一系列属性和方法，其中之一就是 emit 函数。Vue 3 的组件中，setup 函数返回的对象中，可以将 emit 函数添加到 setupContext 中，以便用户在组件内通过 setupContext.emit 访问。 下面是一个简单的例子，展示了如何在 setup 函数中添加 emit 到 setupContext： setup(props, context) &#123; // 添加 emit 到 setupContext context.emit = emit; // 其他 setup 逻辑 // ... // 返回 setup 返回的对象 return &#123;&#125;; &#125; 这样，在组件内部，用户就可以通过 setupContext.emit 来调用 emit 函数了。 事件名称的约定转换： 在 emit 函数内部，为了匹配组件模板中的事件处理函数，需要对事件名称进行约定转换。Vue 使用了一种约定，将事件名称转换为驼峰命名的形式。例如，change 事件会转换为 onChange。这样，用户在组件模板中监听事件时，可以使用驼峰命名的方式。 下面是一个简单的例子，展示了事件名称的约定转换： function emit(event, ...payload) &#123; // 根据约定对事件名称进行处理，例如 change --> onChange const eventName = `on$&#123;event[0].toUpperCase()&#125;$&#123;event.slice(1)&#125;`; // 根据处理后的事件名称去 props 中寻找对应的事件处理函数 const handler = instance.props[eventName]; if (handler) &#123; // 调用事件处理函数并传递参数 handler(...payload); &#125; else &#123; console.error('事件不存在'); &#125; &#125; 这里的 emit 函数会将事件名称转换为以 “on” 开头并使用驼峰命名的形式，例如 change 转换为 onChange。然后，它会在 instance.props 中查找对应的事件处理函数并执行。 需要注意的是，事件类型的 props 在 instance.props 中是找不到的，因此它们会存储在 attrs 中。为了解决这个问题，在解析 props 数据时，需要对事件类型的 props 做特殊处理，确保它们被正确添加到 props 中，而不是 attrs。这样，emit 函数就能够在 instance.props 中正确地找到对应的事件处理函数。","link":"/2023/12/08/vue-component-2/"},{"title":"vue-过期的副作用函数","text":"引言当我们讨论竞态问题时，通常指的是在多进程或多线程编程中出现的一种并发问题。然而，在前端开发中，我们可能较少直接面对多线程编程，但我们经常会遇到与竞态问题相似的情境。一个常见的例子是在异步编程中，特别是在处理异步事件、回调函数或者Promise时。 例如，考虑以下的异步代码： let data; function fetchData() &#123; setTimeout(() => &#123; data = 'Fetched data'; &#125;, 1000); &#125; fetchData(); console.log(data); // 输出 undefined 在这个例子中，fetchData 函数是异步的，它在1秒后将数据赋给 data 变量。但是，由于 JavaScript 是单线程的，fetchData 函数会在主线程的事件队列中等待1秒，而在这1秒内，console.log(data) 语句会立即执行，此时 data 的值为 undefined，因为 fetchData 函数还未完成执行。 在异步编程中，由于代码的非阻塞性质，会出现类似的竞态条件问题。在处理异步操作时，我们需要小心确保数据的一致性和正确性，避免在异步操作完成前就去访问或修改相关数据。 竞态问题与响应式那么竞态问题跟我们响应式有什么联系呢？ 举个例子： let finalData watch(obj, async () => &#123; // 发送并等待网络请求 const res = await fetch('/path/to/request') // 将请求结果赋值给 data finalData = res &#125;) 在这段代码中，我们使用 watch 观测 obj 对象的变化，每次 obj对象发生变化都会发送网络请求，例如请求接口数据，等数据请求成功之后，将结果赋值给 finalData 变量。观察上面的代码，乍一看似乎没什么问题。但仔细思考会发现这段代码会发生竞态问题。假设我们第一次修改 obj 对象的某个字段值，这会导致回调函数执行，同时发送了第一次请求 A。随着时间的推移，在请求 A 的结果返回之前，我们对 obj 对象的某个字段值进行了第二次修改，这会导致发送第二次请求 B。此时请求 A 和请求 B 都在进行中，那么哪一个请求会先返回结果呢？我们不确定，如果请求B 先于请求 A 返回结果，就会导致最终 finalData 中存储的是 A 请求的结果 但由于请求 B 是后发送的，因此我们认为请求 B 返回的数据才是“最新”的，而请求 A 则应该被视为“过期”的，所以我们希望变量finalData 存储的值应该是由请求 B 返回的结果，而非请求 A 返回的结果。 实际上，我们可以对这个问题做进一步总结。请求 A 是副作用函数第一次执行所产生的副作用，请求 B 是副作用函数第二次执行所产生的副作用。由于请求 B 后发生，所以请求 B 的结果应该被视为“最新”的，而请求 A 已经“过期”了，其产生的结果应被视为无效。通过这种方式，就可以避免竞态问题导致的错误结果。归根结底，我们需要的是一个让副作用过期的手段。为了让问题更加清晰，我们先拿 Vue.js 中的 watch 函数来复现场景，看看 Vue.js是如何帮助开发者解决这个问题的，然后尝试实现这个功能。 watch(obj, async (newValue, oldValue, onInvalidate) => &#123; // 定义一个标志，代表当前副作用函数是否过期，默认为 false，代表没有过期 let expired = false; // 调用 onInvalidate() 函数注册一个过期回调 onInvalidate(() => &#123; // 当过期时，将 expired 设置为 true expired = true; &#125;); // 发送网络请求 const res = await fetch('/path/to/request'); // 只有当该副作用函数的执行没有过期时，才会执行后续操作。 if (!expired) &#123; finalData = res; // 后续操作... &#125; &#125;); 如上面的代码所示，在发送请求之前，我们定义了 expired 标志变量，用来标识当前副作用函数的执行是否过期；接着调用onInvalidate 函数注册了一个过期回调，当该副作用函数的执行过期时将 expired 标志变量设置为 true；最后只有当没有过期时才采用请求结果，这样就可以有效地避免上述问题了。","link":"/2023/11/01/vue-expired-side-effects/"},{"title":"嵌套的 effect 与 effect 栈","text":"引言effect 副作用函数是可以发生嵌套的，至于为什么要设计成这样呢 嵌套的 effecteffect(function effectFn1() &#123; effect(function effectFn2() &#123; /* ... */ &#125;) /* ... */ &#125;) 在上面这段代码中，effectFn1 内部嵌套了 effectFn2，effectFn1 的执行会导致 effectFn2 的执行。那么，什么场景下会出现嵌套的 effect 呢？拿 Vue.js 来说，实际上 Vue.js 的渲染函数就是在一个 effect 中执行的. 当组件发生嵌套时，例如 Foo 组件渲染了 Bar 组件： // Bar 组件 const Bar = &#123; render() &#123;/* ... */ &#125;, &#125; // Foo 组件渲染了 Bar 组件 const Foo = &#123; render() &#123; return &lt;Bar /> &#125;// jsx 语法 &#125; 此时就发生了 effect 嵌套，它相当于： effect(() => &#123; Foo.render() // 嵌套 effect(() => &#123; Bar.render()&#125; )&#125; ) effect函数可以嵌套使用，也就是说，一个effect函数内部可以包含另一个effect函数。当外部effect函数依赖于内部effect函数创建的响应式数据时，内部effect函数会被自动追踪，确保外部effect函数在内部effect函数发生变化时得以执行。 这种嵌套的effect函数用于创建依赖关系链，确保当某个响应式数据变化时，所有依赖于它的effect函数都能够被触发执行，从而保持应用的响应性。 而”effect 栈”，在Vue 3的内部实现中，Vue使用了一个effect栈来追踪当前正在执行的effect函数，这个栈的作用类似于函数调用栈，用于管理effect函数的执行顺序和依赖关系。 现在有一个不使用栈结构的嵌套的effect函数的例子，但是他并不能实现嵌套的功能。假设我们有两个响应式数据count1和count2，其中count2的值依赖于count1的值。我们可以使用嵌套的effect函数来实现这种依赖关系。 // 原始数据 const data = &#123; foo: true, bar: true &#125;; // 代理对象 const obj = new Proxy(data, &#123; get(target, key) &#123; console.log(`读取属性: $&#123;key&#125;`); return target[key]; &#125; &#125;); // 全局变量 let temp1, temp2; // effectFn1 嵌套了 effectFn2 effect(function effectFn1() &#123; console.log('effectFn1 执行'); effect(function effectFn2() &#123; console.log('effectFn2 执行'); // 在 effectFn2 中读取 obj.bar 属性 temp2 = obj.bar; &#125;); // 在 effectFn1 中读取 obj.foo 属性 temp1 = obj.foo; &#125;); effectFn1是外部的effect函数，它依赖于obj.foo的值，并且在内部包含了一个innerEffect，内部的effect函数依赖于obj.bar的值。当我们修改obj.foo时，我们希望外部的effect函数被触发执行，并且输出obj.foo的值，然后触发内部的依赖函数。当我们修改obj.bar时，内部的effect函数被触发执行，并且输出obj.bar的值。 我们用全局变量 activeEffect 来存储通过 effect 函数注册的副作用函数，这意味着同一时刻 activeEffect 所存储的副作用函数只能有一个。 // 用一个全局变量存储当前激活的 effect 函数 let activeEffect; function effect(fn) &#123; // 定义副作用函数 const effectFn = () => &#123; // 调用 cleanup 函数，具体实现需要根据需求补充 cleanup(effectFn); // 将副作用函数赋值给 activeEffect activeEffect = effectFn; // 执行副作用函数 fn(); // 将当前副作用函数的依赖集合存储在 effectFn.deps 中（需要根据实际逻辑补充） effectFn.deps = []; // 这里需要根据实际逻辑设置依赖集合 &#125;; // 执行副作用函数 effectFn(); &#125; 但其实只使用一个变量储存而不使用栈结构，当副作用函数发生嵌套时，内层副作用函数的执行会覆盖 activeEffect 的值，并且永远不会恢复到原来的值。这时如果再有响应式数据进行依赖收集，即使这个响应式数据是在外层副作用函数中读取的，它们收集到的副作用函数也都会是内层副作用函数，也就是说我在读取obj.foo的时候，activeEffect还只是innerEffect的值，并且只触发了innerEffect的效果。 为了解决这个问题，我们需要一个副作用函数栈 effectStack，在副作用函数执行时，将当前副作用函数压入栈中，待副作用函数执行完毕后将其从栈中弹出，并始终让 activeEffect 指向栈顶的副作用函数。这样就能做到一个响应式数据只会收集直接读取其值的副作用函数，而不会出现互相影响的情况： // 用一个全局变量存储当前激活的 effect 函数 let activeEffect; // effect 栈 const effectStack = []; function effect(fn) &#123; const effectFn = () => &#123; cleanup(effectFn); // 调用 cleanup 函数，具体实现需要根据需求补充 activeEffect = effectFn; // 将当前副作用函数压入栈中 effectStack.push(effectFn); fn(); // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把 activeEffect 还原为之前的值 effectStack.pop(); activeEffect = effectStack[effectStack.length - 1]; &#125;; // 初始化副作用函数的依赖集合 effectFn.deps = []; // 执行副作用函数 effectFn(); &#125;","link":"/2023/10/31/vue-effect/"},{"title":"Vue.js 响应式系统的作用与实现","text":"引言响应式这一个概念应该不难理解，就是js在对某一个对象或者某一个值进行操作时，我们希望通过实现一个响应式系统达到触发某些事件，也就是对操作的相应。 响应式数据与副作用函数副作用函数指的是会产生副作用的函数，如下面的代码所示： function effect() &#123; document.body.innerText = 'hello vue3' &#125; 当 effect 函数执行时，它会设置 body 的文本内容，但除了effect 函数之外的任何函数都可以读取或设置 body 的文本内容。也就是说，effect 函数的执行会直接或间接影响其他函数的执行，这时我们说 effect 函数产生了副作用。 其实副作用函数并不少见，我们前面在讨论webpack的 tree shaking 话题里面涉及到的是否进行数据流处理对 tree shaking 的效果是不可忽略的。这边不再赘述。 副作用很容易产生，例如一个函数修改了全局变量，这其实也是一个副作用，如下面的代码所示： // 全局变量 let val = 1 function effect() &#123; val = 2 // 修改全局变量，产生副作用 &#125; 理解了什么是副作用函数，再来说说什么是响应式数据。假设在一个副作用函数中读取了某个对象的属性： const obj = &#123; text: 'hello world' &#125; function effect() &#123; // effect 函数的执行会读取 obj.text document.body.innerText = obj.text &#125; 副作用函数 effect 会设置 body 元素的 innerText 属性，其值为 obj.text，当 obj.text 的值发生变化时，我们希望副作用函数 effect 会重新执行。 那这样我们的思路就变成了：通过一些手段，在读取 obj.text 值的时候可以将effect函数储存进一个bucket里面，而在设置obj.text 值的时候可以在bucket里面把effect拿出来执行。 响应式数据的基本实现如何才能让 obj 变成响应式数据呢？通过观察我们能发现： 当副作用函数 effect 执行时，会触发字段 obj.text 的读取操作； 当修改 obj.text 的值时，会触发字段 obj.text 的设置操作。 如何拦截一个对象属性的读取和设置操作。 在 ES2015 之前，只能通过 Object.defineProperty 函数实现，这也是 Vue.js 2 所采用的方式。在 ES2015+ 中，我们可以使用代理对象 Proxy 来实现，这也是 Vue.js 3 所采用的方式。 function createReactiveObject(target, proxyMap, baseHandlers) &#123; // 核心就是 proxy // 目的是可以侦听到用户 get 或者 set 的动作 const existingProxy = proxyMap.get(target); if (existingProxy) &#123; return existingProxy; &#125; const proxy = new Proxy(target, baseHandlers); // 把创建好的 proxy 给存起来， proxyMap.set(target, proxy); return proxy; &#125; 这样我们就基于 proxy 创建了一个用于存储副作用函数，并且我们使用了一个proxyMap，这是一个可以把各类型的proxy储存起来的容器。我们分别设置了 get 和 set 拦截函数，用于拦截读取和设置操作。 设计一个完善的响应系统从上面的示例不难看出，一个响应系统的工作流程如下： 当读取操作发生时，将副作用函数收集到“桶”中； 当设置操作发生时，从“桶”中取出副作用函数并执行。 下面通过一个简单的响应式系统实现来讲解原理： 我们知道proxy对象是可以传入一个具有getter和setter的对象进行get或set操作时处理的函数，因此我们可以创建一个baseHandlers，进行getter和setter的管理。 //baseHandlers function createGetter(isReadonly = false, shallow = false) &#123; return function get(target, key, receiver) &#123; //Reflect.get方法允许你从一个对象中取属性值。就如同属性访问器语法，但却是通过函数调用来实现 const res = Reflect.get(target, key, receiver); if (!isReadonly) &#123; // 在触发 get 的时候进行依赖收集 track(target, \"get\", key); &#125; return res; &#125;; &#125; function createSetter() &#123; return function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); // 在触发 set 的时候进行触发依赖 trigger(target, \"set\", key); return result; &#125;; &#125; 我们还需要在副作用函数与被操作的目标字段之间建立明确的联系。例如当读取属性时，无论读取的是哪一个属性，其实都一样，都会把副作用函数收集到“桶”里；当设置属性时，无论设置的是哪一个属性，也都会把“桶”里的副作用函数取出并执行。副作用函数与被操作的字段之间没有明确的联系。解决方法很简单，只需要在副作用函数与被操作的字段之间建立联系即可，这就需要我们重新设计“桶”的数据结构，而不能简单地使用一个Set 类型的数据作为“桶”了。 我们通过WeakMap来实现刚才上面我们说的储存effect的bucket。不了解WeakMap类的特性的可以看下WeakMap 对象是一组键&#x2F;值对的集合 WeakMap 的键是原始对象 target，WeakMap 的值是一个Map 实例，而 Map 的键是原始对象 target 的 key，Map 的值是一个由副作用函数组成的 Set。 //Map存放不同类型的代理 export const reactiveMap = new WeakMap(); export const readonlyMap = new WeakMap(); export const shallowReadonlyMap = new WeakMap(); 定义好了上面的几种bucket，我们开始实现响应式系统最核心的部分，也就是proxy的实现： function createReactiveObject(target, proxyMap, baseHandlers) &#123; // 核心就是 proxy // 目的是可以侦听到用户 get 或者 set 的动作 const existingProxy = proxyMap.get(target); if (existingProxy) &#123; return existingProxy; &#125; const proxy = new Proxy(target, baseHandlers); // 把创建好的 proxy 给存起来， proxyMap.set(target, proxy); return proxy; &#125; 对于前面的trick和trigger： export function track(target, type, key) &#123; if (!isTracking()) &#123; return; &#125; console.log(`触发 track -> target: $&#123;target&#125; type:$&#123;type&#125; key:$&#123;key&#125;`); // 1. 先基于 target 找到对应的 dep // 如果是第一次的话，那么就需要初始化 let depsMap = targetMap.get(target); if (!depsMap) &#123; // 初始化 depsMap 的逻辑 depsMap = new Map(); targetMap.set(target, depsMap); &#125; let dep = depsMap.get(key); if (!dep) &#123; dep = createDep(); depsMap.set(key, dep); &#125; trackEffects(dep); &#125; export function trigger(target, type, key) &#123; // 1. 先收集所有的 dep 放到 deps 里面， // 后面会统一处理 let deps: Array&lt;any> = []; const depsMap = targetMap.get(target); if (!depsMap) return; // 暂时只实现了 GET 类型 // get 类型只需要取出来就可以 const dep = depsMap.get(key); // 最后收集到 deps 内 deps.push(dep); const effects: Array&lt;any> = []; deps.forEach((dep) => &#123; // 这里解构 dep 得到的是 dep 内部存储的 effect effects.push(...dep); &#125;); // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect // 这里的目前应该是为了 triggerEffects 这个函数的复用 triggerEffects(createDep(effects)); &#125;","link":"/2023/10/30/vue-reactive-1/"},{"title":"Vue-浅响应与深响应","text":"前言介绍 reactive 与 shallowReactive 的区别，即深响应和浅响应的区别。 浅响应式与深相应式const obj = reactive(&#123; foo: &#123; bar: 1 &#125; &#125;) effect(() =>&#123; console.log(obj.foo.bar) &#125;) // 修改 obj.foo.bar 的值，并不能触发响应 obj.foo.bar = 2 首先，创建 obj 代理对象，该对象的 foo 属性值也是一个对象，即 { bar: 1} 。接着，在副作用函数内访问 obj.foo.bar 的值。但是我们发现，后续对 obj.foo.bar 的修改不能触发副作用函数重新执行，这是为什么呢？来看一下现在的实现： function reactive(obj) &#123; return new Proxy(obj ,&#123; get(target, key, receiver) &#123; if (key === 'raw') return target; track(target, key); // 当读取属性值时，直接返回结果 return Reflect.get(target, key, receiver) &#125; // 省略其他拦截函数 &#125;) &#125; 由上面这段代码可知，当我们读取 obj.foo.bar 时，首先要读取 obj.foo 的值。这里我们直接使用 Reflect.get 函数返回obj.foo 的结果。由于通过 Reflect.get 得到 obj.foo 的结果是一个普通对象，即 { bar: 1} ，它并不是一个响应式对象，所以在副作用函数中访问 obj.foo.bar 时，是不能建立响应联系的。要解决这个问题，我们需要对 Reflect.get 返回的结果做一层包装: function reactive(obj) &#123; return new Proxy(obj, &#123; get(target, key, receiver) &#123; const result = Reflect.get(target, key, receiver); // If the result is an object, make it reactive if (typeof result === 'object') &#123; return reactive(result); &#125; return result; &#125;, // Other traps... &#125;); &#125; 这段代码定义了一个名为reactive的函数，该函数接收一个对象作为参数，并返回该对象的代理。这个代理使用了get陷阱函数，当我们尝试获取对象的某个属性时，这个函数就会被触发。 在get陷阱函数中，我们首先使用Reflect.get方法获取目标对象的属性值。Reflect.get方法接收三个参数：目标对象、属性名和接收器对象。在这里，接收器对象就是代理对象本身。 然后，我们检查获取的结果是否为对象。如果是对象，我们就对其进行响应式处理，即再次调用reactive函数。这样做的目的是确保嵌套的对象也具有响应式特性，也就是说，当我们修改这些嵌套对象的属性时，也能触发响应式系统。 最后，如果获取的结果不是对象，我们就直接返回结果。 浅响应式然而，并非所有情况下我们都希望深响应，这就催生了shallowReactive，即浅响应。所谓浅响应，指的是只有对象的第一层属性是响应的，例如： 例如，我们有一个对象，它的属性值也是一个对象： let obj = &#123; innerObj: &#123; key: 'value' &#125; &#125; 如果我们对obj进行深响应处理： let reactiveObj = reactive(obj); 那么，无论我们修改obj的属性，还是修改innerObj的属性，都会触发响应式系统： reactiveObj.innerObj.key = 'new value'; // 触发响应式系统 但是，如果我们只想要obj的第一层属性是响应的，也就是说，只有当我们修改obj的属性时才触发响应式系统，而修改innerObj的属性则不触发，那么我们就需要使用shallowReactive函数： let shallowReactiveObj = shallowReactive(obj); 这样，只有当我们修改obj的属性时，才会触发响应式系统： shallowReactiveObj.innerObj = &#123;&#125;; // 触发响应式系统 shallowReactiveObj.innerObj.key = 'new value'; // 不触发响应式系统 Vuejs里reactive和shallowReactive在Vue.js中，reactive和shallowReactive函数都用于创建响应式对象，这一小节来讨论下他们的不同。 reactive函数创建的是深度响应式对象。这意味着不仅对象本身，而且它内部的所有嵌套对象都会变成响应式的。无论是修改对象的属性，还是修改其嵌套对象的属性，都会触发响应式系统。 而shallowReactive函数创建的是浅层响应式对象。这意味着只有对象的顶层属性是响应式的。如果对象包含嵌套对象，那么修改这些嵌套对象的属性不会触发响应式系统。 let obj = &#123; innerObj: &#123; key: 'value' &#125; &#125; let reactiveObj = Vue.reactive(obj); reactiveObj.innerObj.key = 'new value'; // 这将触发响应式系统 let shallowReactiveObj = Vue.shallowReactive(obj); shallowReactiveObj.innerObj.key = 'new value'; // 这将不会触发响应式系统 只读和浅只读讨论完响应式和浅响应式，我们在来说下只读和浅只读： Vue.js还提供了readonly和shallowReadonly函数，它们用于创建只读的响应式对象。 readonly函数创建的是深度只读的响应式对象。这意味着不仅对象本身是只读的，而且它内部的所有嵌套对象也都是只读的。任何尝试修改对象或其嵌套对象的属性的操作都会失败。 shallowReadonly函数创建的是浅层只读的响应式对象。这意味着只有对象的顶层属性是只读的。如果对象包含嵌套对象，那么这些嵌套对象的属性是可以修改的。 let obj = &#123; innerObj: &#123; key: &#39;value&#39; &#125; &#125; let readonlyObj = Vue.readonly(obj); readonlyObj.innerObj.key = &#39;new value&#39;; // 这将失败，因为对象是只读的 let shallowReadonlyObj = Vue.shallowReadonly(obj); shallowReadonlyObj.innerObj.key = &#39;new value&#39;; // 这将成功，因为只有顶层属性是只读的","link":"/2023/11/01/vue-reactive-shallowReactive/"},{"title":"vue-renderer渲染器的原理","text":"前言在 Vue.js 中，很多功能依赖渲染器来实现，例如 Transition组件、Teleport 组件、Suspense 组件，以及 template ref 和自定义指令等。 另外，渲染器也是框架性能的核心，渲染器的实现直接影响框架的性能。Vue.js 3 的渲染器不仅仅包含传统的 Diff 算法，它还独创了快捷路径的更新方式，能够充分利用编译器提供的信息，大大提升了更新性能。 在Vue.js中，渲染器（renderer）是负责执行渲染任务的组件。在浏览器平台上，它将虚拟DOM渲染为真实DOM元素。渲染器不仅可以渲染真实DOM元素，还是框架跨平台能力的关键。在设计渲染器时，需要考虑其可自定义的能力。 渲染器的基本概念及其含义在实现一个最基本的渲染器之前，我们要先了解几个基本的概念： 在Vue.js中，渲染器（renderer）是用来执行渲染任务的组件。在浏览器平台上，它将虚拟DOM渲染为真实DOM元素。以下是渲染器的基本概念及其含义： 渲染器（Renderer）渲染器是负责将虚拟DOM（或虚拟节点）渲染为特定平台上的真实元素的组件。在浏览器平台上，渲染器会将虚拟DOM渲染为真实的DOM元素。 虚拟DOM（vnode）虚拟DOM（也称为虚拟节点，简写为vnode）是一个树型结构，类似于真实DOM，由各种节点组成。渲染器的任务是将虚拟DOM渲染为真实的DOM元素。 挂载（Mounting）挂载是指将虚拟DOM渲染为真实DOM元素并将其添加到指定的挂载点上。在Vue.js中，组件的mounted钩子函数就是在挂载完成时触发，此时可以访问到真实DOM元素。 容器（Container）容器是指用来指定挂载位置的DOM元素。渲染器会将虚拟DOM渲染为真实DOM元素并添加到指定的容器内。在渲染器的render函数中，通常会传入一个容器参数，表示将虚拟DOM挂载到哪个DOM元素上。 渲染器的创建与使用渲染器的创建通常使用createRenderer函数，该函数返回一个包含渲染和激活（hydrate）函数的对象。激活函数在同构渲染时使用，将虚拟DOM激活为已有的真实DOM元素。以下是渲染器的创建和使用示例： function createRenderer() &#123; function render(vnode, container) &#123; // 渲染逻辑 &#125; function hydrate(vnode, container) &#123; // 激活逻辑 &#125; return &#123; render, hydrate &#125;; &#125; const &#123; render, hydrate &#125; = createRenderer(); // 首次渲染 render(vnode, document.querySelector('#app')); // 同构渲染 hydrate(vnode, document.querySelector('#app')); 上面的代码片中通过createRenderer函数创建了一个渲染器对象，包含了render和hydrate函数。render函数用于将虚拟DOM渲染为真实DOM元素，而hydrate函数用于将虚拟DOM激活为已有的真实DOM元素。 好的，现在我们已经对渲染器有了一个比较基础的认识，下面来一步步深入了解一下： 渲染器的实现可以通过如下的函数来表示，其中domString是待渲染的HTML字符串，container是挂载点的DOM元素： function renderer(domString, container) &#123; container.innerHTML = domString; &#125; 使用渲染器的示例： renderer('&lt;h1>Hello&lt;/h1>', document.getElementById('app')); 上述代码将&lt;h1&gt;Hello&lt;/h1&gt;插入到id为app的DOM元素内。渲染器不仅可以渲染静态字符串，还可以渲染动态拼接的HTML内容： let count = 1; renderer(`&lt;h1>$&#123;count&#125;&lt;/h1>`, document.getElementById('app')); 如果count是一个响应式数据，那么可以使用响应系统来自动化整个渲染过程。首先，定义一个响应式数据count，然后在副作用函数内调用渲染器函数进行渲染： const count = ref(1); effect(() => &#123; renderer(`&lt;h1>$&#123;count.value&#125;&lt;/h1>`, document.getElementById('app')); &#125;); count.value++; 在上述代码中，count是一个ref响应式数据。当修改count.value的值时，副作用函数会重新执行，完成重新渲染，最终渲染到页面的内容是&lt;h1&gt;2&lt;/h1&gt;。 这里使用了Vue 3提供的@vue/reactivity包中的响应式API，通过&lt;script&gt;标签引入： &lt;script src=\"https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js\">&lt;/script> 上述代码中给出了render函数的基本实现，下面将其执行流程进行详细分析。假设我们连续三次调用renderer.render函数来执行渲染： const renderer = createRenderer(); // 首次渲染 renderer.render(vnode1, document.querySelector('#app')); // 第二次渲染 renderer.render(vnode2, document.querySelector('#app')); // 第三次渲染 renderer.render(null, document.querySelector('#app')); 在首次渲染时，渲染器将vnode1渲染为真实DOM，并将vnode1存储到容器元素的container.vnode属性中，作为旧vnode。 在第二次渲染时，旧的vnode存在（即container.vnode中有值），此时渲染器将vnode2作为新vnode，将新旧vnode一同传递给patch函数进行打补丁。 在第三次渲染时，新的vnode的值为null，即不渲染任何内容。但是此时容器中渲染的是vnode2所描述的内容，所以渲染器需要清空容器。在上面的代码中，使用container.innerHTML = &#39;&#39;来清空容器。需要注意的是，这种清空容器的方式并不是最佳实践，但在这里仅用于演示目的。 关于patch函数，它是整个渲染器的核心入口，接收三个参数：旧vnode n1、新vnode n2和容器 container。在首次渲染时，旧vnode n1是undefined，表示挂载动作。patch函数不仅用于打补丁，也可以执行挂载动作。 自定义渲染器自定义渲染器的实现是通过抽象核心渲染逻辑，使其不再依赖于特定平台的API。以下是自定义渲染器的实现示例代码，使用配置项来实现平台无关的渲染： // 创建渲染器函数，接收配置项作为参数 function createRenderer(options) &#123; // 从配置项中获取操作 DOM 的 API const &#123; createElement, insert, setElementText &#125; = options; // 定义挂载元素的函数 function mountElement(vnode, container) &#123; // 调用 createElement 函数创建元素 const el = createElement(vnode.type); // 如果子节点是字符串，调用 setElementText 设置文本内容 if (typeof vnode.children === 'string') &#123; setElementText(el, vnode.children); &#125; // 调用 insert 函数将元素插入到容器内 insert(el, container); &#125; // 定义打补丁函数 function patch(n1, n2, container) &#123; // 实现打补丁逻辑，这部分内容在示例中省略 &#125; // 定义渲染函数，接收虚拟节点和容器作为参数 function render(vnode, container) &#123; // 如果旧虚拟节点存在，执行打补丁逻辑，否则执行挂载逻辑 if (container.vnode) &#123; patch(container.vnode, vnode, container); &#125; else &#123; mountElement(vnode, container); &#125; // 将当前虚拟节点存储到容器的 vnode 属性中 container.vnode = vnode; &#125; // 返回渲染函数 return render; &#125; // 创建自定义渲染器的配置项 const customRendererOptions = &#123; // 用于创建元素 createElement(tag) &#123; console.log(`创建元素 $&#123;tag&#125;`); // 在实际应用中，可以返回一个自定义的对象，模拟DOM元素 return &#123; type: tag &#125;; &#125;, // 用于设置元素的文本节点 setElementText(el, text) &#123; console.log(`设置 $&#123;JSON.stringify(el)&#125; 的文本内容：$&#123;text&#125;`); // 在实际应用中，设置对象的文本内容 el.textContent = text; &#125;, // 用于在给定的 parent 下添加指定元素 insert(el, parent, anchor = null) &#123; console.log(`将 $&#123;JSON.stringify(el)&#125; 添加到 $&#123;JSON.stringify(parent)&#125; 下`); // 在实际应用中，将 el 插入到 parent 内 parent.children = el; &#125;, &#125;; // 使用自定义渲染器的配置项创建渲染函数 const customRenderer = createRenderer(customRendererOptions); // 创建一个虚拟节点描述 &lt;h1>hello&lt;/h1> const vnode = &#123; type: 'h1', children: 'hello', &#125;; // 使用一个对象模拟挂载点 const container = &#123; type: 'root' &#125;; // 使用自定义渲染器渲染虚拟节点到挂载点 customRenderer(vnode, container); 上面的代码片我们通过createRenderer函数创建了一个自定义渲染器，并通过配置项(customRendererOptions)传递操作DOM的API。渲染器在执行时，根据配置项中的API来完成相应的操作。通过这种方式，我们实现了一个通用的、不依赖于特定平台的渲染器。在实际应用中，可以根据不同的平台需求，通过配置不同的API，实现跨平台的渲染能力。","link":"/2023/11/05/vue-renderer-1/"},{"title":"vue-render挂载与更新","text":"前言Vue.js模板功能强大，几乎可以满足我们在应用程序中所需的一切。但是，有一些场景下，比如基于输入或插槽值创建动态组件，render函数可以更好地满足这些用例。 那些来自React世界的开发者可能对render函数非常熟悉。通常在JSX中使用它们来构建React组件。虽然Vue渲染函数也可以用JSX编写，但我们将继续使用原始JS，有助于我们可以更轻松地了解Vue组件系统的基础。。 每个Vue组件都实现了一个render函数。大多数时候，该函数将由Vue编译器创建。当我们在组件上指定模板时，该模板的内容将由Vue编译器处理，编译器最终将返回render函数。渲染函数本质上返回一个虚拟DOM节点，该节点将被Vue在浏览器DOM中渲染。 现在又引出了虚拟DOM的概念， 虚拟DOM到底是什么？ 虚拟文档对象模型（或”DOM”）允许Vue在更新浏览器之前在其内存中渲染组件。 这使一切变得更快，同时也避免了DOM重新渲染的高昂成本。因为每个DOM节点对象包含很多属性和方法，因此使用虚拟DOM预先在内存进行操作，可以省去很多浏览器直接创建DOM节点对象的开销。 Vue更新浏览器DOM时，会将更新的虚拟DOM与上一个虚拟DOM进行比较，并仅使用已修改的部分更新实际DOM。这意味着更少的元素更改，从而提高了性能。Render函数返回虚拟DOM节点，在Vue生态系统中通常称为VNode，该接口是允许Vue在浏览器DOM中写入这些对象的接口。它们包含使用Vue所需的所有信息。 挂载子节点和元素的属性当vnode.children的值是字符串类型时，会把它设置为元素的文本内容。一个元素除了具有文本子节点外，还可以包含其他元素子节点，并且子节点可以是很多个。为了描述元素的子节点，我们需要将vnode.children定义为数组： const vnode = &#123; type: 'div', children: [ &#123; type: 'p', children: 'hello' &#125; ] &#125;; 上面这段代码描述的是“一个div标签具有一个子节点，且子节点是p标签”。可以看到，vnode.children是一个数组，它的每一个元素都是一个独立的虚拟节点对象。这样就形成了树型结构，即虚拟DOM树。 为了完成子节点的渲染，我们需要修改mountElement函数，如下面的代码所示： function mountElement(vnode, container) &#123; const el = createElement(vnode.type); if (typeof vnode.children === 'string') &#123; setElementText(el, vnode.children); &#125; else if (Array.isArray(vnode.children)) &#123; // 如果`children`是数组，则遍历每一个子节点，并调用`patch`函数挂载它们 vnode.children.forEach(child => &#123; patch(null, child, el); &#125;); &#125; insert(el, container); &#125; 在上面这段代码中，我们增加了新的判断分支。使用Array.isArray函数判断vnode.children是否是数组，如果是数组，则循环遍历它，并调用patch函数挂载数组中的虚拟节点。在挂载子节点时，需要注意以下两点： 传递给patch函数的第一个参数是null。因为是挂载阶段，没有旧vnode，所以只需要传递null即可。这样，当patch函数执行时，就会递归地调用mountElement函数完成挂载。 传递给patch函数的第三个参数是挂载点。由于我们正在挂载的子元素是div标签的子节点，所以需要把刚刚创建的div元素作为挂载点，这样才能保证这些子节点挂载到正确位置。 完成了子节点的挂载后，我们再来看看如何用vnode描述一个标签的属性，以及如何渲染这些属性。我们知道，HTML标签有很多属性，其中有些属性是通用的，例如id、class等，而有些属性是特定元素才有的，例如form元素的action属性。实际上，渲染一个元素的属性比想象中要复杂，不过我们仍然秉承一切从简的原则，先来看看最基本的属性处理。 为了描述元素的属性，我们需要为虚拟DOM定义新的vnode.props字段，如下面的代码所示： const vnode = &#123; type: 'div', props: &#123; id: 'foo' &#125;, children: [ &#123; type: 'p', children: 'hello' &#125; ] &#125;; vnode.props是一个对象，它的键代表元素的属性名称，它的值代表对应属性的值。这样，我们就可以通过遍历props对象的方式，把这些属性渲染到对应的元素上，如下面的代码所示： function mountElement(vnode, container) &#123; const el = createElement(vnode.type); // 省略children的处理 // 如果`vnode.props`存在才处理它 if (vnode.props) &#123; // 遍历`vnode.props` for (const key in vnode.props) &#123; // 调用`setAttribute`将属性设置到元素上 el.setAttribute(key, vnode.props[key]); &#125; &#125; insert(el, container); &#125; 在这段代码中，我们首先检查了vnode.props字段是否存在，如果存在则遍历它，并调用setAttribute函数将属性设置到元素上。实际上，除了使用setAttribute函数为元素设置属性之外，还可以通过DOM对象直接设置： function mountElement(vnode, container) &#123; const el = createElement(vnode.type); // 省略children的处理 if (vnode.props) &#123; for (const key in vnode.props) &#123; // 直接设置 el[key] = vnode.props[key]; &#125; &#125; insert(el, container); &#125; 在这段代码中，我们没有选择使用setAttribute函数，而是直接将属性设置在DOM对象上，即el[key] = vnode.props[key]。实际上，无论是使用setAttribute函数，还是直接操作DOM对象，都存在缺陷。如前所述，为元素设置属性比想象中要复杂得多。不过，在讨论具体有哪些缺陷之前，我们有必要先搞清楚两个重要的概念：HTML Attributes和DOM Properties。 当我们处理元素属性时，有两种主要的方式：使用HTML Attributes和DOM Properties。这两者在概念上有些许不同： HTML Attributes: HTML Attributes是在HTML标签中定义的属性，例如id、class、src等。 通过setAttribute方法可以设置HTML Attributes。 HTML Attributes的值始终是字符串。 DOM Properties: DOM Properties是DOM对象上的属性，例如element.id、element.className、element.src等。 直接操作DOM对象可以设置DOM Properties。 DOM Properties的值可以是字符串、数字、布尔值等，具体取决于属性的类型。 HTML Attributes和DOM Properties在处理元素属性时，我们需要明确HTML Attributes和DOM Properties之间的区别。 如果我们使用setAttribute方法设置属性，那么属性会被设置为HTML Attributes。如果我们直接操作DOM对象的属性，属性会被设置为DOM Properties。 现在，我们来讨论一下这两种方式存在的问题： 属性值类型转换问题: 当我们使用setAttribute方法设置属性时，属性的值始终被转换为字符串。这就意味着，如果我们将一个数字或布尔值赋给属性，它们都会被转换为字符串。例如，element.setAttribute(&#39;value&#39;, 42)会将值转换为字符串&#39;42&#39;。 布尔属性问题: HTML中的一些属性是布尔属性，例如checked、disabled等。对于这些属性，如果存在就表示为true，不存在就表示为false。 当我们使用setAttribute方法设置布尔属性时，不论属性值是什么，都会被视为存在。例如，element.setAttribute(&#39;disabled&#39;, &#39;false&#39;)会使元素具有disabled属性，即使值是字符串&#39;false&#39;。 考虑到这些问题，最好的做法是尽量使用DOM Properties而不是HTML Attributes来设置元素的属性。这样可以避免类型转换问题和布尔属性问题，确保属性被正确设置。 首先，HTML Attributes指的是定义在HTML标签上的属性，例如id=&quot;my-input&quot;、type=&quot;text&quot;和value=&quot;foo&quot;。当浏览器解析这段HTML代码后，会创建一个与之相符的DOM元素对象，我们可以通过JavaScript代码来读取该DOM对象： const el = document.querySelector('#my-input'); 现在来说一下DOM Properties。许多HTML Attributes在DOM对象上有与之同名的DOM Properties，例如id=&quot;my-input&quot;对应el.id，type=&quot;text&quot;对应el.type，value=&quot;foo&quot;对应el.value等。但是，DOM Properties与HTML Attributes的名字并不总是一模一样的，例如： &lt;div class=\"foo\">&lt;/div> class=&quot;foo&quot;对应的DOM Properties则是el.className。另外，并不是所有HTML Attributes都有与之对应的DOM Properties，例如： &lt;div aria-valuenow=\"75\">&lt;/div> aria-*类的HTML Attributes就没有与之对应的DOM Properties。 类似地，也不是所有DOM Properties都有与之对应的HTML Attributes，例如可以用el.textContent来设置元素的文本内容，但并没有与之对应的HTML Attributes来完成同样的工作。 HTML Attributes的值与DOM Properties的值之间是有关联的。例如下面的HTML片段： &lt;div id=\"foo\">&lt;/div> 这个片段描述了一个具有id属性的div标签。其中，id=&quot;foo&quot;对应的DOM Properties是el.id，并且值为字符串&#39;foo&#39;。我们把这种HTML Attributes与DOM Properties具有相同名称（即id）的属性看作直接映射。 但并不是所有HTML Attributes与DOM Properties之间都是直接映射的关系，例如： &lt;input value=\"foo\" /> 这是一个具有value属性的input标签。如果用户没有修改文本框的内容，那么通过el.value读取对应的DOM Properties的值就是字符串&#39;foo&#39;。而如果用户修改了文本框的值，那么el.value的值就是当前文本框的值。例如，用户将文本框的内容修改为&#39;bar&#39;，那么： console.log(el.value); // 'bar' 但如果运行下面的代码，会发生“奇怪”的现象： console.log(el.getAttribute('value')); // 仍然是 'foo' console.log(el.value); // 'bar' 可以发现，用户对文本框内容的修改并不会影响el.getAttribute(&#39;value&#39;)的返回值，这个现象蕴含着HTML Attributes所代表的意义。实际上，HTML Attributes的作用是设置与之对应的DOM Properties的初始值。一旦值改变，那么DOM Properties始终存储着当前值，而通过getAttribute函数得到的仍然是初始值。 但我们仍然可以通过el.defaultValue来访问初始值，如下面的代码所示： el.getAttribute('value'); // 仍然是 'foo' el.value; // 'bar' el.defaultValue; // 'foo' 这说明一个HTML Attributes可能关联多个DOM Properties。例如在上例中，value=&quot;foo&quot;与el.value和el.defaultValue都有关联。 虽然我们可以认为HTML Attributes是用来设置与之对应的DOM Properties的初始值的，但有些值是受限制的，就好像浏览器内部做了默认值校验。如果你通过HTML Attributes提供的默认值不合法，那么浏览器会使用内建的合法值作为对应DOM Properties的默认值，例如： &lt;input type=\"foo\" /> 我们知道，为&lt;input/&gt;标签的type属性指定字符串&#39;foo&#39;是不合法的，因此浏览器会矫正这个不合法的值。所以当我们尝试读取el.type时，得到的其实是矫正后的值，即字符串&#39;text&#39;，而非字符串&#39;foo&#39;： console.log(el.type); // 'text' 从上述分析来看，HTML Attributes与DOM Properties之间的关系很复杂，但实际上我们只需要记住一个核心原则：HTML Attributes的作用是设置与之对应的DOM Properties的初始值。 如何正确地设置元素属性在上文中，我们讨论了在Vue.js单文件组件的模板中，HTML Attributes和DOM Properties的设置方式。在普通的HTML文件中，浏览器会自动解析HTML Attributes并设置相应的DOM Properties。然而，在Vue.js的模板中，需要框架手动处理这些属性的设置。 首先，我们以一个禁用的按钮为例，如下所示的HTML代码： &lt;button disabled>Button&lt;/button> 浏览器会自动将这个按钮设置为禁用状态，并将其对应的DOM Properties el.disabled的值设置为true。但是，如果同样的代码出现在Vue.js的模板中，情况就会有所不同。 在Vue.js的模板中，HTML模板会被编译成虚拟节点（vnode），其中props.disabled的值是一个空字符串。如果直接使用setAttribute函数设置属性，会导致意外的效果，即按钮被禁用。例如，以下模板： &lt;button disabled=\"false\">Button&lt;/button> 对应的虚拟节点为： const button = &#123; type: 'button', props: &#123; disabled: false &#125; &#125;; 如果使用setAttribute函数将属性值设置为空字符串，实际上相当于： el.setAttribute('disabled', ''); 而按钮的el.disabled属性是布尔类型的，不关心具体的HTML Attributes的值是什么，只要disabled属性存在，按钮就会被禁用。因此，渲染器不应该总是使用setAttribute函数将vnode.props对象中的属性设置到元素上。 为了解决这个问题，我们可以优先设置元素的DOM Properties，但当值为空字符串时，需要手动将其矫正为true。以下是一个具体的实现示例： function mountElement(vnode, container) &#123; const el = createElement(vnode.type); if (vnode.props) &#123; for (const key in vnode.props) &#123; if (key in el) &#123; const type = typeof el[key]; const value = vnode.props[key]; if (type === 'boolean' &amp;&amp; value === '') &#123; el[key] = true; &#125; else &#123; el[key] = value; &#125; &#125; else &#123; el.setAttribute(key, vnode.props[key]); &#125; &#125; &#125; insert(el, container); &#125; 在上述代码中，我们检查每个vnode.props中的属性，看看是否存在对应的DOM Properties。如果存在，优先设置DOM Properties。同时，对布尔类型的DOM Properties做了值的矫正，即当要设置的值为空字符串时，将其矫正为布尔值true。如果vnode.props中的属性没有对应的DOM Properties，则仍然使用setAttribute函数完成属性的设置。 然而，上述实现仍然存在问题。有些DOM Properties是只读的，例如el.form。为了解决这个问题，我们可以添加一个辅助函数shouldSetAsProps，用于判断是否应该将属性作为DOM Properties设置。如果属性是只读的，或者需要特殊处理，就应该使用setAttribute函数来设置属性。 最后，为了使属性设置操作与平台无关，我们将属性设置相关的操作提取到渲染器选项中。以下是相应的代码示例： const renderer = createRenderer(&#123; createElement(tag) &#123; return document.createElement(tag); &#125;, setElementText(el, text) &#123; el.textContent = text; &#125;, insert(el, parent, anchor = null) &#123; parent.insertBefore(el, anchor); &#125;, patchProps(el, key, prevValue, nextValue) &#123; if (shouldSetAsProps(el, key, nextValue)) &#123; const type = typeof el[key]; if (type === 'boolean' &amp;&amp; nextValue === '') &#123; el[key] = true; &#125; else &#123; el[key] = nextValue; &#125; &#125; else &#123; el.setAttribute(key, nextValue); &#125; &#125; &#125;); 在mountElement函数中，只需要调用patchProps函数，并为其传递相应的参数即可。这样，我们就将属性相关的渲染逻辑从渲染器的核心中抽离出来，使其更加可维护和灵活。","link":"/2023/11/05/vue-renderer-2/"},{"title":"vue-事件渲染的处理","text":"引言本节我们将讨论如何处理事件，包括如何在虚拟节点中描述事件，如何把事件添加到 DOM 元素上，以及如何更新事件。我们先来解决第一个问题，即如何在虚拟节点中描述事件。事件可以视作一种特殊的属性，因此我们可以约定，在 vnode.props 对象中，凡是以字符串 on 开头的属性都视作事件。例如： const vnode = &#123; type: 'p', props: &#123; // 使用 onXxx 描述事件 onClick: () => &#123; alert('clicked'); &#125; &#125;, children: 'text' &#125;; 解决了事件在虚拟节点层面的描述问题后，我们再来看看如何将事件添加到 DOM 元素上。这非常简单，只需要在 patchProps 中调用 addEventListener 函数来绑定事件即可，如下面的代码所示： function patchProps(el, key, prevValue, nextValue) &#123; // 匹配以 on 开头的属性，视其为事件 if (/^on/.test(key)) &#123; // 根据属性名称得到对应的事件名称，例如 onClick ---> click const name = key.slice(2).toLowerCase(); // 移除上一次绑定的事件处理函数 prevValue &amp;&amp; el.removeEventListener(name, prevValue); // 绑定新的事件处理函数 el.addEventListener(name, nextValue); &#125; else if (key === 'class') &#123; // 省略部分代码（处理 class 属性的逻辑） &#125; else if (shouldSetAsProps(el, key, nextValue)) &#123; // 省略部分代码（处理其他属性的逻辑） &#125; else &#123; // 省略部分代码（处理其他属性的逻辑） &#125; &#125; 事实上可以更为优化的事件更新机制，避免多次调用 removeEventListener 和 addEventListener。 function patchProps(el, key, prevValue, nextValue) &#123; if (/^on/.test(key)) &#123; const name = key.slice(2).toLowerCase(); let invoker = el.__vei || (el.__vei = &#123;&#125;); if (nextValue) &#123; if (!invoker[name]) &#123; // 如果没有 invoker，则创建一个伪造的 invoker 函数 invoker[name] = (e) => &#123; invoker[name].value(e); &#125;; &#125; // 将真正的事件处理函数赋值给 invoker 函数的 value 属性 invoker[name].value = nextValue; // 绑定 invoker 函数作为事件处理函数 el.addEventListener(name, invoker[name]); &#125; else if (invoker[name]) &#123; // 如果新的事件处理函数不存在，且之前绑定的 invoker 存在，则移除绑定 el.removeEventListener(name, invoker[name]); invoker[name] = null; &#125; &#125; else if (key === 'class') &#123; // 省略部分代码（处理 class 属性的逻辑） &#125; else if (shouldSetAsProps(el, key, nextValue)) &#123; // 省略部分代码（处理其他属性的逻辑） &#125; else &#123; // 省略部分代码（处理其他属性的逻辑） &#125; &#125; 观察上面的代码，事件绑定主要分为两个步骤。先从 el._vei 中读取对应的 invoker，如果 invoker 不存在，则将伪造的 invoker 作为事件处理函数，并将它缓存到el._vei 属性中。 把真正的事件处理函数赋值给 invoker.value 属性，然后把伪造的 invoker 函数作为事件处理函数绑定到元素上。可以看到，当事件触发时，实际上执行的是伪造的事件处理函数，在其内部间接执行了真正的事件处理函数 invoker.value(e)。 当更新事件时，由于 el._vei 已经存在了，所以我们只需要将invoker.value 的值修改为新的事件处理函数即可。 这样，在更新事件时可以避免一次 removeEventListener 函数的调用，从而提升了性能。实际上，伪造的事件处理函数的作用不止于此，它还能解决事件冒泡与事件更新之间相互影响的问题。但目前的实现仍然存在问题。现在我们将事件处理函数缓存在el._vei 属性中，问题是，在同一时刻只能缓存一个事件处理函数。这意味着，如果一个元素同时绑定了多种事件，将会出现事件覆盖的现象。 const vnode = &#123; type: 'p', props: &#123; // 使用 onXxx 描述事件 onClick: () => &#123; alert('clicked'); &#125;, onContextmenu: () => &#123; alert('contextmenu'); &#125; &#125;, children: 'text' &#125;; // 假设 renderer 是你的渲染器对象 renderer.render(vnode, document.querySelector('#app')); 当渲染器尝试渲染这上面代码中给出的 vnode 时，会先绑定click 事件，然后再绑定 contextmenu 事件。后绑定的contextmenu 事件的处理函数将覆盖先绑定的 click 事件的处理函数。为了解决事件覆盖的问题，我们需要重新设计 el._vei 的数据结构。我们应该将 el._vei 设计为一个对象，它的键是事件名称，它的值则是对应的事件处理函数，这样就不会发生事件覆盖的现象了. 根据你提供的代码片段，这段代码主要是用于处理 DOM 元素的属性更新，其中包括事件的绑定和解绑逻辑。在这个代码中，它使用了一个 el._vei 的对象来缓存事件处理函数。下面是你提供的代码的一些修正： function patchProps(el, key, prevValue, nextValue) &#123; if (/^on/.test(key)) &#123; const invokers = el._vei || (el._vei = &#123;&#125;); const name = key.slice(2).toLowerCase(); let invoker = invokers[name]; if (nextValue) &#123; if (!invoker) &#123; invoker = el._vei[name] = (e) => &#123; if (Array.isArray(invoker.value)) &#123; invoker.value.forEach(fn => fn(e)); &#125; else &#123; invoker.value(e); &#125; &#125;; &#125; invoker.value = nextValue; el.addEventListener(name, invoker); &#125; else if (invoker) &#123; el.removeEventListener(name, invoker); el._vei[name] = null; &#125; &#125; else if (key === 'class') &#123; // 处理 class 属性的逻辑 &#125; else if (shouldSetAsProps(el, key, nextValue)) &#123; // 处理其他属性的逻辑 &#125; else &#123; // 处理其他属性的逻辑 &#125; &#125; 在这段代码中，我们修改了 invoker 函数的实现。当 invoker函数执行时，在调用真正的事件处理函数之前，要先检查invoker.value 的数据结构是否是数组，如果是数组则遍历它，并逐个调用定义在数组中的事件处理函数。","link":"/2023/11/05/vue-renderer-3/"},{"title":"vue-watch-computed原理","text":"引言之前介绍过了 effect 函数，它用来注册副作用函数，同时它也允许指定一些选项参数 options，例如指定 scheduler 调度器来控制副作用函数的执行时机和方式；也介绍了用来追踪和收集依赖的track 函数，以及用来触发副作用函数重新执行的 trigger 函数。实际上，综合这些内容，我们就可以实现 Vue.js 中一个非常重要并且非常有特色的能力——计算属性。 计算属性与lazy属性在Vue.js中，effect函数是用来创建响应式副作用的函数。默认情况下，传递给effect的副作用函数会立即执行。例如，下面的代码中，effect函数会立即执行传递给它的副作用函数： effect(() => &#123; console.log(obj.foo); &#125;); 然而，在某些情况下，我们希望副作用函数在需要的时候才执行，而不是立即执行。一个典型的例子是计算属性。为了实现这种延迟执行的效果，我们可以在options中添加一个lazy属性，并将其设置为true。当lazy为true时，副作用函数不会在初始化时立即执行，而是在需要的时候才执行。修正后的代码如下所示： effect( // 这个函数不会立即执行 () => &#123; console.log(obj.foo); &#125;, // options &#123; lazy: true &#125; ); 具体实现中，我们将副作用函数effectFn作为effect函数的返回值返回。这意味着，当我们调用effect函数时，我们会得到对应的副作用函数，并且可以在需要的时候手动执行它。这种机制赋予了我们更多的控制权，允许我们决定何时触发副作用函数的执行，而不是立即执行它。 这种设计模式特别适用于特定场景，例如计算属性。在计算属性中，我们可能希望在特定时刻触发副作用函数的执行，而不是在初始化时立即执行。通过将副作用函数作为effect函数的返回值，我们能够灵活地控制副作用函数的执行时机，以满足不同场景的需求。 function effect(fn, options = &#123;&#125;) &#123; const effectFn = () => &#123; cleanup(effectFn); activeEffect = effectFn; effectStack.push(effectFn); fn(); effectStack.pop(); activeEffect = effectStack[effectStack.length - 1]; &#125;; // 设置副作用函数的 options 和 deps effectFn.options = options; effectFn.deps = []; // 只有非 lazy 时执行副作用函数 if (!options.lazy) &#123; effectFn(); &#125; // 将副作用函数作为返回值返回 return effectFn; &#125; 在这个代码中，effect函数的第二个参数是一个options对象，其中lazy属性被设置为true。这意味着传递给effect的副作用函数会在需要的时候才执行，例如在计算属性被访问时。这种延迟执行的特性使得effect函数非常适合用于实现计算属性等场景。 在上述代码中，我们通过options参数的lazy属性控制副作用函数的立即执行。如果options.lazy为true，副作用函数将被延迟执行，直到手动触发为止。 现在我们通过计算属性实现了lazy懒加载，那么数据缓存该怎么实现呢。 function computed(getter) &#123; // value 用来缓存上一次计算的值 let value; // dirty 标志，用来标识是否需要重新计算值，为 true 则意味着“脏”，需要计算 let dirty = true; const effectFn = effect(getter, &#123; lazy: true &#125;); const obj = &#123; get value() &#123; // 只有“脏”时才计算值，并将得到的值缓存到 value 中 if (dirty) &#123; value = effectFn(); // 将 dirty 设置为 false，下一次访问直接使用缓存到 value 中的值 dirty = false; &#125; return value; &#125; &#125;; return obj; &#125; 解决了懒计算的问题，只有在真正需要计算value的时候，才会执行effectFn。同时，它还引入了一个dirty标志，用于标识当前的计算是否需要重新进行。如果dirty为true，则重新计算value的值，并将dirty标志设置为false，以便下一次访问时可以直接使用缓存的值。 watch 的实现原理所谓 watch，其本质就是观测一个响应式数据，当数据发生变化时通知并执行相应的回调函数。举个例子： watch(obj, () => &#123; console.log('数据变了') &#125;) // 修改响应数据的值，会导致回调函数执行 obj.foo++ 假设 obj 是一个响应数据，使用 watch 函数观测它，并传递一个回调函数，当修改响应式数据的值时，会触发该回调函数执行。实际上，watch 的实现本质上就是利用了 effect 以及options.scheduler 选项，如以下代码所示： effect(() => &#123; console.log(obj.foo) &#125;, &#123; scheduler() &#123; // 当 obj.foo 的值变化时，会执行 scheduler 调度函数 &#125; &#125;) 在一个副作用函数中访问响应式数据 obj.foo，通过前面的介绍，我们知道这会在副作用函数与响应式数据之间建立联系，当响应式数据变化时，会触发副作用函数重新执行。但有一个例外，即如果副作用函数存在 scheduler 选项，当响应式数据发生变化时，会触发 scheduler 调度函数执行，而非直接触发副作用函数执行。从这个角度来看，其实 scheduler 调度函数就相当于一个回调函数，而watch 的实现就是利用了这个特点。 下面是最简单的 watch 函数的实现： // watch 函数接收两个参数，source 是响应式数据，cb 是回调函数 function watch(source, cb) &#123; effect( // 触发读取操作，从而建立联系 () => source.foo, &#123; scheduler: scheduler(), // 当数据变化时，调用回调函数 cb fn: () => &#123; cb(); &#125;, &#125; ); &#125; 于是一段完整的代码： // 响应式数据对象 const data = &#123; foo: 1 &#125;; // 创建代理对象，用于监听数据变化 const obj = new Proxy(data, &#123; set(target, key, value) &#123; target[key] = value; // 数据变化时触发回调函数 watch(obj, () => &#123; console.log('数据变化了'); &#125;); return true; &#125;, &#125;); // watch 函数接收两个参数，source 是响应式数据，cb 是回调函数 function watch(source, cb) &#123; effect(() => source.foo, &#123; scheduler: scheduler(), fn: () => &#123; cb(); &#125;, &#125;); &#125; // 模拟 effect 函数 function effect(fn, options) &#123; // 在这里执行 effect 相关逻辑 fn(); // 这里假设执行 fn 会触发响应式数据的读取操作 &#125; // 模拟 scheduler 函数 function scheduler() &#123; // 在这里可以添加调度逻辑 // 这里返回一个函数作为 scheduler return function () &#123; // 这里可以添加具体的调度逻辑 // ... &#125;; &#125; // 数据变化 obj.foo++; // 输出: 数据变化了 我们首先定义了一个原始的数据对象data，其中有一个属性foo，初始值为1。接着，我们使用Proxy创建了一个代理对象obj，该代理对象会拦截对data的操作。 当你调用obj.foo++时，会触发Proxy的set拦截器。在set拦截器中，我们首先将属性值设置到目标对象上，然后调用watch函数，并传入obj和一个回调函数。在watch函数中，我们使用了一个假设的effect函数（实际开发中可能是框架提供的响应式函数），这个函数用于监听数据的变化。在watch函数中，我们传入了source.foo的读取操作，以及一个包含scheduler和fn属性的配置对象。scheduler可以用于定义调度逻辑（在示例中为空函数），fn则是一个当数据变化时会被调用的回调函数。 当obj.foo++执行时，set拦截器触发，watch函数被调用。","link":"/2023/10/31/vue-watch-computed/"},{"title":"Vue 2/3 共存开发的思路","text":"前言2023 年 12 ⽉ 31 ⽇后，功能仍然可⽤，但不再提供更新，包括• 安全更新• 浏览器兼容 Evan 宣布 Vue 3 的第一个 RC将于 7 月中旬发布。这篇文章建议库&#x2F;插件作者开始迁移对 Vue 3 的支持。但是由于 API 和行为发生了很大变化，是否有可能使我们的库同时支持 Vue 2 和 3 ？ 通用代码最简单的方法是编写适用于两个版本的通用代码 ，无需任何额外的修改，就像人们对Python 2 和 3所做的那样。简单并不意味着容易。编写此类组件需要避免Vue 3 中新引入的内容 以及Vue 2 中弃用的内容 。换句话说，您不能使用： 合成API .sync .native修饰语 过滤器 3rd 方供应商对象 使用分支核心团队成员对此问题的回复建议使用不同的分支来分隔对每个定位版本的支持。我认为这对于现有和成熟的库来说是一个很好的解决方案，因为它们的代码库通常更稳定，并且版本目标优化可能需要它们具有更好的代码隔离。 这样做的缺点是您需要维护两个代码库，这会使您的工作量增加一倍。对于小型库或想要支持两个版本的新库来说，进行两次错误修复或功能补充是不理想的。我不建议在项目一开始就使用这种方法。 构建脚本在VueUse中，编写了一些构建脚本，以便在构建时从目标版本的 API 导入代码。之后，我需要发布两个标签vue2 vue3来区分不同版本的支持。有了这个，我可以编写一次代码并使库支持两个 Vue 版本。它的问题是我需要在每个版本上构建两次并引导用户安装相应的插件版本（@vue&#x2F;composition-api对于Vue 2则需要手动安装）。 Vue 2&#x2F;3 共存开发的思路同时⽀持 Vue 2&#x2F;3 项⽬Vue 2&#x2F;3 项⽬存在的可能场景渐进式迁移： 如果有一个较大的 Vue 2 项目，但是想要逐步迁移到 Vue 3，可以选择在项目中同时引入 Vue 3，然后逐步将 Vue 2 组件迁移到 Vue 3。 依赖库和插件兼容性： 如果项目依赖于一些 Vue 2 的插件或库，而这些插件或库还没有升级到 Vue 3，可能需要同时使用 Vue 2 和 Vue 3 以确保兼容性。 新功能采用 Vue 3： 可能希望项目中使用 Vue 3 来利用其新功能和性能优势，同时保留 Vue 2 用于旧的组件或功能。 项⽬融合者： 公司内部基于体验要求，需要 Vue 2&#x2F;3项⽬呈现在同⼀⻚⾯中 内部组件资产维护者： 需要在 Vue 2&#x2F;3 的项⽬都⽀持，且能⼒必须⼀致 ⽼项⽬应⽤开发者： 需要⽤到⼀个第三⽅图表组件，但只有 Vue 3 版本，⽽⾮ Vue 2 版本 解决⽅案1. Vue 2&#x2F;3 项⽬共存 直接通过 Vue 3 的 createApp 创建⼀个 Vue 3 的根实例，然后通过 Vue 2 的 mount ⽅法挂载到 Vue 2 的根实例上，这样就可以在 Vue 2 的项⽬中使⽤ Vue 3 的组件。 相关的代码仓库贴在这里，大家自取：vue5 &#x2F;&#x2F; Vue 3 项⽬ import &#123; createApp &#125; from &#39;vue&#39; import App from &#39;.&#x2F;App.vue&#39; createApp(App).mount(&#39;#vue3&#39;) &#x2F;&#x2F; Vue 2 项⽬ import Vue from &#39;vue2&#39; import App from &#39;.&#x2F;App.vue&#39; new Vue(&#123; render: h &#x3D;&gt; h(App as any), &#125;).$mount(&#39;#vue2&#39;) 这一个思路重要的是我们采用配置vite.config.ts解决不同模块的编译问题：编写了一些构建脚本，以便在构建时从目标版本的 API 导入代码。之后，我需要发布两个标签vue2 vue3来区分不同版本的支持。但是它的问题其实是需要在每个版本上引导用户安装相应的插件版本。这对于开发者处理包冲突问题并不是很友好。 import path from &#39;path&#39; import &#123; defineConfig &#125; from &#39;vite&#39; import Vue2 from &#39;@vitejs&#x2F;plugin-vue2&#39; import Vue3 from &#39;@vitejs&#x2F;plugin-vue&#39; import Inspect from &#39;vite-plugin-inspect&#39; import compiler from &#39;vue2&#x2F;compiler-sfc&#39; const src &#x3D; path.resolve(__dirname, &#39;src&#39;) export default defineConfig(&#123; plugins: [ Vue3(&#123; include: [&#x2F;vue3[&#x2F;\\\\].*\\.vue$&#x2F;], &#125;), Vue2(&#123; include: [&#x2F;vue2[&#x2F;\\\\].*\\.vue$&#x2F;], compiler: compiler as any, &#125;), Inspect(), ], &#125;) 这样我们属于是将Vue2和Vue3单独做成了两个独立的包，然后在vite.config.ts中配置了不同的编译规则，这样就可以在同一个页面中使用Vue2和Vue3。 2. JessicaSachs&#x2F;petite 方案先来简单介绍一下petite： Petite是一个为Vue组件作者构建的主观GitHub模板。 它设置了开发、文档和测试通用SFC组件所需的工具，并与Vue 2.7运行时向后兼容。 这是通过一些运行时辅助函数和一个非常主观的单体库结构实现的。 Petite设置了Vite、Volar、Linting、Vitepress、TypeScript和Testing，这样您就可以选择编写Vue 3风格的代码，同时轻松保持对Vue 2.x用户的向后兼容性。 而这也意味着您将在 npm 上发布软件包的两个版本，而不是为了支持 Vue 2 或 Vue 3 而中断主要版本。 这样做的缺点是您的用户在升级和更改导入时需要安装新版本。 好处是您可以更轻松地编写向后兼容的代码并为用户提供定期升级。此外，您还可以拆分仅 Vue 2 和仅 Vue 3 的依赖项。 如果您在通用代码中使用lodash，您将需要在工作区根目录中运行后pnpm build，每个包 ( lib-vue3、lib-vue2) 应独立部署。 3. vue-bridge 方案4. vue-demi 方案仓库实例：vue-demi Vue Demi是一个开发实用程序，允许您为 Vue 2 和 3 编写通用 Vue 库。无需担心用户安装的版本。 当您要创建 Vue 插件&#x2F;库时，只需安装vue-demi为依赖项并从中导入与 Vue 相关的任何内容即可。像往常一样发布你的插件&#x2F;库，你的包将变得通用！ &#123; &quot;dependencies&quot;: &#123; &quot;vue-demi&quot;: &quot;latest&quot; &#125; &#125; import Vue, &#123; reactive, ref &#125; from &#39;vue-demi&#39; 在底层，它使用了postinstallnpm hook。安装所有包后，脚本将开始检查已安装的 Vue 版本，并将导出重定向到基于本地 Vue 版本。使用 Vue 2 时，@vue&#x2F;composition-api如果未安装，它也会自动安装。 所需要注意的有关于库&#x2F;组件的点： 库&#x2F;组件 单仓库 - 多个包构建 依赖管理 alias 别名配置 npm 包名 构建工具配置 Vue 2 应⽤中引⼊ Vue 3 组件会有组件互操作的限制 context 共享 scoped slots 事件 Vue 2 应⽤中引⼊ Vue 3 组件的思路 Vue 3 可以有多个全局实例 前提：Vue 2 升级到 2.7、Vue CLI 移除部分过时插件 互操作层：Custom Elements 构建⼯具：Vite","link":"/2023/11/28/vue5/"},{"title":"vue-renderer 渲染器的核心 Diff 算法","text":"前言渲染器的核心就是 Diff 算法。简单来说，当新旧 vnode 的子节点都是一组节点时，为了以最小的性能开销完成更新操作，需要比较两组子节点，用于比较的算法就叫作 Diff 算法。我们知道，操作 DOM 的性能开销通常比较大，而渲染器的核心 Diff 算法就是为了解决这个问题而诞生的。 减少 DOM 操作的性能开销核心 Diff 只关心新旧虚拟节点都存在一组子节点的情况。针对两组子节点的更新，我们之前采用了一种简单直接的手段，即卸载全部旧子节点，再挂载全部新子节点。这么做的确可以完成更新，但由于没有复用任何 DOM 元素，所以会产生极大的性能开销。 // 旧 vnode const oldNode = &#123; type: 'div', children: [ &#123; type: 'p', children: '1' &#125;, &#123; type: 'p', children: '2' &#125;, &#123; type: 'p', children: '3' &#125; ] &#125; // 新 vnode const newNode = &#123; type: 'div', children: [ &#123; type: 'p', children: '4' &#125;, &#123; type: 'p', children: '5' &#125;, &#123; type: 'p', children: '6' &#125; ] &#125; 按照之前的做法，当更新子节点时，我们需要执行 6 次 DOM 操作： 卸载所有旧子节点，需要 3 次 DOM 删除操作； 挂载所有新子节点，需要 3 次 DOM 添加操作。 但是，通过观察上面新旧 vnode 的子节点，可以发现：更新前后的所有子节点都是 p 标签，即标签元素不变；只有 p 标签的子节点（文本节点）会发生变化。 例如，oldVNode 的第一个子节点是一个 p 标签，且该 p 标签的子节点类型是文本节点，内容是 ‘1’。而 newVNode 的第一个子节点也是一个 p 标签，它的子节点的类型也是文本节点，内容是 ‘4’。可以发现，更新前后改变的只有 p 标签文本节点的内容。 所以，最理想的更新方式是，直接更新这个 p 标签的文本节点的内容。这样只需要一次 DOM 操作，即可完成一个 p 标签更新。新旧虚拟节点都有 3 个 p标签作为子节点，所以一共只需要 3 次 DOM 操作就可以完成全部节点的更新。相比原来需要执行 6 次 DOM 操作才能完成更新的方式，其性能提升了一倍。 按照这个思路，我们可以重新实现两组子节点的更新逻辑，如下面 patchChildren 函数的代码所示： function patchChildren(n1, n2, container) &#123; if (typeof n2.children === 'string') &#123; // 省略部分代码 &#125; else if (Array.isArray(n2.children)) &#123; // 重新实现两组子节点的更新方式 // 新旧 children const oldChildren = n1.children const newChildren = n2.children // 遍历旧的 children for (let i = 0; i &lt; oldChildren.length; i++) &#123; // 调用 patch 函数逐个更新子节点 patch(oldChildren[i], newChildren[i]) &#125; &#125; else &#123; // 省略部分代码 &#125; &#125; 在这段代码中，oldChildren 和 newChildren 分别是旧的一组子节点和新的一组子节点。我们遍历前者，并将两者中对应位置的节点分别传递给 patch 函数进行更新。patch 函数在执行更新时，发现新旧子节点只有文本内容不同，因此只会更新其文本节点的内容。这样，我们就成功地将 6 次 DOM 操作减少为 3 次。其中菱形代表新子节点，矩形代表旧子节点，圆形代表真实 DOM 节点。 这种做法虽然能够减少 DOM 操作次数，但问题也很明显。在上面的代码中，我们通过遍历旧的一组子节点，并假设新的一组子节点的数量与之相同，只有在这种情况下，这段代码才能正确地工作。但是，新旧两组子节点的数量未必相同。当新的一组子节点的数量少于旧的一组子节点的数量时，意味着有些节点在更新后应该被卸载。","link":"/2023/11/11/vue-renderer-4/"},{"title":"浅谈WebAssembly","text":"引言看了不少Wasm的文章，也做了一些性能测试，现在来简单的谈下这门技术。 WASM &#x3D;&#x3D; 汇编级性能？这显然不对，WASM 里的 Assembly 并不意味着真正的汇编码，而只是种新约定的字节码，也是需要解释器运行的。 这种解释器肯定比 JS 解释器快得多，但自然也达不到真正的原生机器码水平。 一个可供参考的数据指标，是 JS 上了 JIT 后整体性能大致是机器码 1&#x2F;20 的水平，而 WASM 则可以跑到机器码 1&#x2F;3 的量级（视场景不同很不好说，仅供参考）。相当于即便你写的是 C++ 和 Rust 级的语言，得到的其实也只是 Java 和 C# 级的性能。 这也可以解释为什么 WASM 并不能在所有应用场景都显示出压倒性的性能优势：只要你懂得如何让 JS 引擎走在 Happy Path 上，那么在浏览器里，JS 就敢和 Rust 性能优化差不多。 一个在 WASM 和 JS 之间做性能对比的经典案例，就是 Mozilla 开发者和 V8 开发者的白学现场。整个过程是这样的： Mozilla Hacks 发表了一篇名为 用 Rust 和 WASM 优化 Source Map 性能 的博文，将 source-map 这个 JS 包的性能优化了五倍。 V8 核心开发 Vyacheslav Egorov 回应名为你也许不需要用 Rust 和 WASM 来优化 JS 的博文，用纯 JS 实现了速度比 Rust 更快的惊人优化。 原文作者以 无需魔法的速度 为名展开了进一步讨论，并用 Rust 做出了新的性能优化。 巧的是，这场论战正发生在两年前白色相簿的季节。双方就像雪菜和冬马那样展开了高水平的对决，名场面十分精彩。最终 Vyacheslav 给出了一张三轮过招后的性能对比图。可以看到虽然最终还是 Rust 更快，但 JS 被逼到极限后非但不是败犬，还胜出了一回合： 另外，大佬Milo Yip 做过的不同语言光线追踪性能测试（修罗场），也能侧面印证带 VM 语言与机器码之间的性能对比结论。C++、Java 和 JS 在未经特别优化的前提下，可以分别代表三个典型的性能档次： C++&#x2F;C#&#x2F;F#&#x2F;Java&#x2F;JS&#x2F;Lua&#x2F;Python&#x2F;Ruby 渲染比试 WASM 比 JS 快，所以计算密集型应用就该用它？这有点偏颇，WASM 同样是 CPU 上的计算。对于可以高度并行化的任务，使用 WebGL 来做 GPU 加速往往更快。譬如我在 实用 WebGL 图像处理入门 这篇文章里介绍的图像处理算法，比起 JS 里 for 循环遍历 Canvas 像素就可以很轻松地快个几十倍。 而这种套两层 for 循环的苦力活，用现在的 WASM 重写能快几倍就非常不错了。至于浏览器内 AI 计算的性能方面，社区的评测结论也是 WebGL 和 WebMetal 具备最高的性能水平，然后才是 WASM。参见这里：浏览器内的 AI 评测 不过，WebGL 的加速存在精度问题。例如前端图像缩放库 Pica，它的核心用的是 Lanczos 采样算法。我用 WebGL 着色器实现过这个算法，它并不复杂，早期的 Pica 也曾经加入过可选的 WebGL 优化，但现在却劈腿了 WASM。这一决策的理由在于，WASM 能保证相同参数下的计算结果和 JS 一致，但 WebGL 则不行。相关讨论参见这里：Issue #114 · nodeca&#x2F;pica 而且，对于前端来说，计算密集型的应用场景并不算太多，比起 WebGPU 这种图形渲染的技术的发展前景可以说算是比较弱势，但毕竟二者不在同一种应用场景下。 所以对计算密集型任务，WASM 并不是前端唯一的救星，而是给大家多了一种在性能、开发成本和效果之间权衡的选择。在我个人印象里，前端在图形渲染外需要算力的场景说实话并不太多，像加密、压缩、挖矿这种，都难说是高频刚需。至于未来可能相当重要的 AI 应用，长期而言我还是看好 WebGPU 这种更能发挥出 GPU 潜力的下一代标准，当然 WASM 也已经是个不错的可选项了。 只要嵌入 WASM 函数到 JS 就能提高性能？既然 WASM 很快，那么是不是我只要把 JS 里 const add (a, b) &#x3D;&gt; a + b 这样的代码换成用 C 编译出来的 WASM，就可以有效地提高性能了呢？ 这还真不一定。 因为现代浏览器内的 JS 引擎都有进行性能优化的利器，都标配了一种东西，那就是 JIT。简单来说，上面这个 add 函数如果始终都在算整数加法，那么 JS 引擎就会自动编译出一份计算 int a + int b 的机器码来替代掉原始的 JS 函数，这样高频调用这个函数的性能就会得到极大的提升，这也就是 JIT 所谓 Just-in-time 编译的奥妙所在了。 所以，不要一觉得 JS 慢就想着手动靠 WASM 来嵌入 C，其实现代 JS 引擎可都是在不停地帮你「自动把 JS 转换成 C」的！如果你可以把一个 JS 函数改写成等价的 C，那么我猜如果把这个函数单独抽离出来，靠 JS 引擎的 JIT 都很可能达到相近的性能。这应该就是 V8 开发者敢用 JS 和 Rust 对线的底气所在吧。 像在 JS 和 WASM 之间的调用终于变快了 这篇文章中，Lin Clark 非常精彩地论述了整个优化过程，最终使得 JS 和 WASM 间的函数调用，比非内联的 JS 函数间调用要快。不过，至于和被 JIT 内联掉的 JS 函数调用相比起来如何，这篇文章就没有提及了。 这里偏个题，Mozilla 经常宣传自己实现的超大幅优化，有不少都可能来源于之前明显的设计问题（平心而论，我们自己何尝不是这样呢）。像去年 Firefox 70 在 Mac 上实现的 大幅省电优化，其根源是什么呢？粗略的理解是，以前的 Firefox 在 Mac 上竟然每帧都会全量更新窗口像素！当然，这些文章的干货都相当多，十分推荐大家打好基础后看看原文，至少是个更大的世界，也常常能对软件架构设计有所启发。 如果后续 WASM 支持了 GC，那么嵌入互调的情况很可能更复杂。例如我最近就尝试在 Flutter 的 Dart 和安卓的 Java 之间手动同步大对象，希望能「嵌入一些安卓平台能力到 Flutter 体系里」，然而这带来了许多冗长而低性能的胶水代码，需要通过异步的消息来做深拷贝，可控性很低。 虽然 WASM 现在还没有 GC，但一旦加上，我有理由怀疑它和 JS 之间的对象生命周期管理也会遇到类似的问题。只是这个问题主要是让 Mozilla 和 Google 的人来操心，用不着我们管而已。 在 JS 里调 WASM，就像 Python 里调 C 那样简单？这个问题只有实际做过才有发言权。譬如我最近尝试过的这些东西： 在安卓的 Java class 里调用 C++ 在 Flutter 的 Dart 里调用 C 在 QuickJS 这种嵌入式 JS 引擎里调用 C 它们都能做到一件事，那就是在引擎里新建原生对象，并将它以传引用的方式直接交给C / C++函数调用，并用引擎的 GC 来管理对象的生命周期。这种方式一般称为 FFI（Foreign Function Interface 外部函数接口），可以把原生代码嵌入到语言 Runtime 中。但如果是两个不同的 Runtime，事情就没有这么简单了。例如 QuickJS 到 Java 的 binding 项目 Quack，就需要在 JS 的对象和 Java 对象中做 Marshalling（类似于 JSON 那样的序列化和反序列化）的过程，不能随便传引用。 对 WASM 来说是怎样的呢？ 基本上，WASM 的线性内存空间可以随便用 JS 读写，并没有深拷贝的困扰。不过，WASM倒有一些数据流的问题，只有 int 和 float 之流的数据类型，连 string 都没有，因此对于稍复杂一点的对象，都很难手写出 JS 和 WASM 两边各自的结构。这点导致你想直接使用Wasm做复杂的对象转换都较为困难，现在这件脏活是交由 wasm-bindgen 等轮子来做的,wasm-pack 使用另一个工具 wasm-bindgen 来提供 JavaScript 和 Rust 等其他类型之间的桥梁。 但毕竟这个过程并不是直接在 JS 的 Runtime 里嵌入 C &#x2F; C++ 函数，和传统编译到机器码的 FFI 还是挺不一样的。 例如现在如果需要频繁地用 WASM 操作 JS 对象，那么几乎必然是影响性能的。这方面典型的坑是基于 WASM 移植的 OpenGL 应用。像 C++ 中的一个 glTexImage2D 函数，目前编译到 WASM 后就需要先从 WASM 走到 JS 胶水层，再在 JS 里调 gl.texImage2D 这样的 WebGL API，最后才能经由 C++ binding 调用到原生的图形 API。这样从一层胶水变成了两层，性能不要说比起原生 C++，能比得上直接写 JS 吗？ 当然，Mozilla 也意识到了这个问题，因此他们在尝试如何更好地将 Web IDL（也就是浏览器原生 API 的 binding）开放给 WASM，并在这个过程中提出了 WASM Interface Types 概念：既然 WASM 已经是个字节码的中间层了，那么干脆给它约定个能一统所有编程语言运行时类型的 IR 规范吧！不过，这一规范还是希望主要靠协议化、结构化的深拷贝来解决问题，只有未来的 anyref 类型是可以传引用的。anyref 有些像 Unix 里的文件描述符，这里就不展开了。 WASM 属于前端生态？这个我不太认可, 要知道Wasm这个玩意其编译工具链和依赖库生态，基本完全不涉及 JS。 一套支持交叉编译的工具链，会附带上用于支持目标平台的一些库，例如 include 了 &lt;GLES2/gl2.h&gt; 之后，你调用到的 glTexImage2D API 就是动态库里提供的。有了动态库，这个 API 才能在 x86 &#x2F; ARM &#x2F; MIPS &#x2F; WASM 等平台上一致地跑起来（就像安卓上的 .so 格式）。 像 Emscripten 就提供了面向 WASM 平台，编译成 JS 格式的一套动态库。但它只能保证这些 API 能用，性能如何就另说了。它自己也对移植 WebGL 时的性瓶颈提出了很多的优化建议。 所以这里再重复一遍，编译 WASM 应用所需的依赖库和整套工具链，几乎都跟 JS 没什么关系。JS 就像机器码那样，只是人家工具链编译出来的输出格式而已。在 JS 开发者看来，这整套东西可能显得相当突兀。但从原生应用开发者的视角看来，这一切都再正常不过了。 后记WASM 当然是个革命性的技术，代表了一种跨平台的全新方向，尤其对原生应用开发者来说具备巨大的商业价值。但它对前端来说其实就是个浏览器内置的字节码虚拟机。","link":"/2023/11/03/wasm-1/"},{"title":"Webpack-自定义 loader/plugin","text":"引言loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 Loader API，并通过 this 上下文访问。 这边贴一个官网链接loader的用法和例子，以及自定义loader本地开发测试 Webpack Loader的简单使用当一个 loader 在资源中使用，这个 loader 只能传入一个参数 - 一个包含资源文件内容的字符串。 同步 loader 可以 return 一个代表已转换模块（transformed module）的单一值。 loader 会返回一个或者两个值。第一个值的类型是 JavaScript 代码的字符串或者 buffer。第二个可选值是 SourceMap，它是个 JavaScript 对象。 下面是一个简单的loader的用法，他将匹配所有的js文件，并使用loader.js处理 //webpack.config.js const path = require('path'); module.exports = &#123; //... module: &#123; rules: [ &#123; test: /\\.js$/, use: [ &#123; loader: path.resolve('path/to/loader.js'), options: &#123; /* ... */ &#125;, &#125;, ], &#125;, ], &#125;, &#125;; 由上面我们可以知道loader的使用方法，但对loader仅停留在使用，那具体的一个loader长什么样呢？ 比如说一个简单的loader是这样的： module.exports = function (content) &#123; // content 就是传入的源内容字符串 return content &#125; 一个 loader 就是一个node模块，其中暴露了一个函数，并只可以接收一个入参，这个参数是一个包含包含资源文件内容的字符串，而函数的返回值就是处理后的内容。 自定义webpack loader自定义loader的用法准则编写 loader 时应该遵循以下准则。它们按重要程度排序，有些仅适用于某些场景，请阅读下面详细的章节以获得更多信息。 保持 简单 。 使用 链式 传递。 模块化 的输出。 确保 无状态 。 使用 loader utilities 。 记录 loader 的依赖 。 解析 模块依赖关系 。 提取 通用代码 。 避免 绝对路径 。 使用 peer dependencies。 步骤1：创建项目目录和文件首先，在一个webpack项目目录中的文件夹中创建以下文件： src/loader/custom-loader.js：自定义Loader的源文件。 src/index.js：JavaScript入口文件，用于测试自定义Loader。 步骤2：编写自定义Loader在 custom-loader.js 文件中，编写你的自定义loader代码。这个Loader的作用是将在每个加载的JavaScript文件的顶部添加一个注释。 // src/loader/custom-loader.js module.exports = function(source) &#123; // 在源代码的顶部添加自定义注释 const updatedSource = `/** Custom Comment added by Custom Loader */\\n$&#123;source&#125;`; return updatedSource; &#125;; 步骤3：配置Webpack在项目根目录下创建Webpack配置文件 webpack.config.js。在配置文件中，使用刚刚编写的自定义Loader。 // webpack.config.js const path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, use: ['custom-loader'], // 使用自定义Loader处理.js文件 exclude: /node_modules/, &#125;, ], &#125;, &#125;; 功能就简单的进行了一下实现，这里我们主要说一下如何测试调用我们的本地的 loader，方式有两种，一种是通过 Npm link 的方式进行测试，这边贴一个Npm link的链接，大家可以去创建一个软连接进行本地测试，还是挺方便的npm-link。 另外一种就是直接在项目里面进行路径配置： 单loader配置方法//webpack.config.js &#123; test: /\\.js$/ use: [ &#123; loader: path.resolve('path/to/custom-loader.js'), options: &#123;/* ... */&#125; &#125; ] &#125; 多loader配置方法当然也可以通过数组的方式进行配置 //webpack.config.js resolveLoader: &#123; // 这里就是说先去找 node_modules 目录中，如果没有的话再去 loaders 目录查找 modules: [ 'node_modules', path.resolve(__dirname, 'custom-loader') ] &#125; 步骤4：测试自定义Loader在 index.js 文件中，编写一些JavaScript代码，例如： // src/index.js console.log('Hello, Webpack Loader!'); 步骤5：运行Webpack构建运行以下命令来构建你的项目： npx webpack --config webpack.config.js 构建完成后，你将在 dist 文件夹中找到生成的 bundle.js 文件。在这个文件里面可以看到在顶部添加了自定义注释的JavaScript代码。 Webpack plugin的简单使用插件向第三方开发者提供了 webpack 引擎中完整的能力。使用阶段式的构建回调，开发者可以在 webpack 构建流程中引入自定义的行为。 比如说最简单的一个例子： // webpack.config.js const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: __dirname + '/dist', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', // 指定HTML模板文件 filename: 'index.html', // 生成的HTML文件名 &#125;), // 可以添加更多的插件 ], &#125;; 在上面这个例子里面使用了HtmlWebpackPlugin插件，根据指定的HTML模板生成一个新的HTML文件，并将打包后的JavaScript文件自动添加到生成的HTML文件中。 一个基本的webpack 插件由以下组成： 一个 JavaScript 命名函数或 JavaScript 类。 在插件函数的 prototype 上定义一个 apply 方法，apply 方法在 webpack 装载这个插件的时候被调用，并且会传入 compiler 对象。。 指定一个绑定到 webpack 自身的事件钩子。 处理 webpack 内部实例的特定数据。 功能完成后调用 webpack 提供的回调。 一个插件结构如下： class HelloWorldPlugin &#123; apply(compiler) &#123; compiler.hooks.done.tap( 'Hello World Plugin', ( stats /* 绑定 done 钩子后，stats 会作为参数传入。 */ ) => &#123; console.log('Hello World!'); &#125; ); &#125; &#125; module.exports = HelloWorldPlugin; Compiler and Compilation在插件开发中最重要的两个资源就是 compiler 和 compilation 对象。可以说Webpack plugin的开发就是围绕着这两个对象的 hook 进行操作 compiler 对象可以理解为一个和 webpack 环境整体绑定的一个对象，它包含了所有的环境配置，包括 options，loader 和 plugin，当 webpack 启动时，这个对象会被实例化，并且他是全局唯一的，上面我们说到的 apply 方法传入的参数就是它。 compilation 在每次构建资源的过程中都会被创建出来，一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。它同样也提供了很多的 hook 。 自定义Webpack plugin步骤1：创建项目目录和文件首先，还是需要一个webpack项目。我们在这个文件夹中创建以下文件： src/plugins/CustomPlugin.js：自定义插件的源文件。 步骤2：编写自定义插件在 CustomPlugin.js 文件中，我们编写了一个插件，并将在Webpack构建结束时输出一条信息。 // src/plugins/CustomPlugin.js class CustomPlugin &#123; apply(compiler) &#123; compiler.hooks.done.tap('CustomPlugin', () => &#123; console.log('CustomPlugin: Webpack build process is done!'); &#125;); &#125; &#125; module.exports = CustomPlugin; 步骤3：配置Webpack在配置文件中，使用上面我们的自定义插件。 // webpack.config.js const CustomPlugin = require('./src/plugins/CustomPlugin'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: __dirname + '/dist', &#125;, plugins: [ new CustomPlugin(), // 可以添加更多的插件 ], &#125;; 步骤4：运行Webpack构建现在进行Webpack构建： npx webpack --config webpack.config.js","link":"/2023/10/29/webpack-plugin-design/"}],"tags":[{"name":"Essay","slug":"Essay","link":"/tags/Essay/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"Vue,Browser,FE","slug":"Vue-Browser-FE","link":"/tags/Vue-Browser-FE/"},{"name":"Cloud-Computing","slug":"Cloud-Computing","link":"/tags/Cloud-Computing/"},{"name":"Vue,FE","slug":"Vue-FE","link":"/tags/Vue-FE/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"Chrome,devtools","slug":"Chrome-devtools","link":"/tags/Chrome-devtools/"},{"name":"Webpack,FE","slug":"Webpack-FE","link":"/tags/Webpack-FE/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"FE","slug":"FE","link":"/tags/FE/"},{"name":"Vue,ElementUI,PR","slug":"Vue-ElementUI-PR","link":"/tags/Vue-ElementUI-PR/"},{"name":"Hadoop,Cloud-Computing","slug":"Hadoop-Cloud-Computing","link":"/tags/Hadoop-Cloud-Computing/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"JITcompiler,JavaScript,Wasm","slug":"JITcompiler-JavaScript-Wasm","link":"/tags/JITcompiler-JavaScript-Wasm/"},{"name":"Build,Rspack","slug":"Build-Rspack","link":"/tags/Build-Rspack/"},{"name":"Vue,MathJax,Latex","slug":"Vue-MathJax-Latex","link":"/tags/Vue-MathJax-Latex/"},{"name":"产品","slug":"产品","link":"/tags/%E4%BA%A7%E5%93%81/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Wasm","slug":"Wasm","link":"/tags/Wasm/"}],"categories":[{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"http","slug":"http","link":"/categories/http/"},{"name":"FE","slug":"FE","link":"/categories/FE/"},{"name":"Cloud-Computing","slug":"Cloud-Computing","link":"/categories/Cloud-Computing/"},{"name":"Security","slug":"Security","link":"/categories/Security/"},{"name":"Chrome","slug":"Chrome","link":"/categories/Chrome/"},{"name":"Webpack","slug":"Webpack","link":"/categories/Webpack/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Hadoop","slug":"Hadoop","link":"/categories/Hadoop/"},{"name":"Network","slug":"Network","link":"/categories/Network/"},{"name":"JITcompiler","slug":"JITcompiler","link":"/categories/JITcompiler/"},{"name":"Build","slug":"Build","link":"/categories/Build/"},{"name":"devtools","slug":"Chrome/devtools","link":"/categories/Chrome/devtools/"},{"name":"产品","slug":"产品","link":"/categories/%E4%BA%A7%E5%93%81/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"ElementUI","slug":"Vue/ElementUI","link":"/categories/Vue/ElementUI/"},{"name":"Cloud-Computing","slug":"Hadoop/Cloud-Computing","link":"/categories/Hadoop/Cloud-Computing/"},{"name":"Wasm","slug":"Wasm","link":"/categories/Wasm/"},{"name":"Rspack","slug":"Build/Rspack","link":"/categories/Build/Rspack/"},{"name":"MathJax","slug":"Vue/MathJax","link":"/categories/Vue/MathJax/"},{"name":"PR","slug":"Vue/ElementUI/PR","link":"/categories/Vue/ElementUI/PR/"},{"name":"Latex","slug":"Vue/MathJax/Latex","link":"/categories/Vue/MathJax/Latex/"}]}