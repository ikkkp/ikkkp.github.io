{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"Archives","text":"","link":"/archive/index.html"},{"title":"關於我","text":"写作，是内心的独白“写作，是内心的独白，是灵魂的流淌。” - 王小波 我是ikkkp。 其实想建一个属于自己的个人网站并在上面写一些自己喜欢的东西也不是一天两天了。 我写作的原因，或许并不复杂。文字，是我与世界沟通的桥梁，是我思考、感受、触摸生活的工具。 而写作，是我在孤独中寻找陪伴的方式，是我在迷茫中找到方向的灯塔。 文字是生活的注解，写作是内心的显现。 在这个喧嚣的世界里，写作替我找到了一份宁静。 写作，让我能够更清晰地思考问题，更深刻地理解自己。 每当我将思绪转化为文字，就像是给心灵进行了一次洗礼，让我更加了解自己的内心世界。写作，也是我与他人交流的方式，通过文字，我能够传递我的思想、分享我的经验，与他人建立起深厚的情感纽带。 在文字的海洋里，我们可以不受拘束地航行，探寻无限的可能。","link":"/abouts/index.html"},{"title":"推薦閱讀","text":"","link":"/recommend/index.html"}],"posts":[{"title":"301/302-重定向","text":"前言当你在网站上进行重定向设置时，特别是在以下两种情况下，可能会遇到问题： 从HTTP到HTTPS的重定向： 假设你配置了SSL证书，将网站从HTTP升级到HTTPS。 如果在这个过程中出现了问题，导致网站无法正常访问，你可能会想撤销重定向，回到HTTP版本。然而，问题在于，一旦你使用了301永久性重定向，浏览器会把这个重定向信息保存下来。即使你在服务器上取消了重定向，用户的浏览器依然会强制将他们重定向到HTTPS版本，无法再访问HTTP版本。 更改网站域名的重定向： 当你将网站从一个域名（比如old-domain.com）迁移到另一个域名（比如new-domain.com），你可能会使用301永久性重定向，以便搜索引擎和浏览器知道网站已经永久地移动到了新的域名。 但如果在这个过程中出现了问题，你可能希望撤销重定向，使用户能够再次访问旧域名。然而，由于301重定向被浏览器硬缓存，用户将被永久性地重定向到新域名，无法再访问旧域名。 为了避免这种情况，建议在测试确保一切正常后，一开始使用302临时性重定向，而不是301永久性重定向。302重定向不会被浏览器永久性地缓存，这意味着如果需要，你可以随时撤销重定向，而用户不会被永久性地锁定在新的网址上。这样可以避免用户需要手动清除浏览器缓存的繁琐步骤，提供更好的用户体验。 301重定向：意味着资源（页面）被永久性地移动到了一个新的位置。客户端&#x2F;浏览器不应再尝试请求原始位置，而应该从现在开始使用新的位置。 302重定向：意味着资源暂时位于其他地方，客户端&#x2F;浏览器应继续请求原始URL。 301是永久性重定向。即使你从服务器移除了重定向，你的浏览器仍然会将资源永久性地重定向到新的域名或HTTPS，因为它们被硬缓存。 所以，302不会被浏览器硬缓存，如果你从服务器（网站）移除了重定向，你就能够访问旧版本。 清除301&#x2F;302重定向缓存通常涉及清除浏览器缓存或者操作系统的DNS缓存。下面是如何在不同平台上做的说明： 清除浏览器缓存（适用于Windows、macOS、Linux）Google Chrome： 打开Chrome浏览器。 点击右上角的三个垂直点，选择“更多工具”。 选择“清除浏览数据”。 在弹出的窗口中，选择“高级”选项卡。 选择“所有时间”作为时间范围。 勾选“缓存图像和文件”选项。 点击“清除数据”按钮。 Mozilla Firefox： 打开Firefox浏览器。 点击右上角的三条水平线，选择“隐私与安全”。 在“Cookie和站点数据”部分，点击“清除数据”。 确保勾选了“缓存”选项。 点击“清除”。 Microsoft Edge： 打开Edge浏览器。 点击右上角的三个水平点，选择“设置”。 滚动至底部，点击“查看高级设置”。 在“隐私与服务”部分，点击“清除浏览数据”。 勾选“缓存图像和文件”选项。 点击“清除”按钮。 清除操作系统的DNS缓存（适用于Windows、macOS）Windows： 打开命令提示符（在开始菜单中搜索“cmd”并打开）。 输入以下命令并按下回车键：ipconfig &#x2F;flushdns macOS： 打开终端（在应用程序 &gt; 实用工具文件夹中找到）。 输入以下命令并按下回车键：sudo dscacheutil -flushcache 然后输入管理员密码并再次按下回车键。 请注意，清除浏览器缓存可能会导致您在网站上的登录状态丢失，所以请确保您已经备份了重要的信息，以防需要重新登录网站。","link":"/2023/10/28/301-302-Redirection/"},{"title":"Webpack 性能优化-1","text":"前言先来说说为什么要优化？当然如果你的项目很小，构建很快，其实不需要特别关注性能方面的问题。 但是随着项目涉及到的页面越来越多，功能和业务代码也会越来越多，相应的 webpack 的构建时间也会越来越久，这个时候我们就不得不考虑性能优化的事情了。 webpack 的性能优化较多，我们考虑从两方面入手：优化一：打包后的结果，上线时的性能优化。（比如分包处理、减小包体积、CDN服务器等）优化二：优化打包速度，开发或者构建时优化打包速度。（比如 exclude 、cache-loader等） 因为这个上线时的性能是直接影响到用户使用体验的，而构建时间与我们的日常开发是密切相关，当我们本地开发启动 devServer 或者 build 的时候，如果时间过长，会大大降低我们的工作效率。 性能优化 - 代码分离代码分离（Code Splitting）是 webpack 一个非常重要的特性： 它主要的目的是将代码分离到不同的 bundle 中，之后我们可以按需加载，或者并行加载这些文件；比如默认情况下，所有的 JavaScript 代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度；代码分离可以分出更小的 bundle ，以及控制资源加载优先级，提供代码的加载性能； Webpack中常用的代码分离有三种： 入口起点：使用entry配置手动分离代码； 防止重复：使用Entry Dependencies或者SplitChunksPlugin去重和分离代码； 动态导入：通过模块的内联函数调用来分离代码； 入口起点优化-Entry Dependencies(入口依赖)当项目拥有多个入口点（entry points）时，可能会遇到一些重复依赖的问题。某些模块可能在多个入口点中被引用，导致这些模块被重复打包，增加了最终输出文件的体积。dependon-shared模块解决重复依赖 module.exports = &#123; entry: &#123; page1: &#123; import: './src/page1.js', dependOn: 'shared', &#125;, page2: &#123; import: './src/page2.js', dependOn: 'shared', &#125;, shared: './src/shared.js', &#125;, output: &#123; filename: '[name].bundle.js', path: __dirname + '/dist', &#125;, &#125;; 动态导入(dynamic import)动态导入是一种在Webpack中实现按需加载（Lazy Loading）的技术，允许在运行时异步加载模块，而不是在应用初始化时就把所有模块打包到一个大文件中。可以提高应用的初始加载速度，并且减小了初始包的体积。 const path = require('path'); module.exports = &#123; entry: &#123; main: './src/index.js', &#125;, output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist'), publicPath: '/', &#125;, module: &#123; rules: [ // 添加你的Loader规则 ], &#125;, optimization: &#123; splitChunks: &#123; chunks: 'all', &#125;, &#125;, &#125;; 在上述配置中，通过 optimization.splitChunks 进行代码分割，它的 chunks: &#39;all&#39; 选项表示对所有模块进行代码分割。 然后，在代码中使用 import() 函数进行动态导入： // 在需要的地方使用动态导入 const loadModule = () => import('./Module'); loadModule().then(module => &#123; // 使用加载的模块 &#125;); Webpack会将使用 import() 函数引入的模块进行代码分割，生成单独的文件。在运行时，这些文件会在需要的时候异步加载。 自定义分包-SplitChunks分包（code splitting）是一种优化策略，它允许将代码分割成小块，使得应用在加载时能够更快地显示内容。 Webpack提供了多种分包的模式，其中一种是使用SplitChunksPlugin插件来实现的，这个模式叫做splitChunks。 module.exports = &#123; // ...其他配置 optimization: &#123; splitChunks: &#123; chunks: 'all', minSize: 30000, // 模块的最小体积 minChunks: 1, // 模块的最小被引用次数 maxAsyncRequests: 5, // 按需加载时的最大并行请求数 maxInitialRequests: 3, // 入口点的最大并行请求数 automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10, reuseExistingChunk: true, &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true, &#125;, &#125;, &#125;, &#125;, &#125;; webpack-split-chunks-plugin 性能优化-CDNCDN称之为内容分发网络（Content Delivery Network或Content Distribution Network，缩写：CDN）， 它是指通过相互连接的网络系统，利用最靠近每个用户的服务器； 更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户； 来提供高性能、可扩展性及低成本的网络内容传递给用户； 在开发中，我们使用CDN主要是两种方式： 打包的所有静态资源，放到CDN服务器， 用户所有资源都是通过CDN服务器加载的； 一些第三方资源放到CDN服务器上； 使用CDN（Content Delivery Network，内容分发网络）是一种非常有效的性能优化策略，特别是在Webpack中。CDN可以加速网站的加载速度，减轻服务器负担，并提高用户体验。以下是如何在Webpack中配置和使用CDN的方法： 将第三方库引入CDN将你的项目中用到的第三方库（例如React、Vue、jQuery等）引入CDN。可以选择在HTML文件中直接引入CDN链接： &lt;script src=\"https://cdn.jsdelivr.net/npm/react@版本号/dist/react.min.js\">&lt;/script> &lt;script src=\"https://cdn.jsdelivr.net/npm/react-dom@版本号/dist/react-dom.min.js\">&lt;/script> 在Webpack中配置externals在Webpack的配置中使用externals字段，告诉Webpack哪些模块是外部引入的，不需要打包。 module.exports = &#123; // ...其他配置 externals: &#123; react: 'React', 'react-dom': 'ReactDOM', &#125;, &#125;; 然后在HTML文件中通过script标签引入CDN： &lt;script src=\"https://cdn.jsdelivr.net/npm/react@版本号/dist/react.min.js\">&lt;/script> &lt;script src=\"https://cdn.jsdelivr.net/npm/react-dom@版本号/dist/react-dom.min.js\">&lt;/script> 配置CDN的publicPath在Webpack的output字段中配置publicPath，指定在引入资源时使用的URL前缀，通常设置为CDN的地址： module.exports = &#123; // ...其他配置 output: &#123; // ...其他output配置 publicPath: 'https://cdn.example.com/', &#125;, &#125;; 这样在Webpack构建时，所有的资源引用路径都会加上CDN的地址前缀。 性能优化-提取css文件将CSS文件从JavaScript打包文件中提取出来是一种常见的性能优化策略。这样做的好处是可以减小JavaScript文件的体积，加快页面加载速度，并且使浏览器能够并行下载CSS和JavaScript文件，提高加载性能。在Webpack中，你可以使用mini-css-extract-plugin插件来实现CSS文件的提取。 配置Webpack 在Webpack配置文件中引入mini-css-extract-plugin插件，然后配置module.rules来处理CSS文件。 const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = &#123; // ...其他配置 module: &#123; rules: [ &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', // 可以加入其他的CSS处理loader，比如postcss-loader和sass-loader ], &#125;, ], &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: 'styles.css', // 提取出的CSS文件的文件名 &#125;), ], &#125;; 引入CSS文件 在JavaScript文件或者入口文件中引入CSS文件： import './styles.css'; 或者在HTML文件中使用link标签引入提取出来的CSS文件： &lt;link rel=\"stylesheet\" href=\"styles.css\"> 性能优化-打包文件命名(Hash,ContentHash,ChunkHash)在Webpack中，打包文件的命名是一个重要的性能优化策略。合适的命名方案可以确保浏览器能够正确地缓存文件，避免不必要的网络请求，提高应用的加载速度。以下是三种常见的打包文件命名方式：Hash、ContentHash 和 ChunkHash。 Hash（哈希）Hash 是根据文件内容生成的哈希值，当文件内容发生改变时，其对应的 Hash 值也会改变。在Webpack中，可以使用 [hash] 占位符来表示 Hash 值。 output: &#123; filename: 'bundle.[hash].js', &#125; ContentHash（内容哈希）ContentHash 是根据文件内容生成的哈希值，但是不同于 Hash 的是，ContentHash 只会受到文件内容的影响，不会受到文件名或路径等其他因素的影响。在Webpack中，可以使用 [contenthash] 占位符来表示 ContentHash 值。 output: &#123; filename: 'bundle.[contenthash].js', &#125; ChunkHash（块哈希）ChunkHash 是根据模块内容生成的哈希值，不同模块的内容不同，它们的 ChunkHash 值也会不同。在Webpack中，可以使用 [chunkhash] 占位符来表示 ChunkHash 值。 output: &#123; filename: '[name].[chunkhash].js', &#125; 性能优化-webpack实现Tree ShakingJavaScript的Tree Shaking： 对JavaScript进行Tree Shaking是源自打包工具rollup（后面我们也会讲的构建工具）； 这是因为Tree Shaking依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）； webpack2正式内置支持了ES2015模块，和检测未使用模块的能力； 在webpack4正式扩展了这个能力，并且通过 package.json的 sideEffects属性作为标记，告知webpack在编译时，哪里文 件可以安全的删除掉； webpack5中，也提供了对部分CommonJS的tree shaking的支持； commonjs-tree-shaking JS实现Tree Shakingwebpack实现Tree Shaking采用了两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的； sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用； CSS进行Tree ShakingCSS的Tree Shaking需要借助于一些其他的插件； 在早期的时候，我们使用PurifyCss插件来完成CSS的tree shaking，但是目前该库已经不再维护； 目前我们可以使用另外一个库来完成CSS的Tree Shaking：PurgeCSS，也是一个帮助我们删除未使用的CSS的工具: PurgeCss","link":"/2023/10/26/Webpack-optimization-1/"},{"title":"云计算及应用","text":"云计算的定义即通过网络按需提供可动态伸缩的廉价计算服务。是与信息技术、软件、互联网相关的一种服务。 云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进入可配置的计算机资源共享池（资源包括网络、服务器、存储、应用软件、服务），这些资源能够被快速提供。 云计算发展史2006年3月，亚马逊（Amazon）推出弹性计算云（Elastic Compute Cloud；EC2）服务。 2006年8月9日，Google首席执行官埃里克·施密特（Eric Schmidt）在搜索引擎大会（SES San Jose 2006）首次提出“云计算”（Cloud Computing）的概念。Google“云端计算”源于Google工程师克里斯托弗·比希利亚所做的“Google 101”项目。 2007年10月，Google与IBM开始在美国大学校园推广云计算的计划。 2008年2月1日，IBM（NYSE: IBM）宣布将在中国无锡太湖新城科教产业园为中国的软件公司建立全球第一个云计算中心（Cloud Computing Center）。 2008年7月29日，雅虎、惠普和英特尔宣布一项联合研究计划，推出云计算研究测试床，推进云计算。 2008年8月3日，美国专利商标局网站信息显示，戴尔正在申请“云计算”（Cloud Computing）商标，此举旨在加强对这一未来可能重塑技术架构的术语的控制权。 2010年3月5日，Novell与云安全联盟（CSA）共同宣布一项供应商中立计划，名为“可信任云计算计划（Trusted Cloud Initiative）”。 2010年7月，美国国家航空航天局和包括Rackspace、AMD、Intel、戴尔等支持厂商共同宣布“OpenStack”开放源代码计划，微软在2010年10月表示支持OpenStack与Windows Server 2008 R2的集成；而Ubuntu已把OpenStack加至11.04版本中。 2011年2月，思科系统正式加入OpenStack，重点研制OpenStack的网络服务。 云计算的技术背景云计算是并行计算(Parallel Computing)、分布式计算(Distributed Computing)和网格计算(Grid Computing)的发展，或者说是这些计算机科学概念的商业实现 云计算是虚拟化(Virtualization)、效用计算(Utility Computing)、IaaS(基础设施即服务)、PaaS(平台即服务)、SaaS(软件即服务)等技术混合演进、提升的结果","link":"/2023/11/08/Cloud-Computing/"},{"title":"Webpack 性能优化-2","text":"性能优化 - JS-CSS代码压缩 Terser是一个JavaScript的解释（Parser）、Mangler（绞肉机）&#x2F;Compressor（压缩机）的工具集； 早期我们会使用 uglify-js来压缩、丑化我们的JavaScript代码，但是目前已经不再维护，并且不支持ES6+的语法； Terser是从 uglify-es fork 过来的，并且保留它原来的大部分API以及适配 uglify-es和uglify-js@3等； webpack-terser JavaScript 代码压缩Webpack 提供了terser-webpack-plugin 插件进行代码优化和压缩。 在production模式下，默认就是使用TerserPlugin来处理代码。 const TerserPlugin = require('terser-webpack-plugin'); module.exports = &#123; // 配置其他Webpack选项... optimization: &#123; minimizer: [new TerserPlugin()], &#125;, &#125;; CSS 代码压缩除了JavaScript代码，CSS代码也可以通过Webpack进行压缩。使用css-minimizer-webpack-plugin 进行压缩CSS代码。 const CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); module.exports = &#123; // 配置其他Webpack选项... optimization: &#123; minimizer: [ new CssMinimizerPlugin(), // 可以继续添加其他压缩插件... ], &#125;, &#125;; webpack实现Tree Shakingtree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。 Webpack 实现 Tree Shaking在现代的前端开发中，代码体积优化是一个关键的议题。Tree Shaking 是一种用于消除未引用代码的优化技术，它可以帮助我们剔除项目中未使用的 JavaScript 模块，从而减小打包后的文件体积。Webpack 提供了内置的支持，使得 Tree Shaking 在项目中变得非常容易实现。 开启 ES 模块化首先，确保你的 JavaScript 代码采用了 ES 模块化的方式，因为Webpack 的 Tree Shaking 功能仅对 ES 模块有效。你可以在项目中使用 import 和 export 语法来定义模块。 // math.js export function square(x) &#123; return x * x; &#125; export function cube(x) &#123; return x * x * x; &#125; Webpack 配置在 Webpack 的配置文件中，确保以下几点设置，以启用 Tree Shaking： 将 mode 设置为 &#39;production&#39;，Webpack 会自动启用相关的优化，包括 Tree Shaking。 JS实现Tree Shakingwebpack实现Tree Shaking采用了两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的； sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用； 使用usedExports实现Tree Sharking配置模式为production module.exports = &#123; mode: 'production', // ...其他配置 &#125;; 配置optimization里面的usedExports const path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), &#125;, mode: 'development', optimization: &#123; usedExports: true, &#125;, &#125;; 使用sideEffect实现Tree Sharking在package.json中设置sideEffects的值： 如果我们将sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports； 如果有一些我们希望保留，可以设置为数组； &#123; \"name\": \"your-project\", \"sideEffects\": [\"./src/some-side-effectful-file.js\"] &#125; Webpack 中的 sideEffects 解释 tree shaking 和 sideEffectssideEffects 和 usedExports（更多被认为是 tree shaking）是两种不同的优化方式。 sideEffects 更为有效 是因为它允许跳过整个模块&#x2F;文件和整个文件子树。 usedExports 依赖于 terser 去检测语句中的副作用。它是一个 JavaScript 任务而且没有像 sideEffects 一样简单直接。而且它不能跳转子树&#x2F;依赖由于细则中说副作用需要被评估。尽管导出函数能运作如常，但 React 框架的高阶函数（HOC）在这种情况下是会出问题的。 CSS实现TreeShakingCSS的Tree Shaking需要借助于一些其他的插件； 在早期的时候，我们会使用PurifyCss插件来完成CSS的tree shaking，但是目前该库已经不再维护了（最新更新也是在4年前 了）； 目前我们可以使用另外一个库来完成CSS的Tree Shaking：PurgeCSS，也是一个帮助我们删除未使用的CSS的工具； Webpack对文件压缩什么是HTTP压缩HTTP压缩是一种内置在 服务器 和 客户端 之间的，以改进传输速度和带宽利用率的方式；HTTP压缩的流程什么呢？第一步：HTTP数据在服务器发送前就已经被压缩了；（可以在webpack中完成）第二步：兼容的浏览器在向服务器发送请求时，会告知服务器自己支持哪些压缩格式；第三步：服务器在浏览器支持的压缩格式下，直接返回对应的压缩后的文件，并且在响应头中告知浏览器； 目前的流行压缩格式目前的压缩格式非常的多：compress – UNIX的“compress”程序的方法（历史性原因，不推荐大多数应用使用，应该使用gzip或deflate）；deflate – 基于deflate算法（定义于RFC 1951）的压缩，使用zlib数据格式封装；gzip – GNU zip格式（定义于RFC 1952），是目前使用比较广泛的压缩算法；br – 一种新的开源压缩算法，专为HTTP内容的编码而设计； Webpack配置文件压缩webpack中相当于是实现了HTTP压缩的第一步操作，我们可以使用CompressionPlugin。 第一步，安装CompressionPlugin： npm install compression-webpack-plugin -D 第二步，使用CompressionPlugin即可 module.exports = &#123; plugins: [ new CompressionPlugin(&#123; test: /\\.js(\\?.*)?$/i, &#125;), ], &#125;;","link":"/2023/10/27/Webpack-optimization-2/"},{"title":"輕鬆理解 Ajax 與跨來源請求","text":"前言一般來說在學習寫網頁的時候，最先碰到的會是 HTML 與 CSS，負責把版面刻出來以及美化版面，當基礎打穩之後，會開始學習 JavaScript，試著做出一點互動性的效果。而「互動」除了使用者跟瀏覽器的互動以外，別忘了還有 Client 端跟 Server 端的互動，也就是必須要學會從瀏覽器用 JavaScript 跟後端 Server 拿資料，否則你的網頁資料都只能是寫死的。 這篇的主要預設讀者是網頁前端的初學者，希望能讓本來不太理解怎麼跟 Server 交換資料或是怎麼串 APi 的讀者看完之後，能夠更了解該怎麼跟後端串接。 先從舉例開始在開始之前，我們可以先想想一個問題： 為什麼前端必須跟後端交換資料？ 其實這跟你做的網頁類型有關，假如說你今天做的是一個官方網站，很可能整個網站都是靜態的，只要 HTML 跟 CSS 就可以了，並不需要跟後端 Server 拿資料。 那我們先假設今天要做的是一個可以瀏覽現在 Twitch 實況列表的網頁好了，如下圖。 如果這個網頁不跟後端拿資料，就代表說網頁的內容都是固定的，無論什麼時候看都一樣。可是這樣的話就不對了嘛，因為這個網頁的目標是顯示出「現在有在開實況的頻道」，所以內容是會跟著改變的。 既然會跟著改變，就必須不斷的去更新資料，從 Server 那邊拿資料回來，接著在前端處理過後顯示。 已經確認有拿資料的必要性之後，就可以問自己兩個問題： 要跟誰拿資料？ 要怎麼拿資料？ 第一個問題，很明顯的就是跟 Twitch，因為 Twitch 才有你要的這些資料嘛！ 那第二個問題，要怎麼拿資料呢？就必須透過 Twitch API 了。 API什麼是 API？你可能已經聽過很多次這個名詞，但還是不知道是什麼。先來講講它的全名吧，它的全名是「Application Programming Interface」，中文翻作應用程式介面。 你可能會想說這是什麼鬼東西，怎麼中文英文我都看不懂在幹嘛。但其實這幾個字裡面，最重要的是「介面」兩個字。 介面是什麼？介面就是拿來串接用的，我舉一個例子你就知道了。 電腦上不是有一個 USB 插槽嗎？然後你只要是看到市面上有賣 USB 隨身碟的，都可以買來以後插到 USB 插槽，你的電腦就可以讀取得到。你有想過為什麼嗎？明明就是不同廠商做的東西，可是卻都可以讀得到、都可以插到 USB 插槽裡面。 因為有一項標準叫做 USB 介面，當這套標準訂出來以後，所有廠商只要按照這一套標準來開發，就可以保證能夠連接電腦跟 USB 隨身碟。 API 也是這樣，只是變成程式跟程式之間的串接。例如說今天我寫程式需要讀取檔案好了，我要怎麼讀取檔案？讀取檔案是作業系統提供的功能，因此我可以去串接「讀取檔案的 API」，就可以在我的程式裡面也使用這個功能了。 再多舉幾個例子你可能會更有感覺。 例如說今天我想要讓我的網頁能夠用 Facebook 登入，那要怎麼辦？我就要去串接「Facebook 提供的 API」，就等於說是 Facebook 向外提供給大家的一套介面、一套標準，任何想要接入 Facebook 服務的開發者們，都可以遵循著那套規範拿到自己想要的資料，這個東西就叫做 API。 或是你可能今天是一個飯店管理系統的開發者，你們公司做了一套給飯店用的 ERP，可以管理飯店的訂房狀態等等，就能知道說現在有哪些房間是空的。 而這些資料如果只有自己用太可惜了，於是公司決定把這些資料提供給大型訂房網站，在那些網站上能夠即時顯示這間飯店的房間狀況。所以就必須交換資料，你要提供一個「查詢房間情形的 API」給其他網站，讓他們能夠去串接，才能獲得這些資訊。 講到這邊，大家應該對 API 已經有一些 sense 了，我再多舉幾個例子： 我想要抓到 flickr 上面的照片，所以我要去串接 flickr 的 API Google 要開放讓其他 App 也能用 Google 登入驗證，所以 Google 要提供「Google 登入 API」 我要抓 Twitch 上面現在有哪些頻道，所以要串 Twitch API API Documentation既然已經知道 API 是什麼了，也知道要串接 API，那下一個問題就是「那要怎麼串呢？」 剛剛前面有提過檔案存取的例子，其實這個比較像是呼叫作業系統或是程式語言的函式庫提供的 Function，而這些 Function 你通常都可以在官方文件上查到更詳細的說明，例如說 Node.js 的讀取檔案： （來源：https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback） 上面就有寫說你應該呼叫哪一個 Function，應該傳入哪些參數。 API 的串接也是一樣，一定要有文件你才知道怎麼串，不然根本串不起來，因為你連要傳什麼參數都不知道。 我們可以先來看看Twitch API 文件是怎麼寫的。 裡面說明了你必須要有一個Client ID，然後 API Root 的 URL 是 https://api.twitch.tv/kraken 等等，這些都是與 API 相關的基本資訊。如果你在左側欄隨便點一個 API，會看到個別 API 的詳細資訊： 這邊就有寫說網址是什麼，你應該傳的參數是什麼等等，下面還有附上參考範例，這就是一個很完整的 API 文件。 通常在寫網頁的時候，我們都會直接講 API，但其實我們指的是 Web API，也就是透過網路來傳輸的 API。那有沒有非 Web API 呢？有，像我們前面提到的跟作業系統要讀檔的 API，就都是在本機底下執行的，沒有透過任何網路。 不過這其實也不用太在意，反正大家都習慣講 API，聽得懂就好。 現在有了 API 文件，我們就有了所有我們需要的資訊。以上面這個 Twitch 的例子來講，我們只要能夠發送 Request 到https://api.twitch.tv/kraken/games/top?client_id=xxx，Twitch 就會傳回目前最熱門的遊戲列表。 我們已經把問題的範圍一步步給縮小了，一開始是「要怎麼跟 Twitch 拿資料」，現在則更細的切分為：「要怎麼利用 JavaScript 發送 Reuqest」 Ajax要在瀏覽器上面發送 Request，必須應用到一種技術叫做 Ajax，全名是「Asynchronous JavaScript and XML」，重點在於Asynchronous這個單字，非同步。 在講什麼是非同步之前，就要先來提一下什麼是同步。你原本寫的 JavaScript 就幾乎都是同步執行的。意思是他執行到某一行的時候，會等這行執行完畢，才執行到下一行，確保執行順序。 也就是說下面這段程式碼，最後一行需要等很長一段時間才能執行到： var count = 10000000; while(count--) &#123; // 做一些耗時的操作 &#125; // 等很久才被執行到 console.log('done') 看起來滿有道理的，程式本來不就是一行一行執行的嗎？可是如果今天牽涉到網路操作的話，大家可以思考看看下面這個例子： // 假設有個發送 Request 的函式叫做 sendRequest var result = sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx'); // 等很久才被執行到 console.log(result); 當 JavaScript 執行到sendRequest的時候，由於是同步的，就會等待 Response 回來才繼續做事。換句話說，在 Response 還沒回來之前，整個 JavaScript 引擎是不會執行任何東西的！很可怕對吧，你點任何有牽涉到 JavaScript 的東西，都不會有反應，因為 JavaScript 還在等 Response 回來。 所以呢，像是這種已經預期到可能非常耗時間，非常不穩定的操作，就不能用同步的方式來執行，而是要用非同步。 非同步是什麼意思呢？就是執行完之後就不管它了，不等結果回來就繼續執行下一行： // 假設有個發送 Request 的函式叫做 sendRequest var result = sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx'); // 上面 Request 發送完之後就執行到這一行，所以 result 不會有東西 // 因為 Response 根本沒有回來 console.log(result); 這邊需要特別注意的是「非同步的 Function 不能直接透過 return 把結果傳回來」，為什麼？因為像上面這個例子，它發送 Request 之後就會執行到下一行了，這個時候根本就還沒有 Response，是要回傳什麼？ 那怎麼辦呢？先聽我舉個很常見的小例子吧！ 我之前在新加坡的 Food Court 吃飯的時候，那邊每一張桌子上面都會有桌號。你去點餐的時候，只要跟老闆講說你坐哪一桌，等餐點完成之後老闆就會自己主動送過來。 所以我不需要站在店家門口等，我只要在位子上繼續坐我的事情，反正餐點好了之後老闆會送過來。 非同步的概念也是這樣，我發送 Request 之後（我點餐之後），我不用等 Response 回來（不用等老闆做好），可以繼續做自己的事，等 Response 回來之後（等餐點做好之後），會自己幫我把結果送過來（老闆會自己送過來）。 在點餐的例子中，老闆可以透過桌號知道應該把資料送到哪邊，那在 JavaScript 裡面呢？可以透過 Function！而這個 Function，我們就稱作 Callback Function，回呼函式。 當非同步的操作完成時，就可以呼叫這個 Function，並且把資料帶進來。 // 假設有個發送 Request 的函式叫做 sendRequest sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx', callMe); function callMe (response) &#123; console.log(response); &#125; // 或者寫成匿名函式 sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx', function (response) &#123; console.log(response); &#125;); 現在你就知道為什麼網路的操作是非同步，以及什麼是 callback function 了。 XMLHttpRequest方才提到 Ajax、非同步以及 callback function 的概念，但還是沒講到要怎麼發送 Request，只寫了一個假的sendRequest函式當作參考而已。 要發送 Request 的話，就要透過瀏覽器幫我們準備好的一個物件，叫做XMLHttpRequest，範例程式碼如下： var request = new XMLHttpRequest(); request.open('GET', `https://api.twitch.tv/kraken/games/top?client_id=xxx`, true); request.onload = function() &#123; if (request.status >= 200 &amp;&amp; request.status &lt; 400) &#123; // Success! console.log(request.responseText); &#125; &#125;; request.send(); 上面的request.onload其實就是在指定說當資料回來的時候，要用哪一個 function 去處理。 有了上面這一段程式碼之後，你終於大功告成，終於可以串接 Twitch API，從那邊拿資料下來了！真是可喜可賀，從此之後，你就跟「串接 API」這個技能過著幸福快樂的生活… 才怪。 Same Origin Policy正當你以為自己已經對串接 API 駕輕就熟，想說去串接別的 API 試試看好了的時候，才發現一串就出問題了： XMLHttpRequest cannot load http:&#x2F;&#x2F;odata.tn.edu.tw&#x2F;ebookapi&#x2F;api&#x2F;getOdataJH&#x2F;?level&#x3D;all. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;null&#39; is therefore not allowed access. 咦？為什麼會有這個錯誤呢？ 其實是瀏覽器因為安全性的考量，有一個東西叫做同源政策，Same-origin policy。 意思就是說如果你現在這個網站的跟你要呼叫的 API 的網站「不同源」的時候，瀏覽器一樣會幫你發 Request，但是會把 Response 給擋下來，不讓你的 JavaScript 拿到並且傳回錯誤。 什麼是不同源呢？其實你想簡單一點，只要是 Domain 不一樣就是不同源，或者是一個用http一個用https也是不同源，端口號不一樣也是不同源。 所以如果你是接別人 API 的話，大多數情形都是不同源的。 這邊我想再強調一點，「你的 Request 還是有發出去的」，而且瀏覽器也「確實有收到 Response」，重點是「瀏覽器因為同源政策，不把結果傳回給你的 JavaScript」。如果沒有瀏覽器的話其實就沒有這些問題，你愛發給誰就發給誰，不管怎樣都拿得到 Response。 好，既然剛剛說了不同源會被擋下來，那 Twitch API 不是也不同源嗎，是怎麼串接成功的？ CORS大家都知道其實在不同源之間互相傳輸資料是很常有的事情，像我們串接 Twitch API 就是，我們怎麼可能跟 Twitch API 在同一個 Domain 底下呢？ 因此，同源政策的確是規範非同源就被擋下來，但與此同時其實又有另外一個規範，是說：「如果你想在不同 origin 之間傳輸資料的話，你應該怎麼做」，這規範就叫做 CORS。 CORS，全名為 Cross-Origin Resource Sharing，跨來源資源共用。 這套規範跟你說，如果你想開啟跨來源 HTTP 請求的話，Server 必須在 Response 的 Header 裡面加上Access-Control-Allow-Origin。 這個字段你應該不陌生才對，覺得陌生的可以拉回去上面看，剛剛的錯誤訊息其實就有講到這一個 Header。 當瀏覽器收到 Response 之後，會先檢查Access-Control-Allow-Origin裡面的內容，如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。 如果你打開 Devtool 仔細看一開始我們發給 Twitch 的 Request，你會發現 Response 的 Header 大概是長這樣： Content-Type: application&#x2F;json Content-Length: 71 Connection: keep-alive Server: nginx Access-Control-Allow-Origin: * Cache-Control: no-cache, no-store, must-revalidate, private Expires: 0 Pragma: no-cache Twitch-Trace-Id: e316ddcf2fa38a659fa95af9012c9358 X-Ctxlog-Logid: 1-5920052c-446a91950e3abed21a360bd5 Timing-Allow-Origin: https:&#x2F;&#x2F;www.twitch.tv 重點是這一行：Access-Control-Allow-Origin: *，星號就代表萬用字元，意思是任何一個 Origin 都接受。所以當瀏覽器接收到這個 Response 之後，比對目前的 Origin 符合*這個規則，檢驗通過，允許我們接受跨來源請求的回應。 除了這個 Header 以外，其實還有其他的可以用，例如說Access-Control-Allow-Headers跟Access-Control-Allow-Methods，就可以定義接受哪些 Request Header 以及接受哪些 Method。 總結一下，如果你想要發起跨來源 HTTP 請求並且順利收到回應的話，需要確保 Server 端有加上Access-Control-Allow-Origin，不然 Response 會被瀏覽器給擋下來並且顯示出錯誤訊息。 Preflight Request還記得 Twitch 的 API 文件嗎？裡面需要帶一個client-id的參數，而文件裡面寫說你可以帶在 GET 的參數上面，也可以帶在 Header 裡，我們來試試看帶在 Header 裡會怎樣吧！打開 Devtool，你會看到一個神奇的現象： 咦？我明明只發了一個 Request，怎麼變兩個了？而且第一個的 Method 居然是OPTIONS。只是多加了一個 Header 就多了一個 Request，是為什麼呢？ 其實這又跟上面講的 CORS 有關了，CORS 把 Request 分成兩種，一種是簡單請求（simple requests）。什麼是簡單請求呢？其實定義有滿長一串的，我認為有需要用到的時候再看就好，但總之如果你沒有加任何自定義的 Header，而且又是 GET 的話，絕對是簡單請求（這個夠簡單了吧） 反之呢，如果你有加一些自定義的 Header，例如說我們剛剛加的Client-ID，這個 Request 就絕對不是簡單請求。 （定義可參考：MDN: 簡單請求） 從上述分類可知，我們剛剛發起的 Request 因為有帶了 Custom header，所以不會是簡單請求，那為什麼會多一個 Request 呢？ 這一個 Request 叫做 Preflight Request，中文翻作「預檢請求」，因為非簡單請求可能會帶有一些使用者資料，因此會先透過 Preflight Request 去確認後續的請求能否送出。 如果這個 Preflight Request 沒有過的話，真的 Request 也就不會發送了，這就是預檢請求的目的。 我舉一個例子，你就會知道為什麼需要這個 Preflight Request 了。 假設今天某個 Server 提供了一個 API 網址叫做：https://example.com/data/16，你只要對它發送 GET，就能夠拿到 id 是 16 的資料，只要對它發送 DELETE，就可以把這筆資料刪除。 如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。 因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。 如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。 先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。 JSONP最後來講一下 JSONP，這是跨來源請求除了 CORS 以外的另外一種方法，全名叫做：JSON with Padding。 還記得一開始提到的同源政策吧？仔細思考一下會發現，其實有些東西是不受同源政策限制的，例如說&lt;script&gt;這個 Tag，我們不是常常引用 CDN 或是 Google Analytics 之類的第三方套件嗎？網址都是其他 Domain 的，但是卻能正常載入。 JSONP 就是利用&lt;script&gt;的這個特性來達成跨來源請求的。 今天先想像你有一段 HTML 長這樣： &lt;script> var response = &#123; data: 'test' &#125;; &lt;/script> &lt;script> console.log(response); &lt;/script> 很好懂的一段程式碼，我就不多做解釋了。那如果今天把上面那一段換成一串網址呢？ &lt;script src=\"https://another-origin.com/api/games\">&lt;/script> &lt;script> console.log(response); &lt;/script> 如果https://another-origin.com/api/games這個網址返回的內容就是剛剛的： var response = &#123; data: 'test' &#125;; 那我不就一樣可以拿到資料了嗎？而且這些資料還是 Server 端控制的，所以 Server 可以給我任何資料。但是這樣用全域變數其實不太好，我們可以借用剛剛的 Callback Function 的概念，改成這樣： &lt;script> receiveData(&#123; data: 'test' &#125;); &lt;/script> &lt;script> function receiveData (response) &#123; console.log(response); &#125; &lt;/script> 所以 JSONP 是什麼？JSONP 其實就是透過上面這種形式，利用&lt;script&gt;裡面放資料，透過指定好的 function 把資料給帶回去。你只要把第一段的&lt;script&gt;那邊想成是 Server 的回傳值，你就可以理解了。 實務上在操作 JSONP 的時候，Server 通常會提供一個callback的參數讓 client 端帶過去。Twitch API 有提供 JSONP 的版本，我們可以直接來看範例： URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=aaa&amp;limit=1 aaa(&#123;\"_total\":1069,\"_links\":&#123;\"self\":\"https://api.twitch.tv/kraken/games/top?limit=1\",\"next\":\"https://api.twitch.tv/kraken/games/top?limit=1\\u0026offset=1\"&#125;,\"top\":[&#123;\"game\":&#123;\"name\":\"Dota 2\",\"popularity\":63361,\"_id\":29595,\"giantbomb_id\":32887,\"box\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"logo\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"_links\":&#123;&#125;,\"localized_name\":\"Dota 2\",\"locale\":\"zh-tw\"&#125;,\"viewers\":65243,\"channels\":373&#125;]&#125;) URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1 receiveData(&#123;\"_total\":1067,\"_links\":&#123;\"self\":\"https://api.twitch.tv/kraken/games/top?limit=1\",\"next\":\"https://api.twitch.tv/kraken/games/top?limit=1\\u0026offset=1\"&#125;,\"top\":[&#123;\"game\":&#123;\"name\":\"Dota 2\",\"popularity\":63361,\"_id\":29595,\"giantbomb_id\":32887,\"box\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"logo\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"_links\":&#123;&#125;,\"localized_name\":\"Dota 2\",\"locale\":\"zh-tw\"&#125;,\"viewers\":65622,\"channels\":376&#125;]&#125;) 有發現了嗎？它就是透過你帶過去的callback這個參數當作函式名稱，把 JavaScript 物件整個傳到 Function 裡面，你就可以在 Function 裡面拿到資料。 結合起來會變這樣： &lt;script src=\"https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1\">&lt;/script> &lt;script> function receiveData (response) &#123; console.log(response); &#125; &lt;/script> 利用 JSONP，也可以存取跨來源的資料。但 JSONP 的缺點就是你要帶的那些參數永遠都只能用附加在網址上的方式（GET）帶過去，沒辦法用 POST。 如果能用 CORS 的話，還是應該優先考慮 CORS。 總結今天這篇文章的內容就是從抓資料這件事情開始，一步步告訴你應該去哪裡抓？應該怎麼抓？用 API 抓，那什麼是 API？怎麼在 JavaScript 裡面呼叫 Web API？怎麼樣存取跨來源的資料？ 一般來說，跟前端抓資料有關的東西我基本上都提到了，不過有個遺珠之憾是沒有提到Fetch API，這是比較新的標準，也是拿來抓資料用的，MDN 上面的介紹是： The Fetch API provides an interface for fetching resources (including across the network). It will seem familiar to anyone who has used XMLHttpRequest, but the new API provides a more powerful and flexible feature set. 有興趣的讀者們可以自己去看一下。 希望大家看完這篇之後，會更了解怎麼樣串接後端 API，以及串接的時候可能會碰到哪些困難。","link":"/2017/08/27/ajax-and-cors/"},{"title":"Webpack 中的 sideEffects 该怎么用","text":"webpack v4 开始新增了一个 sideEffects 特性，通过给 package.json 加入 sideEffects 声明该 包&#x2F;模块 是否包含 sideEffects(副作用)，从而可以为 tree-shaking 提供更大的优化空间。 基于我们对 side effect 的常规理解，我们可以认为，只要我们确定当前包里的模块不包含副作用，然后将发布到 npm 里的包标注为 sideEffects: false ，我们就能为使用方提供更好的打包体验。原理是 webpack 能将标记为 side-effects-free 的包由 import &#123;a&#125; from xx 转换为 import &#123;a&#125; from &#39;xx/a&#39;，从而自动修剪掉不必要的 import，作用同 babel-plugin-import。 Tree Shaking 与副作用Tree-Shaking在前端界由rollup首先提出并实现，后续webpack在2.x版本也借助于UglifyJS实现了。自那以后，在各类讨论优化打包的文章中，都能看到Tree-Shaking的身影。 Tree-Shaking的原理ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。 分析程序流，判断哪些变量未被使用、引用，进而删除此代码。 很好，原理非常完美，那为什么有时候我们项目里面多余的的代码又删不掉呢？ 先说原因：都是副作用的锅！ 副作用了解过函数式编程的同学对副作用这词肯定不陌生。它大致可以理解成：一个函数会、或者可能会对函数外部变量产生影响的行为。 举个例子，比如这个函数： function go (url) &#123; window.location.href = url &#125; 这个函数修改了全局变量location，甚至还让浏览器发生了跳转，这就是一个有副作用的函数。 // componetns.js export class Person &#123; constructor (&#123; name &#125;) &#123; this.className = 'Person' this.name = name &#125; getName () &#123; return this.name &#125; &#125; export class Apple &#123; constructor (&#123; model &#125;) &#123; this.className = 'Apple' this.model = model &#125; getModel () &#123; return this.model &#125; &#125; // main.js import &#123; Apple &#125; from './components' const appleModel = new Apple(&#123; model: 'IphoneX' &#125;).getModel() console.log(appleModel) 很显然这个Person类是无用的代码 而为什么有时候别的工具，比如rollup在线repl尝试了下tree-shaking，也确实删掉了无用的代码 而使用webpack打包工具却不能进行有效的代码消除呢？ 答案是：babel编译 + webpack打包 在这边贴一个链接，是有关于详细介绍babel编译 + webpack打包是怎么让你无效的代码消除不掉的。你的Tree-Shaking并没什么卵用 如果不想看文章的话，这边直接简单说一下原理：babel编译会使得Person类被封装成了一个IIFE(立即执行函数)，然后返回一个构造函数，在这边就产生了一个副作用。 这边有个Issues，IIFE 中的类声明被视为副作用 当我在 IIFE 中声明一个类，但没有使用类时，它不会被 UglifyJS 剥离，因为它被认为是副作用。 var V6Engine = (function () &#123; function V6Engine() &#123; &#125; V6Engine.prototype.toString = function () &#123; return 'V6'; &#125;; return V6Engine; &#125;()); 编译时收到这样的警告：WARN: Side effects in initialization of unused variable V6Engine [./dist/car.bundle.js:74,4] 下面给出的回复：Uglify 没做执行程序流分析。它并不会因为你注意到的副作用而删除代码。你要是想弄个完善一点的摇树，去隔壁rollup呗！ issue中总结下几点关键信息： 函数的参数若是引用类型，对于它属性的操作，都是有可能会产生副作用的。因为首先它是引用类型，对它属性的任何修改其实都是改变了函数外部的数据。其次获取或修改它的属性，会触发getter或者setter，而getter、setter是不透明的，有可能会产生副作用。 uglify没有完善的程序流分析。它可以简单的判断变量后续是否被引用、修改，但是不能判断一个变量完整的修改过程，不知道它是否已经指向了外部变量，所以很多有可能会产生副作用的代码，都只能保守的不删除。 rollup有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。 但这已经是很久之前的版本问题，现在的webpack tree shaking已经做了很多的优化，足够的程序流分析进行tree shaking webpack 的 tree shaking 的作用是可以将未被使用的 exported member 标记为 unused 同时在将其 re-export 的模块中不再 export。说起来很拗口，看代码： // a.js export function a() &#123;&#125; // b.js export function b()&#123;&#125; // package/index.js import a from './a' import b from './b' export &#123; a, b &#125; // app.js import &#123;a&#125; from 'package' console.log(a) 当我们以 app.js 为 entry 时，经过摇树后的代码会变成这样： // a.js export function a() &#123;&#125; // b.js 不再导出 function b()&#123;&#125; function b() &#123;&#125; // package/index.js 不再导出 b 模块 import a from './a' import './b' export &#123; a &#125; // app.js import &#123;a&#125; from 'package' console.log(a) 配合 webpack 的 scope hoisting 和 uglify 之后，b 模块的痕迹会被完全抹杀掉。 但是如果 b 模块中添加了一些副作用，比如一个简单的 log： // b.js export function b(v) &#123; reutrn v &#125; console.log(b(1)) webpack 之后会发现 b 模块内容变成了： // b.js console.log(function (v)&#123;return v&#125;(1)) 虽然 b 模块的导出是被忽略了，但是副作用代码被保留下来了。 由于目前 transformer 转换后可能引入的各种奇怪操作引发的副作用，很多时候我们会发现就算有了 tree shaking 我们的 bundle size 还是没有明显的减小。 而通常我们期望的是 b 模块既然不被使用了，其中所有的代码应该不被引入才对。 这个时候 sideEffects 的作用就显现出来了：如果我们引入的 包&#x2F;模块 被标记为 sideEffects: false 了，那么不管它是否真的有副作用，只要它没有被引用到，整个 模块&#x2F;包 都会被完整的移除。 以 mobx-react-devtool 为例，我们通常这样去用： import DevTools from 'mobx-react-devtools'; class MyApp extends React.Component &#123; render() &#123; return ( &lt;div> ... &#123; process.env.NODE_ENV === 'production' ? null : &lt;DevTools /> &#125; &lt;/div> ); &#125; &#125; 这是一个很常见的按需导入场景，然而在没有 sideEffects: false 配置时，即便 NODE_ENV 设为 production ，打包后的代码里依然会包含 mobx-react-devtools 包，虽然我们没使用过其导出成员，但是 mobx-react-devtools 还是会被 import，因为里面“可能”会有副作用。 但当我们加上 sideEffects false 之后，tree shaking 就能安全的把它从 bundle 里完整的移除掉了。 sideEffects 的使用场景上面也说到，通常我们发布到 npm 上的包很难保证其是否包含副作用（可能是代码的锅可能是 transformer 的锅），但是我们基本能确保这个包是否会对包以外的对象产生影响，比如是否修改了 window 上的属性，是否复写了原生对象方法等。如果我们能保证这一点，其实我们就能知道整个包是否能设置 sideEffects: false了，至于是不是真的有副作用则并不重要，这对于 webpack 而言都是可以接受的。 这也就能解释为什么能给 vue 这个本身充满副作用的包加上 sideEffects: false 了。 所以其实 webpack 里的 sideEffects: false 的意思并不是我这个模块真的没有副作用，而只是为了在摇树时告诉 webpack：我这个包在设计的时候就是期望没有副作用的，即使他打完包后是有副作用的。","link":"/2023/10/27/Webpack-optimization-3/"},{"title":"一文读懂什么是Hadoop","text":"Hadoop是什么？Hadoop是一个由Apache基金会所开发的分布式系统基础架构，是一个存储系统+计算框架的软件框架。主要解决海量数据存储与计算的问题，是大数据技术中的基石。Hadoop以一种可靠、高效、可伸缩的方式进行数据处理，用户可以在不了解分布式底层细节的情况下，开发分布式程序，用户可以轻松地在Hadoop上开发和运行处理海量数据的应用程序。 Hadoop能解决什么问题 海量数据存储 HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（High throughput）来访问数据，适合那些有着超大数据集（large data set）的应用程序,它由n台运行着DataNode的机器组成和1台（另外一个standby）运行NameNode进程一起构成。每个DataNode 管理一部分数据，然后NameNode负责管理整个HDFS 集群的信息（存储元数据）。 资源管理，调度和分配 Apache Hadoop YARN（Yet Another Resource Negotiator，另一种资源协调者）是一种新的 Hadoop 资源管理器，它是一个通用资源管理系统和调度平台，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。 Hadoop的由来 Hadoop的核心架构Hadoop的核心，说白了，就是HDFS和MapReduce。HDFS为海量数据提供了存储，而MapReduce为海量数据提供了计算框架。 HDFS 整个HDFS有三个重要角色：NameNode（名称节点）、DataNode（数据节点）和Client（客户机）。 典型的主从架构，用TCP&#x2F;IP通信 NameNode：是Master节点（主节点），可以看作是分布式文件系统中的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等。NameNode会将文件系统的Meta-data存储在内存中，这些信息主要包括了文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode的信息等。 DataNode：是Slave节点（从节点），是文件存储的基本单元，它将Block存储在本地文件系统中，保存了Block的Meta-data，同时周期性地将所有存在的Block信息发送给NameNode。 Client：切分文件；访问HDFS；与NameNode交互，获得文件位置信息；与DataNode交互，读取和写入数据。 还有一个Block（块）的概念：Block是HDFS中的基本读写单元；HDFS中的文件都是被切割为block（块）进行存储的；这些块被复制到多个DataNode中；块的大小（通常为64MB）和复制的块数量在创建文件时由Client决定。 MapReduceMapReduce是一种分布式计算模型，它将大规模数据集（大于1TB）分成许多小数据块，然后在集群中的各个节点上进行并行处理，最后将结果汇总。MapReduce的计算过程可以分为两个阶段：Map阶段和Reduce阶段。 Map阶段：将输入数据切分成若干个小数据块，然后由多个Map任务并行处理，每个Map任务将处理结果输出为若干个键值对。 Reduce阶段：将Map阶段的输出结果按照键值对中的键进行分组，然后由多个Reduce任务并行处理，每个Reduce任务将处理结果输出为若干个键值对。 总结Hadoop是一个分布式系统基础架构，主要解决海量数据存储与计算的问题。它的核心是HDFS和MapReduce，其中HDFS为海量数据提供了存储，而MapReduce为海量数据提供了计算框架。除此之外，Hadoop还有一个重要的组件——YARN，它是一个通用资源管理系统和调度平台，可为上层应用提供统一的资源管理和调度。","link":"/2023/11/08/hadoop-1/"},{"title":"hadoop之MapReduce工作原理","text":"MapReduce 定义MapReduce 是一个分布式运算程序的编程框架，是用户开发“基于hadoop的数据分析应用”的核心框架，其核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个hadoop集群上。 MapReduce 产生缘由为什么需要MapReduce？ 海量数据在单机上处理因为硬件资源限制，无法胜任。 而一旦将单机版程序扩展到集群来分布式运行，将极大增加程序的复杂度和开发难度。 引入MapReduce框架后，开发人员可以将绝大部分工作集中在业务逻辑的开发上，而将分布式计算中的复杂性交由框架来处理。 设想一个海量数据场景下的wordcount需求： 单机版：内存受限，磁盘受限，运算能力受限 分布式：文件分布式存储（HDFS）、运算逻辑需要至少分成2个阶段（一个阶段独立并发，一个阶段汇聚）、运算程序如何分发、程序如何分配运算任务（切片）、两阶段的程序如何启动？如何协调？、整个程序运行过程中的监控？容错？重试？ 可见在程序由单机版扩成分布式时，会引入大量的复杂工作。 MapReduce与Yarn的关系Yarn 是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台。而MapReduce等运算程序则相当于运行于操作系统之上的应用程序。 YARN的重要概念： yarn并不清楚用户提交的程序的运行机制； yarn只提供运算资源的调度（用户程序向yarn申请资源，yarn就负责分配资源）； yarn中的主管角色叫ResourceManager； yarn中具体提供运算资源的角色叫NodeManager； 这样一来，yarn其实就与运行的用户程序完全解耦，就意味着yarn上可以运行各种类型的分布式运算程序（MapReduce只是其中的一种），比如MapReduce、storm程序，spark程序，tez……； 所以，spark、storm等运算框架都可以整合在yarn上运行，只要他们各自的框架中有符合yarn规范的资源请求机制即可； Yarn就成为一个通用的资源调度平台，从此，企业中以前存在的各种运算集群都可以整合在一个物理集群上，提高资源利用率，方便数据共享。 MapReduce 工作原理严格说起来MapReduce并不是一种算法， 而是一个计算思想。它由map和reduce两个阶段组成。 MapReduce 进程为了提高开发效率，可以将分布式程序中的公共功能封装成框架，让开发人员可以将精力集中于业务逻辑。 而MapReduce就是这样一个分布式程序的通用框架，整体结构如下（在分布式运行时有三类实例进程）： MRAppMaster：负责整个程序的过程调度及状态协调 MapTask：负责map阶段的整个数据处理流程 ReduceTask：负责reduce阶段的整个数据处理流程 MapReduce 运行机制 流程描述如下： 一个MR程序启动的时候，最先启动的是MRAppMaster，MRAppMaster启动后根据本次job的描述信息，计算出需要的MapTask实例数量，然后向集群申请机器启动相应数量的MapTask进程； MapTask进程启动之后，根据给定的数据切片范围进行数据处理，主体流程为： 利用客户指定的inputformat来获取RecordReader读取数据，形成输入KV对； 将输入KV对传递给客户定义的map()方法，做逻辑运算，并将map()方法输出的KV对收集到缓存； 将缓存中的KV对按照K分区排序后不断溢写到磁盘文件。 MRAppMaster监控到所有MapTask进程任务完成之后，会根据客户指定的参数启动相应数量的ReduceTask进程，并告知ReduceTask进程要处理的数据范围（数据分区）； ReduceTask进程启动之后，根据MRAppMaster告知的待处理数据所在位置，从若干台MapTask运行所在机器上获取到若干个MapTask输出结果文件，并在本地进行重新归并排序，然后按照相同key的KV为一个组，调用客户定义的reduce()方法进行逻辑运算，并收集运算输出的结果KV，然后调用客户指定的outputformat将结果数据输出到外部存储。 我们来举个例子。 上图是一个统计词频的任务。 Hadoop将输入数据切成若干个分片，并将每个split（分割）交给一个map task（Map任务）处理。 Mapping之后，相当于得出这个task里面，每个词以及它出现的次数。 shuffle（拖移）将相同的词放在一起，并对它们进行排序，分成若干个分片。 根据这些分片，进行reduce（归约）。 统计出reduce task的结果，输出到文件。 在MapReduce里，为了完成上面这些过程，需要两个角色：JobTracker和TaskTracker。 JobTracker用于调度和管理其它的TaskTracker。JobTracker可以运行于集群中任一台计算机上。TaskTracker 负责执行任务，必须运行于 DataNode 上。 在整个Hadoop架构中，计算框架起到承上启下的作用，一方面可以操作HDFS中的数据，另一方面可以被封装，提供Hive、Pig这样的上层组件的调用。 我们简单介绍一下其中几个比较重要的组件。 HBase：来源于Google的BigTable；是一个高可靠性、高性能、面向列、可伸缩的分布式数据库。 Hive：是一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 Pig：是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算。 ZooKeeper：来源于Google的Chubby；它主要是用来解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度。 Ambari：Hadoop管理工具，可以快捷地监控、部署、管理集群。 Sqoop：用于在Hadoop与传统的数据库间进行数据的传递。 Mahout：一个可扩展的机器学习和数据挖掘库。 Hadoop的优点和应用 总的来看，Hadoop有以下优点： 高可靠性：这个是由它的基因决定的。它的基因来自Google。Google最擅长的事情，就是“垃圾利用”。Google起家的时候就是穷，买不起高端服务器，所以，特别喜欢在普通电脑上部署这种大型系统。虽然硬件不可靠，但是系统非常可靠。 高扩展性：Hadoop是在可用的计算机集群间分配数据并完成计算任务的，这些集群可以方便地进行扩展。说白了，想变大很容易。 高效性：Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。 高容错性：Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。这个其实也算是高可靠性。 低成本：Hadoop是开源的，依赖于社区服务，使用成本比较低。 基于这些优点，Hadoop适合应用于大数据存储和大数据分析的应用，适合于服务器几千台到几万台的集群运行，支持PB级的存储容量。 Hadoop的应用非常广泛，包括：搜索、日志处理、推荐系统、数据分析、视频图像分析、数据保存等，都可以使用它进行部署。","link":"/2023/11/08/hadoop-2/"},{"title":"JIT (just-in-time) compiler 是怎么工作的","text":"引言在谈到JIT前，还是需要对编译过程有一些简单的了解。 在编译原理中，把源代码翻译成机器指令，一般要经过以下几个重要步骤： JIT简介JIT是just in time的缩写，也就是即时编译。 通过JIT技术，能够做到Java程序执行速度的加速。那么，是怎么做到的呢？ 我们都知道，Java是一门解释型语言（或者说是半编译，半解释型语言）。Java通过编译器javac先将源程序编译成与平台无关的Java字节码文件（.class），再由JVM解释执行字节码文件，从而做到平台无关。 但是，有利必有弊。对字节码的解释执行过程实质为：JVM先将字节码翻译为对应的机器指令，然后执行机器指令。很显然，这样经过解释执行，其执行速度必然不如直接执行二进制字节码文件。 而为了提高执行速度，便引入了 JIT 技术。当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code）。然后JIT会把部分“热点代码”编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。 Hot Spot编译当 JVM 执行代码时，它并不是立即开始编译代码的。这主要有两个原因： 首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。 当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能 ，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。 第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。 JavaScript 编译 - JIT (just-in-time) compiler 是怎么工作的大体来说，有两种方式可以将程序翻译成机器可执行的指令，使用编译器 (Compiler) 或者是 解释器 (Interpreter)。 解释器解释器是边翻译，边执行。 优缺点 优点：快速执行，不需要等待编译 缺点：相同的代码可能被翻译多次，比如循环内部的代码 编译器而编译器则是提前将结果翻译出来，并生成一个可执行程序。 优缺点 优点：不需要重复编译，并且可以在编译时对代码做优化 缺点：需要提前编译 JITJavaScript 刚出现的时候，是一个典型的解释型语言，因此运行速度极慢，后来浏览器引入了 JIT compiler，大幅提高了 JavaScript 的运行速度。 原理：They added a new part to the JavaScript engine, called a monitor (aka a profiler). That monitor watches the code as it runs, and makes a note of how many times it is run and what types are used. 简单来说，浏览器在 JavaScript engine 中加入了一个 monitor，用来观察运行的代码。并记录下每段代码运行的次数和代码中的变量的类型。 那么问题来了，为什么这样做能提高运行速度？ 后面的所有内容都以下面这个函数的运行为例： function arraySum(arr) &#123; var sum = 0; for (var i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; &#125; 1st step - Interpreter 一开始只是简单的使用解释器执行，当某一行代码被执行了几次，这行代码会被打上 Warm 的标签；当某一行代码被执行了很多次，这行代码会被打上 Hot 的标签 2nd step - Baseline compiler 被打上 Warm 标签的代码会被传给Baseline Compiler编译且储存，同时按照行数 (Line number) 和变量类型 (Variable type) 被索引（为什么会引入变量类型做索引很重要，后面会讲） 当发现执行的代码命中索引，会直接取出编译后的代码执行，从而不需要重复编译已经编译过的代码 3rd step - Optimizing compiler 被打上 Hot 标签的代码会被传给 Optimizing compiler，这里会对这部分带码做更优化的编译。怎么样做更优化的编译呢？关键点就在这里，没有别的办法，只能用概率模型做一些合理的 假设 (Assumptions)。比如我们上面的循环中的代码 sum +&#x3D; arr[i]，尽管这里只是简单的 + 运算和赋值，但是因为 JavaScript 的动态类型 (Dynamic typing)，对应的编译结果有很多种可能（这个角度能很明显的暴露动态类型的缺点） 比如: sum 是 Int，arr 是 Array，i 是 Int，这里的 + 就是加法运算，对应其中一种编译结果 sum 是 string，arr 是 Array，i 是 Int，这里的 + 就是字符串拼接，并且需要把 i 转换为 string 类型… 下面的图可以看出，这么简单的一行代码对应有 2^4 &#x3D; 16 种可能的编译结果 前面第二步的 Baseline compiler 做的就是这件事，所以上面说编译后的代码需要使用line number和variable type一起做索引，因为不同的 variable type 对应不同的编译结果。 如果代码是 “Warm” 的，JIT 的任务也就到此为止，后面每次执行的时候，需要先判断类型，再使用对应类型的编译结果就好。 但是上面我们说，当代码变成 “hot” 的时候，会做更多的优化。这里的优化其实指的就是 JIT 直接假设一个前提，比如这里我们直接假设 sum 是 Int，i 也是 Int，arr 是 Array，于是就只用一种编译结果就好了。 实际上，在执行前会做类型检查，看是假设是否成立，如果不成立执行就会被打回interpreter或者baseline compiler的版本，这个操作叫做 &quot;反优化 (deoptimization)&quot;。 可以看出，只要假设的成功率足够高，那么代码的执行速度就会快。但是如果假设的成功率很低，那么会导致比没有任何优化的时候还要慢（因为要经历optimize =&gt; deoptimize的过程） 结论简而言之，这就是 JIT运行时所做的事情。它通过监控正在运行的代码并发送要优化的热代码路径，使 JavaScript 运行得更快。这使得大多数 JavaScript 应用程序的性能提高了许多倍。 然而，即使有了这些改进，JavaScript 的性能仍然无法预测。为了使速度更快，JIT 在运行时增加了一些开销，包括： 优化和反优化 用于监视器和发生信息丢失时恢复信息的内存 用于存储函数的基线和优化版本的内存 这里还有改进的空间：可以消除开销，使性能更加可预测。","link":"/2023/11/04/just-in-time-compilers/"},{"title":"构建工具之Rspack和Vite","text":"试了试把真实项目从 Vite 迁移到 Rspack，Build 速度从 125 秒缩短到了 17 秒，开发中刷新页面的速度也提升了 64 %，不过 HMR 时间比 Vite 慢多了。 如果开发过程中触发 HMR 比较多，而刷新页面比较少，Vite 还是有开发体验的优势。如果是复杂项目，刷新页面更常用，那 Rspack 的开发体验反而会更好。 前端构建的工具实在是太多了，rolldown、rollup、Rspack、Vite…… 先提前插个眼","link":"/2023/10/27/pack-tool-preview/"},{"title":"vue-Proxy和Reflect","text":"引言既然 Vue.js 3 的响应式数据是基于 Proxy 实现的，那么我们就有必要了解 Proxy 以及与之相关联的 Reflect。什么是 Proxy 呢？简单地说，使用 Proxy 可以创建一个代理对象。它能够实现对其他对象的代理，这里的关键词是其他对象，也就是说，Proxy 只能代理对象，无法代理非对象值，例如字符串、布尔值等。那么，代理指的是什么呢？所谓代理，指的是对一个对象基本语义的代理。它允许我们拦截并重新定义对一个对象的基本操作。 创建对象代理 Proxy 内置的对象 Reflect 当我们讨论编程语言中的”基本语义”时，我们指的是对数据进行读取和修改的最基本操作。在JavaScript中，这些操作通常包括读取属性值和设置属性值。例如，在给定一个对象obj的情况下，以下操作被认为是基本语义的操作： 读取属性值：obj.foo （读取属性foo的值） 设置属性值：obj.foo = newValue （设置属性foo的值） 在上述代码中，Proxy对象允许我们拦截（或者说重定义）这些基本语义的操作。Proxy的构造函数接受两个参数：被代理的对象和一个包含拦截器（也称为夹子或陷阱）的对象。在拦截器对象中，我们可以定义get方法来拦截读取属性操作，定义set方法来拦截设置属性操作。这样，我们就可以在这些操作发生时执行自定义的逻辑。 关于Reflect对象，它是JavaScript的一个全局对象，提供了与Proxy拦截器方法一一对应的方法。这些Reflect方法提供了默认的操作行为。例如，Reflect.get(target, key)方法提供了访问对象属性的默认行为，与直接使用target[key]是等价的。同时，Reflect方法还可以接受第三个参数，用来指定函数调用时的this值。 理解这些基本语义操作以及如何使用Proxy和Reflect来拦截和处理这些操作，是理解JavaScript中响应式数据（Reactive Data）实现的关键。在响应式数据中，我们可以利用Proxy和Reflect来追踪对象属性的读取和修改，从而实现数据的响应式更新。 Proxy 的基本用法当我们谈论基本语义时，我们指的是 JavaScript 中的一些基本操作，比如读取对象属性值和设置对象属性值。考虑下面的对象 obj： const obj = &#123; foo: 1 &#125;; 在这里，obj.foo 是一个读取属性的基本语义操作，obj.foo = newValue 是一个设置属性的基本语义操作。 现在，我们可以使用 Proxy 来拦截这些基本语义的操作。 const handler = &#123; get(target, key) &#123; console.log(`读取属性 $&#123;key&#125;`); return target[key]; &#125;, set(target, key, value) &#123; console.log(`设置属性 $&#123;key&#125; 为 $&#123;value&#125;`); target[key] = value; &#125; &#125;; const proxyObj = new Proxy(obj, handler); proxyObj.foo; // 输出：读取属性 foo proxyObj.foo = 2; // 输出：设置属性 foo 为 2 在上面的代码中，我们创建了一个 handler 对象，其中定义了 get 和 set 方法，用来拦截属性的读取和设置。然后，我们使用 Proxy 构造函数创建了一个代理对象 proxyObj，它会拦截 obj 对象上的读取和设置操作。当我们访问 proxyObj.foo 时，会触发 get 方法，输出相应的信息。当我们设置 proxyObj.foo 的值时，会触发 set 方法，同样输出相应的信息。 这样，Proxy 允许我们在基本语义操作发生时执行自定义的逻辑，而不需要直接操作原始对象。在实际应用中，这种能力可以用来实现响应式数据、数据验证、日志记录等功能。 当我们使用 Proxy 拦截对象属性的读取操作时，我们需要特别注意访问器属性（accessor properties）的情况，因为访问器属性使用 getter 函数来定义，而这个函数内部的 this 关键字会根据调用方式而变化。 Reflect 在响应式中的用法在拦截器函数中，我们希望建立副作用函数与响应式数据之间的关联，确保当属性被访问时，能够正确地进行依赖收集，以便在属性发生变化时触发副作用函数的重新执行。然而，如果我们直接使用 target[key] 来获取属性值，那么访问器属性内部的 this 关键字将指向原始对象，而不是代理对象，这会导致无法正确建立响应关系。 解决这个问题的方法是使用 Reflect.get(target, key, receiver) 来代替 target[key]。这样，Reflect.get 的第三个参数 receiver 就能正确地指向代理对象，而不是原始对象。这样一来，在访问器属性的 getter 函数内部，this 关键字就会指向代理对象，从而建立了正确的响应关系。 以下是使用 Reflect.get 的修正代码： const handler = &#123; get(target, key, receiver) &#123; track(target, key); // 响应式数据依赖收集 return Reflect.get(target, key, receiver); // 使用 Reflect.get 获取属性值 &#125;, // 其他拦截器方法... &#125;; const proxyObj = new Proxy(obj, handler); effect(() => &#123; console.log(proxyObj.bar); // 在副作用函数内部访问 bar 属性 &#125;); proxyObj.foo++; // 触发副作用函数的重新执行 我们可以再看一个简单一点的示例： 当使用代理对象时，receiver参数主要用于确保在代理的拦截函数内部，this指向代理对象，从而建立响应式联系。下面我将对比使用receiver参数和不使用的情况，以便更清楚地理解它的作用。 1. 使用receiver参数的情况：const data = &#123; foo: 1 &#125;; const proxy = new Proxy(data, &#123; get(target, key, receiver) &#123; // 使用 Reflect.get 保证 this 指向代理对象 const result = Reflect.get(target, key, receiver); // 在实际应用中，你可能还需要进行其他处理，例如触发更新操作等 console.log(`Accessed $&#123;key&#125; property with value $&#123;result&#125;`); return result; &#125; &#125;); console.log(proxy.foo); // 输出: Accessed foo property with value 1 在这个例子中，我们使用了receiver参数传递给Reflect.get，确保在get拦截函数内部，this指向代理对象proxy。当你访问proxy.foo时，get拦截函数被触发，并且this指向proxy对象。 2. 不使用receiver参数的情况：const data = &#123; foo: 1 &#125;; const proxy = new Proxy(data, &#123; get(target, key) &#123; // 不使用 receiver 参数，this 指向原始对象 data const result = target[key]; // 在实际应用中，你可能还需要进行其他处理，例如触发更新操作等 console.log(`Accessed $&#123;key&#125; property with value $&#123;result&#125;`); return result; &#125; &#125;); console.log(proxy.foo); // 输出: Accessed foo property with value 1 在这个例子中，我们没有使用receiver参数。由于没有传递receiver参数，this在get拦截函数内部指向的是原始对象data。虽然代理对象proxy被使用，但get拦截函数内部的this并不指向proxy，而是指向原始对象data。因此，这种情况下，响应式联系不会得到建立。 虽然说两个函数的输出是一致的，但显然没有使用receiver参数时响应式联系不会得到建立。也就是说在effect函数里面，对象不会得到正确的响应。","link":"/2023/11/01/vue-Proxy-and-Reflect/"},{"title":"嵌套的 effect 与 effect 栈","text":"引言effect 副作用函数是可以发生嵌套的，至于为什么要设计成这样呢 嵌套的 effecteffect(function effectFn1() &#123; effect(function effectFn2() &#123; /* ... */ &#125;) /* ... */ &#125;) 在上面这段代码中，effectFn1 内部嵌套了 effectFn2，effectFn1 的执行会导致 effectFn2 的执行。那么，什么场景下会出现嵌套的 effect 呢？拿 Vue.js 来说，实际上 Vue.js 的渲染函数就是在一个 effect 中执行的. 当组件发生嵌套时，例如 Foo 组件渲染了 Bar 组件： // Bar 组件 const Bar = &#123; render() &#123;/* ... */ &#125;, &#125; // Foo 组件渲染了 Bar 组件 const Foo = &#123; render() &#123; return &lt;Bar /> &#125;// jsx 语法 &#125; 此时就发生了 effect 嵌套，它相当于： effect(() => &#123; Foo.render() // 嵌套 effect(() => &#123; Bar.render()&#125; )&#125; ) effect函数可以嵌套使用，也就是说，一个effect函数内部可以包含另一个effect函数。当外部effect函数依赖于内部effect函数创建的响应式数据时，内部effect函数会被自动追踪，确保外部effect函数在内部effect函数发生变化时得以执行。 这种嵌套的effect函数用于创建依赖关系链，确保当某个响应式数据变化时，所有依赖于它的effect函数都能够被触发执行，从而保持应用的响应性。 而”effect 栈”，在Vue 3的内部实现中，Vue使用了一个effect栈来追踪当前正在执行的effect函数，这个栈的作用类似于函数调用栈，用于管理effect函数的执行顺序和依赖关系。 现在有一个不使用栈结构的嵌套的effect函数的例子，但是他并不能实现嵌套的功能。假设我们有两个响应式数据count1和count2，其中count2的值依赖于count1的值。我们可以使用嵌套的effect函数来实现这种依赖关系。 // 原始数据 const data = &#123; foo: true, bar: true &#125;; // 代理对象 const obj = new Proxy(data, &#123; get(target, key) &#123; console.log(`读取属性: $&#123;key&#125;`); return target[key]; &#125; &#125;); // 全局变量 let temp1, temp2; // effectFn1 嵌套了 effectFn2 effect(function effectFn1() &#123; console.log('effectFn1 执行'); effect(function effectFn2() &#123; console.log('effectFn2 执行'); // 在 effectFn2 中读取 obj.bar 属性 temp2 = obj.bar; &#125;); // 在 effectFn1 中读取 obj.foo 属性 temp1 = obj.foo; &#125;); effectFn1是外部的effect函数，它依赖于obj.foo的值，并且在内部包含了一个innerEffect，内部的effect函数依赖于obj.bar的值。当我们修改obj.foo时，我们希望外部的effect函数被触发执行，并且输出obj.foo的值，然后触发内部的依赖函数。当我们修改obj.bar时，内部的effect函数被触发执行，并且输出obj.bar的值。 我们用全局变量 activeEffect 来存储通过 effect 函数注册的副作用函数，这意味着同一时刻 activeEffect 所存储的副作用函数只能有一个。 // 用一个全局变量存储当前激活的 effect 函数 let activeEffect; function effect(fn) &#123; // 定义副作用函数 const effectFn = () => &#123; // 调用 cleanup 函数，具体实现需要根据需求补充 cleanup(effectFn); // 将副作用函数赋值给 activeEffect activeEffect = effectFn; // 执行副作用函数 fn(); // 将当前副作用函数的依赖集合存储在 effectFn.deps 中（需要根据实际逻辑补充） effectFn.deps = []; // 这里需要根据实际逻辑设置依赖集合 &#125;; // 执行副作用函数 effectFn(); &#125; 但其实只使用一个变量储存而不使用栈结构，当副作用函数发生嵌套时，内层副作用函数的执行会覆盖 activeEffect 的值，并且永远不会恢复到原来的值。这时如果再有响应式数据进行依赖收集，即使这个响应式数据是在外层副作用函数中读取的，它们收集到的副作用函数也都会是内层副作用函数，也就是说我在读取obj.foo的时候，activeEffect还只是innerEffect的值，并且只触发了innerEffect的效果。 为了解决这个问题，我们需要一个副作用函数栈 effectStack，在副作用函数执行时，将当前副作用函数压入栈中，待副作用函数执行完毕后将其从栈中弹出，并始终让 activeEffect 指向栈顶的副作用函数。这样就能做到一个响应式数据只会收集直接读取其值的副作用函数，而不会出现互相影响的情况： // 用一个全局变量存储当前激活的 effect 函数 let activeEffect; // effect 栈 const effectStack = []; function effect(fn) &#123; const effectFn = () => &#123; cleanup(effectFn); // 调用 cleanup 函数，具体实现需要根据需求补充 activeEffect = effectFn; // 将当前副作用函数压入栈中 effectStack.push(effectFn); fn(); // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把 activeEffect 还原为之前的值 effectStack.pop(); activeEffect = effectStack[effectStack.length - 1]; &#125;; // 初始化副作用函数的依赖集合 effectFn.deps = []; // 执行副作用函数 effectFn(); &#125;","link":"/2023/10/31/vue-effect/"},{"title":"vue-过期的副作用函数","text":"引言当我们讨论竞态问题时，通常指的是在多进程或多线程编程中出现的一种并发问题。然而，在前端开发中，我们可能较少直接面对多线程编程，但我们经常会遇到与竞态问题相似的情境。一个常见的例子是在异步编程中，特别是在处理异步事件、回调函数或者Promise时。 例如，考虑以下的异步代码： let data; function fetchData() &#123; setTimeout(() => &#123; data = 'Fetched data'; &#125;, 1000); &#125; fetchData(); console.log(data); // 输出 undefined 在这个例子中，fetchData 函数是异步的，它在1秒后将数据赋给 data 变量。但是，由于 JavaScript 是单线程的，fetchData 函数会在主线程的事件队列中等待1秒，而在这1秒内，console.log(data) 语句会立即执行，此时 data 的值为 undefined，因为 fetchData 函数还未完成执行。 在异步编程中，由于代码的非阻塞性质，会出现类似的竞态条件问题。在处理异步操作时，我们需要小心确保数据的一致性和正确性，避免在异步操作完成前就去访问或修改相关数据。 竞态问题与响应式那么竞态问题跟我们响应式有什么联系呢？ 举个例子： let finalData watch(obj, async () => &#123; // 发送并等待网络请求 const res = await fetch('/path/to/request') // 将请求结果赋值给 data finalData = res &#125;) 在这段代码中，我们使用 watch 观测 obj 对象的变化，每次 obj对象发生变化都会发送网络请求，例如请求接口数据，等数据请求成功之后，将结果赋值给 finalData 变量。观察上面的代码，乍一看似乎没什么问题。但仔细思考会发现这段代码会发生竞态问题。假设我们第一次修改 obj 对象的某个字段值，这会导致回调函数执行，同时发送了第一次请求 A。随着时间的推移，在请求 A 的结果返回之前，我们对 obj 对象的某个字段值进行了第二次修改，这会导致发送第二次请求 B。此时请求 A 和请求 B 都在进行中，那么哪一个请求会先返回结果呢？我们不确定，如果请求B 先于请求 A 返回结果，就会导致最终 finalData 中存储的是 A 请求的结果 但由于请求 B 是后发送的，因此我们认为请求 B 返回的数据才是“最新”的，而请求 A 则应该被视为“过期”的，所以我们希望变量finalData 存储的值应该是由请求 B 返回的结果，而非请求 A 返回的结果。 实际上，我们可以对这个问题做进一步总结。请求 A 是副作用函数第一次执行所产生的副作用，请求 B 是副作用函数第二次执行所产生的副作用。由于请求 B 后发生，所以请求 B 的结果应该被视为“最新”的，而请求 A 已经“过期”了，其产生的结果应被视为无效。通过这种方式，就可以避免竞态问题导致的错误结果。归根结底，我们需要的是一个让副作用过期的手段。为了让问题更加清晰，我们先拿 Vue.js 中的 watch 函数来复现场景，看看 Vue.js是如何帮助开发者解决这个问题的，然后尝试实现这个功能。 watch(obj, async (newValue, oldValue, onInvalidate) => &#123; // 定义一个标志，代表当前副作用函数是否过期，默认为 false，代表没有过期 let expired = false; // 调用 onInvalidate() 函数注册一个过期回调 onInvalidate(() => &#123; // 当过期时，将 expired 设置为 true expired = true; &#125;); // 发送网络请求 const res = await fetch('/path/to/request'); // 只有当该副作用函数的执行没有过期时，才会执行后续操作。 if (!expired) &#123; finalData = res; // 后续操作... &#125; &#125;); 如上面的代码所示，在发送请求之前，我们定义了 expired 标志变量，用来标识当前副作用函数的执行是否过期；接着调用onInvalidate 函数注册了一个过期回调，当该副作用函数的执行过期时将 expired 标志变量设置为 true；最后只有当没有过期时才采用请求结果，这样就可以有效地避免上述问题了。","link":"/2023/11/01/vue-expired-side-effects/"},{"title":"Vue.js 响应式系统的作用与实现","text":"引言响应式这一个概念应该不难理解，就是js在对某一个对象或者某一个值进行操作时，我们希望通过实现一个响应式系统达到触发某些事件，也就是对操作的相应。 响应式数据与副作用函数副作用函数指的是会产生副作用的函数，如下面的代码所示： function effect() &#123; document.body.innerText = 'hello vue3' &#125; 当 effect 函数执行时，它会设置 body 的文本内容，但除了effect 函数之外的任何函数都可以读取或设置 body 的文本内容。也就是说，effect 函数的执行会直接或间接影响其他函数的执行，这时我们说 effect 函数产生了副作用。 其实副作用函数并不少见，我们前面在讨论webpack的 tree shaking 话题里面涉及到的是否进行数据流处理对 tree shaking 的效果是不可忽略的。这边不再赘述。 副作用很容易产生，例如一个函数修改了全局变量，这其实也是一个副作用，如下面的代码所示： // 全局变量 let val = 1 function effect() &#123; val = 2 // 修改全局变量，产生副作用 &#125; 理解了什么是副作用函数，再来说说什么是响应式数据。假设在一个副作用函数中读取了某个对象的属性： const obj = &#123; text: 'hello world' &#125; function effect() &#123; // effect 函数的执行会读取 obj.text document.body.innerText = obj.text &#125; 副作用函数 effect 会设置 body 元素的 innerText 属性，其值为 obj.text，当 obj.text 的值发生变化时，我们希望副作用函数 effect 会重新执行。 那这样我们的思路就变成了：通过一些手段，在读取 obj.text 值的时候可以将effect函数储存进一个bucket里面，而在设置obj.text 值的时候可以在bucket里面把effect拿出来执行。 响应式数据的基本实现如何才能让 obj 变成响应式数据呢？通过观察我们能发现： 当副作用函数 effect 执行时，会触发字段 obj.text 的读取操作； 当修改 obj.text 的值时，会触发字段 obj.text 的设置操作。 如何拦截一个对象属性的读取和设置操作。 在 ES2015 之前，只能通过 Object.defineProperty 函数实现，这也是 Vue.js 2 所采用的方式。在 ES2015+ 中，我们可以使用代理对象 Proxy 来实现，这也是 Vue.js 3 所采用的方式。 function createReactiveObject(target, proxyMap, baseHandlers) &#123; // 核心就是 proxy // 目的是可以侦听到用户 get 或者 set 的动作 const existingProxy = proxyMap.get(target); if (existingProxy) &#123; return existingProxy; &#125; const proxy = new Proxy(target, baseHandlers); // 把创建好的 proxy 给存起来， proxyMap.set(target, proxy); return proxy; &#125; 这样我们就基于 proxy 创建了一个用于存储副作用函数，并且我们使用了一个proxyMap，这是一个可以把各类型的proxy储存起来的容器。我们分别设置了 get 和 set 拦截函数，用于拦截读取和设置操作。 设计一个完善的响应系统从上面的示例不难看出，一个响应系统的工作流程如下： 当读取操作发生时，将副作用函数收集到“桶”中； 当设置操作发生时，从“桶”中取出副作用函数并执行。 下面通过一个简单的响应式系统实现来讲解原理： 我们知道proxy对象是可以传入一个具有getter和setter的对象进行get或set操作时处理的函数，因此我们可以创建一个baseHandlers，进行getter和setter的管理。 //baseHandlers function createGetter(isReadonly = false, shallow = false) &#123; return function get(target, key, receiver) &#123; //Reflect.get方法允许你从一个对象中取属性值。就如同属性访问器语法，但却是通过函数调用来实现 const res = Reflect.get(target, key, receiver); if (!isReadonly) &#123; // 在触发 get 的时候进行依赖收集 track(target, \"get\", key); &#125; return res; &#125;; &#125; function createSetter() &#123; return function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); // 在触发 set 的时候进行触发依赖 trigger(target, \"set\", key); return result; &#125;; &#125; 我们还需要在副作用函数与被操作的目标字段之间建立明确的联系。例如当读取属性时，无论读取的是哪一个属性，其实都一样，都会把副作用函数收集到“桶”里；当设置属性时，无论设置的是哪一个属性，也都会把“桶”里的副作用函数取出并执行。副作用函数与被操作的字段之间没有明确的联系。解决方法很简单，只需要在副作用函数与被操作的字段之间建立联系即可，这就需要我们重新设计“桶”的数据结构，而不能简单地使用一个Set 类型的数据作为“桶”了。 我们通过WeakMap来实现刚才上面我们说的储存effect的bucket。不了解WeakMap类的特性的可以看下WeakMap 对象是一组键&#x2F;值对的集合 WeakMap 的键是原始对象 target，WeakMap 的值是一个Map 实例，而 Map 的键是原始对象 target 的 key，Map 的值是一个由副作用函数组成的 Set。 //Map存放不同类型的代理 export const reactiveMap = new WeakMap(); export const readonlyMap = new WeakMap(); export const shallowReadonlyMap = new WeakMap(); 定义好了上面的几种bucket，我们开始实现响应式系统最核心的部分，也就是proxy的实现： function createReactiveObject(target, proxyMap, baseHandlers) &#123; // 核心就是 proxy // 目的是可以侦听到用户 get 或者 set 的动作 const existingProxy = proxyMap.get(target); if (existingProxy) &#123; return existingProxy; &#125; const proxy = new Proxy(target, baseHandlers); // 把创建好的 proxy 给存起来， proxyMap.set(target, proxy); return proxy; &#125; 对于前面的trick和trigger： export function track(target, type, key) &#123; if (!isTracking()) &#123; return; &#125; console.log(`触发 track -> target: $&#123;target&#125; type:$&#123;type&#125; key:$&#123;key&#125;`); // 1. 先基于 target 找到对应的 dep // 如果是第一次的话，那么就需要初始化 let depsMap = targetMap.get(target); if (!depsMap) &#123; // 初始化 depsMap 的逻辑 depsMap = new Map(); targetMap.set(target, depsMap); &#125; let dep = depsMap.get(key); if (!dep) &#123; dep = createDep(); depsMap.set(key, dep); &#125; trackEffects(dep); &#125; export function trigger(target, type, key) &#123; // 1. 先收集所有的 dep 放到 deps 里面， // 后面会统一处理 let deps: Array&lt;any> = []; const depsMap = targetMap.get(target); if (!depsMap) return; // 暂时只实现了 GET 类型 // get 类型只需要取出来就可以 const dep = depsMap.get(key); // 最后收集到 deps 内 deps.push(dep); const effects: Array&lt;any> = []; deps.forEach((dep) => &#123; // 这里解构 dep 得到的是 dep 内部存储的 effect effects.push(...dep); &#125;); // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect // 这里的目前应该是为了 triggerEffects 这个函数的复用 triggerEffects(createDep(effects)); &#125;","link":"/2023/10/30/vue-reactive-1/"},{"title":"Vue-浅响应与深响应","text":"前言介绍 reactive 与 shallowReactive 的区别，即深响应和浅响应的区别。 浅响应式与深相应式const obj = reactive(&#123; foo: &#123; bar: 1 &#125; &#125;) effect(() =>&#123; console.log(obj.foo.bar) &#125;) // 修改 obj.foo.bar 的值，并不能触发响应 obj.foo.bar = 2 首先，创建 obj 代理对象，该对象的 foo 属性值也是一个对象，即 { bar: 1} 。接着，在副作用函数内访问 obj.foo.bar 的值。但是我们发现，后续对 obj.foo.bar 的修改不能触发副作用函数重新执行，这是为什么呢？来看一下现在的实现： function reactive(obj) &#123; return new Proxy(obj ,&#123; get(target, key, receiver) &#123; if (key === 'raw') return target; track(target, key); // 当读取属性值时，直接返回结果 return Reflect.get(target, key, receiver) &#125; // 省略其他拦截函数 &#125;) &#125; 由上面这段代码可知，当我们读取 obj.foo.bar 时，首先要读取 obj.foo 的值。这里我们直接使用 Reflect.get 函数返回obj.foo 的结果。由于通过 Reflect.get 得到 obj.foo 的结果是一个普通对象，即 { bar: 1} ，它并不是一个响应式对象，所以在副作用函数中访问 obj.foo.bar 时，是不能建立响应联系的。要解决这个问题，我们需要对 Reflect.get 返回的结果做一层包装: function reactive(obj) &#123; return new Proxy(obj, &#123; get(target, key, receiver) &#123; const result = Reflect.get(target, key, receiver); // If the result is an object, make it reactive if (typeof result === 'object') &#123; return reactive(result); &#125; return result; &#125;, // Other traps... &#125;); &#125; 这段代码定义了一个名为reactive的函数，该函数接收一个对象作为参数，并返回该对象的代理。这个代理使用了get陷阱函数，当我们尝试获取对象的某个属性时，这个函数就会被触发。 在get陷阱函数中，我们首先使用Reflect.get方法获取目标对象的属性值。Reflect.get方法接收三个参数：目标对象、属性名和接收器对象。在这里，接收器对象就是代理对象本身。 然后，我们检查获取的结果是否为对象。如果是对象，我们就对其进行响应式处理，即再次调用reactive函数。这样做的目的是确保嵌套的对象也具有响应式特性，也就是说，当我们修改这些嵌套对象的属性时，也能触发响应式系统。 最后，如果获取的结果不是对象，我们就直接返回结果。 浅响应式然而，并非所有情况下我们都希望深响应，这就催生了shallowReactive，即浅响应。所谓浅响应，指的是只有对象的第一层属性是响应的，例如： 例如，我们有一个对象，它的属性值也是一个对象： let obj = &#123; innerObj: &#123; key: 'value' &#125; &#125; 如果我们对obj进行深响应处理： let reactiveObj = reactive(obj); 那么，无论我们修改obj的属性，还是修改innerObj的属性，都会触发响应式系统： reactiveObj.innerObj.key = 'new value'; // 触发响应式系统 但是，如果我们只想要obj的第一层属性是响应的，也就是说，只有当我们修改obj的属性时才触发响应式系统，而修改innerObj的属性则不触发，那么我们就需要使用shallowReactive函数： let shallowReactiveObj = shallowReactive(obj); 这样，只有当我们修改obj的属性时，才会触发响应式系统： shallowReactiveObj.innerObj = &#123;&#125;; // 触发响应式系统 shallowReactiveObj.innerObj.key = 'new value'; // 不触发响应式系统 Vuejs里reactive和shallowReactive在Vue.js中，reactive和shallowReactive函数都用于创建响应式对象，这一小节来讨论下他们的不同。 reactive函数创建的是深度响应式对象。这意味着不仅对象本身，而且它内部的所有嵌套对象都会变成响应式的。无论是修改对象的属性，还是修改其嵌套对象的属性，都会触发响应式系统。 而shallowReactive函数创建的是浅层响应式对象。这意味着只有对象的顶层属性是响应式的。如果对象包含嵌套对象，那么修改这些嵌套对象的属性不会触发响应式系统。 let obj = &#123; innerObj: &#123; key: 'value' &#125; &#125; let reactiveObj = Vue.reactive(obj); reactiveObj.innerObj.key = 'new value'; // 这将触发响应式系统 let shallowReactiveObj = Vue.shallowReactive(obj); shallowReactiveObj.innerObj.key = 'new value'; // 这将不会触发响应式系统 只读和浅只读讨论完响应式和浅响应式，我们在来说下只读和浅只读： Vue.js还提供了readonly和shallowReadonly函数，它们用于创建只读的响应式对象。 readonly函数创建的是深度只读的响应式对象。这意味着不仅对象本身是只读的，而且它内部的所有嵌套对象也都是只读的。任何尝试修改对象或其嵌套对象的属性的操作都会失败。 shallowReadonly函数创建的是浅层只读的响应式对象。这意味着只有对象的顶层属性是只读的。如果对象包含嵌套对象，那么这些嵌套对象的属性是可以修改的。 let obj = &#123; innerObj: &#123; key: &#39;value&#39; &#125; &#125; let readonlyObj = Vue.readonly(obj); readonlyObj.innerObj.key = &#39;new value&#39;; // 这将失败，因为对象是只读的 let shallowReadonlyObj = Vue.shallowReadonly(obj); shallowReadonlyObj.innerObj.key = &#39;new value&#39;; // 这将成功，因为只有顶层属性是只读的","link":"/2023/11/01/vue-reactive-shallowReactive/"},{"title":"vue-renderer渲染器的原理","text":"前言在 Vue.js 中，很多功能依赖渲染器来实现，例如 Transition组件、Teleport 组件、Suspense 组件，以及 template ref 和自定义指令等。 另外，渲染器也是框架性能的核心，渲染器的实现直接影响框架的性能。Vue.js 3 的渲染器不仅仅包含传统的 Diff 算法，它还独创了快捷路径的更新方式，能够充分利用编译器提供的信息，大大提升了更新性能。 在Vue.js中，渲染器（renderer）是负责执行渲染任务的组件。在浏览器平台上，它将虚拟DOM渲染为真实DOM元素。渲染器不仅可以渲染真实DOM元素，还是框架跨平台能力的关键。在设计渲染器时，需要考虑其可自定义的能力。 渲染器的基本概念及其含义在实现一个最基本的渲染器之前，我们要先了解几个基本的概念： 在Vue.js中，渲染器（renderer）是用来执行渲染任务的组件。在浏览器平台上，它将虚拟DOM渲染为真实DOM元素。以下是渲染器的基本概念及其含义： 渲染器（Renderer）渲染器是负责将虚拟DOM（或虚拟节点）渲染为特定平台上的真实元素的组件。在浏览器平台上，渲染器会将虚拟DOM渲染为真实的DOM元素。 虚拟DOM（vnode）虚拟DOM（也称为虚拟节点，简写为vnode）是一个树型结构，类似于真实DOM，由各种节点组成。渲染器的任务是将虚拟DOM渲染为真实的DOM元素。 挂载（Mounting）挂载是指将虚拟DOM渲染为真实DOM元素并将其添加到指定的挂载点上。在Vue.js中，组件的mounted钩子函数就是在挂载完成时触发，此时可以访问到真实DOM元素。 容器（Container）容器是指用来指定挂载位置的DOM元素。渲染器会将虚拟DOM渲染为真实DOM元素并添加到指定的容器内。在渲染器的render函数中，通常会传入一个容器参数，表示将虚拟DOM挂载到哪个DOM元素上。 渲染器的创建与使用渲染器的创建通常使用createRenderer函数，该函数返回一个包含渲染和激活（hydrate）函数的对象。激活函数在同构渲染时使用，将虚拟DOM激活为已有的真实DOM元素。以下是渲染器的创建和使用示例： function createRenderer() &#123; function render(vnode, container) &#123; // 渲染逻辑 &#125; function hydrate(vnode, container) &#123; // 激活逻辑 &#125; return &#123; render, hydrate &#125;; &#125; const &#123; render, hydrate &#125; = createRenderer(); // 首次渲染 render(vnode, document.querySelector('#app')); // 同构渲染 hydrate(vnode, document.querySelector('#app')); 上面的代码片中通过createRenderer函数创建了一个渲染器对象，包含了render和hydrate函数。render函数用于将虚拟DOM渲染为真实DOM元素，而hydrate函数用于将虚拟DOM激活为已有的真实DOM元素。 好的，现在我们已经对渲染器有了一个比较基础的认识，下面来一步步深入了解一下： 渲染器的实现可以通过如下的函数来表示，其中domString是待渲染的HTML字符串，container是挂载点的DOM元素： function renderer(domString, container) &#123; container.innerHTML = domString; &#125; 使用渲染器的示例： renderer('&lt;h1>Hello&lt;/h1>', document.getElementById('app')); 上述代码将&lt;h1&gt;Hello&lt;/h1&gt;插入到id为app的DOM元素内。渲染器不仅可以渲染静态字符串，还可以渲染动态拼接的HTML内容： let count = 1; renderer(`&lt;h1>$&#123;count&#125;&lt;/h1>`, document.getElementById('app')); 如果count是一个响应式数据，那么可以使用响应系统来自动化整个渲染过程。首先，定义一个响应式数据count，然后在副作用函数内调用渲染器函数进行渲染： const count = ref(1); effect(() => &#123; renderer(`&lt;h1>$&#123;count.value&#125;&lt;/h1>`, document.getElementById('app')); &#125;); count.value++; 在上述代码中，count是一个ref响应式数据。当修改count.value的值时，副作用函数会重新执行，完成重新渲染，最终渲染到页面的内容是&lt;h1&gt;2&lt;/h1&gt;。 这里使用了Vue 3提供的@vue/reactivity包中的响应式API，通过&lt;script&gt;标签引入： &lt;script src=\"https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js\">&lt;/script> 上述代码中给出了render函数的基本实现，下面将其执行流程进行详细分析。假设我们连续三次调用renderer.render函数来执行渲染： const renderer = createRenderer(); // 首次渲染 renderer.render(vnode1, document.querySelector('#app')); // 第二次渲染 renderer.render(vnode2, document.querySelector('#app')); // 第三次渲染 renderer.render(null, document.querySelector('#app')); 在首次渲染时，渲染器将vnode1渲染为真实DOM，并将vnode1存储到容器元素的container.vnode属性中，作为旧vnode。 在第二次渲染时，旧的vnode存在（即container.vnode中有值），此时渲染器将vnode2作为新vnode，将新旧vnode一同传递给patch函数进行打补丁。 在第三次渲染时，新的vnode的值为null，即不渲染任何内容。但是此时容器中渲染的是vnode2所描述的内容，所以渲染器需要清空容器。在上面的代码中，使用container.innerHTML = &#39;&#39;来清空容器。需要注意的是，这种清空容器的方式并不是最佳实践，但在这里仅用于演示目的。 关于patch函数，它是整个渲染器的核心入口，接收三个参数：旧vnode n1、新vnode n2和容器 container。在首次渲染时，旧vnode n1是undefined，表示挂载动作。patch函数不仅用于打补丁，也可以执行挂载动作。 自定义渲染器自定义渲染器的实现是通过抽象核心渲染逻辑，使其不再依赖于特定平台的API。以下是自定义渲染器的实现示例代码，使用配置项来实现平台无关的渲染： // 创建渲染器函数，接收配置项作为参数 function createRenderer(options) &#123; // 从配置项中获取操作 DOM 的 API const &#123; createElement, insert, setElementText &#125; = options; // 定义挂载元素的函数 function mountElement(vnode, container) &#123; // 调用 createElement 函数创建元素 const el = createElement(vnode.type); // 如果子节点是字符串，调用 setElementText 设置文本内容 if (typeof vnode.children === 'string') &#123; setElementText(el, vnode.children); &#125; // 调用 insert 函数将元素插入到容器内 insert(el, container); &#125; // 定义打补丁函数 function patch(n1, n2, container) &#123; // 实现打补丁逻辑，这部分内容在示例中省略 &#125; // 定义渲染函数，接收虚拟节点和容器作为参数 function render(vnode, container) &#123; // 如果旧虚拟节点存在，执行打补丁逻辑，否则执行挂载逻辑 if (container.vnode) &#123; patch(container.vnode, vnode, container); &#125; else &#123; mountElement(vnode, container); &#125; // 将当前虚拟节点存储到容器的 vnode 属性中 container.vnode = vnode; &#125; // 返回渲染函数 return render; &#125; // 创建自定义渲染器的配置项 const customRendererOptions = &#123; // 用于创建元素 createElement(tag) &#123; console.log(`创建元素 $&#123;tag&#125;`); // 在实际应用中，可以返回一个自定义的对象，模拟DOM元素 return &#123; type: tag &#125;; &#125;, // 用于设置元素的文本节点 setElementText(el, text) &#123; console.log(`设置 $&#123;JSON.stringify(el)&#125; 的文本内容：$&#123;text&#125;`); // 在实际应用中，设置对象的文本内容 el.textContent = text; &#125;, // 用于在给定的 parent 下添加指定元素 insert(el, parent, anchor = null) &#123; console.log(`将 $&#123;JSON.stringify(el)&#125; 添加到 $&#123;JSON.stringify(parent)&#125; 下`); // 在实际应用中，将 el 插入到 parent 内 parent.children = el; &#125;, &#125;; // 使用自定义渲染器的配置项创建渲染函数 const customRenderer = createRenderer(customRendererOptions); // 创建一个虚拟节点描述 &lt;h1>hello&lt;/h1> const vnode = &#123; type: 'h1', children: 'hello', &#125;; // 使用一个对象模拟挂载点 const container = &#123; type: 'root' &#125;; // 使用自定义渲染器渲染虚拟节点到挂载点 customRenderer(vnode, container); 上面的代码片我们通过createRenderer函数创建了一个自定义渲染器，并通过配置项(customRendererOptions)传递操作DOM的API。渲染器在执行时，根据配置项中的API来完成相应的操作。通过这种方式，我们实现了一个通用的、不依赖于特定平台的渲染器。在实际应用中，可以根据不同的平台需求，通过配置不同的API，实现跨平台的渲染能力。","link":"/2023/11/05/vue-renderer-1/"},{"title":"vue-render挂载与更新","text":"前言Vue.js模板功能强大，几乎可以满足我们在应用程序中所需的一切。但是，有一些场景下，比如基于输入或插槽值创建动态组件，render函数可以更好地满足这些用例。 那些来自React世界的开发者可能对render函数非常熟悉。通常在JSX中使用它们来构建React组件。虽然Vue渲染函数也可以用JSX编写，但我们将继续使用原始JS，有助于我们可以更轻松地了解Vue组件系统的基础。。 每个Vue组件都实现了一个render函数。大多数时候，该函数将由Vue编译器创建。当我们在组件上指定模板时，该模板的内容将由Vue编译器处理，编译器最终将返回render函数。渲染函数本质上返回一个虚拟DOM节点，该节点将被Vue在浏览器DOM中渲染。 现在又引出了虚拟DOM的概念， 虚拟DOM到底是什么？ 虚拟文档对象模型（或”DOM”）允许Vue在更新浏览器之前在其内存中渲染组件。 这使一切变得更快，同时也避免了DOM重新渲染的高昂成本。因为每个DOM节点对象包含很多属性和方法，因此使用虚拟DOM预先在内存进行操作，可以省去很多浏览器直接创建DOM节点对象的开销。 Vue更新浏览器DOM时，会将更新的虚拟DOM与上一个虚拟DOM进行比较，并仅使用已修改的部分更新实际DOM。这意味着更少的元素更改，从而提高了性能。Render函数返回虚拟DOM节点，在Vue生态系统中通常称为VNode，该接口是允许Vue在浏览器DOM中写入这些对象的接口。它们包含使用Vue所需的所有信息。 挂载子节点和元素的属性当vnode.children的值是字符串类型时，会把它设置为元素的文本内容。一个元素除了具有文本子节点外，还可以包含其他元素子节点，并且子节点可以是很多个。为了描述元素的子节点，我们需要将vnode.children定义为数组： const vnode = &#123; type: 'div', children: [ &#123; type: 'p', children: 'hello' &#125; ] &#125;; 上面这段代码描述的是“一个div标签具有一个子节点，且子节点是p标签”。可以看到，vnode.children是一个数组，它的每一个元素都是一个独立的虚拟节点对象。这样就形成了树型结构，即虚拟DOM树。 为了完成子节点的渲染，我们需要修改mountElement函数，如下面的代码所示： function mountElement(vnode, container) &#123; const el = createElement(vnode.type); if (typeof vnode.children === 'string') &#123; setElementText(el, vnode.children); &#125; else if (Array.isArray(vnode.children)) &#123; // 如果`children`是数组，则遍历每一个子节点，并调用`patch`函数挂载它们 vnode.children.forEach(child => &#123; patch(null, child, el); &#125;); &#125; insert(el, container); &#125; 在上面这段代码中，我们增加了新的判断分支。使用Array.isArray函数判断vnode.children是否是数组，如果是数组，则循环遍历它，并调用patch函数挂载数组中的虚拟节点。在挂载子节点时，需要注意以下两点： 传递给patch函数的第一个参数是null。因为是挂载阶段，没有旧vnode，所以只需要传递null即可。这样，当patch函数执行时，就会递归地调用mountElement函数完成挂载。 传递给patch函数的第三个参数是挂载点。由于我们正在挂载的子元素是div标签的子节点，所以需要把刚刚创建的div元素作为挂载点，这样才能保证这些子节点挂载到正确位置。 完成了子节点的挂载后，我们再来看看如何用vnode描述一个标签的属性，以及如何渲染这些属性。我们知道，HTML标签有很多属性，其中有些属性是通用的，例如id、class等，而有些属性是特定元素才有的，例如form元素的action属性。实际上，渲染一个元素的属性比想象中要复杂，不过我们仍然秉承一切从简的原则，先来看看最基本的属性处理。 为了描述元素的属性，我们需要为虚拟DOM定义新的vnode.props字段，如下面的代码所示： const vnode = &#123; type: 'div', props: &#123; id: 'foo' &#125;, children: [ &#123; type: 'p', children: 'hello' &#125; ] &#125;; vnode.props是一个对象，它的键代表元素的属性名称，它的值代表对应属性的值。这样，我们就可以通过遍历props对象的方式，把这些属性渲染到对应的元素上，如下面的代码所示： function mountElement(vnode, container) &#123; const el = createElement(vnode.type); // 省略children的处理 // 如果`vnode.props`存在才处理它 if (vnode.props) &#123; // 遍历`vnode.props` for (const key in vnode.props) &#123; // 调用`setAttribute`将属性设置到元素上 el.setAttribute(key, vnode.props[key]); &#125; &#125; insert(el, container); &#125; 在这段代码中，我们首先检查了vnode.props字段是否存在，如果存在则遍历它，并调用setAttribute函数将属性设置到元素上。实际上，除了使用setAttribute函数为元素设置属性之外，还可以通过DOM对象直接设置： function mountElement(vnode, container) &#123; const el = createElement(vnode.type); // 省略children的处理 if (vnode.props) &#123; for (const key in vnode.props) &#123; // 直接设置 el[key] = vnode.props[key]; &#125; &#125; insert(el, container); &#125; 在这段代码中，我们没有选择使用setAttribute函数，而是直接将属性设置在DOM对象上，即el[key] = vnode.props[key]。实际上，无论是使用setAttribute函数，还是直接操作DOM对象，都存在缺陷。如前所述，为元素设置属性比想象中要复杂得多。不过，在讨论具体有哪些缺陷之前，我们有必要先搞清楚两个重要的概念：HTML Attributes和DOM Properties。 当我们处理元素属性时，有两种主要的方式：使用HTML Attributes和DOM Properties。这两者在概念上有些许不同： HTML Attributes: HTML Attributes是在HTML标签中定义的属性，例如id、class、src等。 通过setAttribute方法可以设置HTML Attributes。 HTML Attributes的值始终是字符串。 DOM Properties: DOM Properties是DOM对象上的属性，例如element.id、element.className、element.src等。 直接操作DOM对象可以设置DOM Properties。 DOM Properties的值可以是字符串、数字、布尔值等，具体取决于属性的类型。 HTML Attributes和DOM Properties在处理元素属性时，我们需要明确HTML Attributes和DOM Properties之间的区别。 如果我们使用setAttribute方法设置属性，那么属性会被设置为HTML Attributes。如果我们直接操作DOM对象的属性，属性会被设置为DOM Properties。 现在，我们来讨论一下这两种方式存在的问题： 属性值类型转换问题: 当我们使用setAttribute方法设置属性时，属性的值始终被转换为字符串。这就意味着，如果我们将一个数字或布尔值赋给属性，它们都会被转换为字符串。例如，element.setAttribute(&#39;value&#39;, 42)会将值转换为字符串&#39;42&#39;。 布尔属性问题: HTML中的一些属性是布尔属性，例如checked、disabled等。对于这些属性，如果存在就表示为true，不存在就表示为false。 当我们使用setAttribute方法设置布尔属性时，不论属性值是什么，都会被视为存在。例如，element.setAttribute(&#39;disabled&#39;, &#39;false&#39;)会使元素具有disabled属性，即使值是字符串&#39;false&#39;。 考虑到这些问题，最好的做法是尽量使用DOM Properties而不是HTML Attributes来设置元素的属性。这样可以避免类型转换问题和布尔属性问题，确保属性被正确设置。 首先，HTML Attributes指的是定义在HTML标签上的属性，例如id=&quot;my-input&quot;、type=&quot;text&quot;和value=&quot;foo&quot;。当浏览器解析这段HTML代码后，会创建一个与之相符的DOM元素对象，我们可以通过JavaScript代码来读取该DOM对象： const el = document.querySelector('#my-input'); 现在来说一下DOM Properties。许多HTML Attributes在DOM对象上有与之同名的DOM Properties，例如id=&quot;my-input&quot;对应el.id，type=&quot;text&quot;对应el.type，value=&quot;foo&quot;对应el.value等。但是，DOM Properties与HTML Attributes的名字并不总是一模一样的，例如： &lt;div class=\"foo\">&lt;/div> class=&quot;foo&quot;对应的DOM Properties则是el.className。另外，并不是所有HTML Attributes都有与之对应的DOM Properties，例如： &lt;div aria-valuenow=\"75\">&lt;/div> aria-*类的HTML Attributes就没有与之对应的DOM Properties。 类似地，也不是所有DOM Properties都有与之对应的HTML Attributes，例如可以用el.textContent来设置元素的文本内容，但并没有与之对应的HTML Attributes来完成同样的工作。 HTML Attributes的值与DOM Properties的值之间是有关联的。例如下面的HTML片段： &lt;div id=\"foo\">&lt;/div> 这个片段描述了一个具有id属性的div标签。其中，id=&quot;foo&quot;对应的DOM Properties是el.id，并且值为字符串&#39;foo&#39;。我们把这种HTML Attributes与DOM Properties具有相同名称（即id）的属性看作直接映射。 但并不是所有HTML Attributes与DOM Properties之间都是直接映射的关系，例如： &lt;input value=\"foo\" /> 这是一个具有value属性的input标签。如果用户没有修改文本框的内容，那么通过el.value读取对应的DOM Properties的值就是字符串&#39;foo&#39;。而如果用户修改了文本框的值，那么el.value的值就是当前文本框的值。例如，用户将文本框的内容修改为&#39;bar&#39;，那么： console.log(el.value); // 'bar' 但如果运行下面的代码，会发生“奇怪”的现象： console.log(el.getAttribute('value')); // 仍然是 'foo' console.log(el.value); // 'bar' 可以发现，用户对文本框内容的修改并不会影响el.getAttribute(&#39;value&#39;)的返回值，这个现象蕴含着HTML Attributes所代表的意义。实际上，HTML Attributes的作用是设置与之对应的DOM Properties的初始值。一旦值改变，那么DOM Properties始终存储着当前值，而通过getAttribute函数得到的仍然是初始值。 但我们仍然可以通过el.defaultValue来访问初始值，如下面的代码所示： el.getAttribute('value'); // 仍然是 'foo' el.value; // 'bar' el.defaultValue; // 'foo' 这说明一个HTML Attributes可能关联多个DOM Properties。例如在上例中，value=&quot;foo&quot;与el.value和el.defaultValue都有关联。 虽然我们可以认为HTML Attributes是用来设置与之对应的DOM Properties的初始值的，但有些值是受限制的，就好像浏览器内部做了默认值校验。如果你通过HTML Attributes提供的默认值不合法，那么浏览器会使用内建的合法值作为对应DOM Properties的默认值，例如： &lt;input type=\"foo\" /> 我们知道，为&lt;input/&gt;标签的type属性指定字符串&#39;foo&#39;是不合法的，因此浏览器会矫正这个不合法的值。所以当我们尝试读取el.type时，得到的其实是矫正后的值，即字符串&#39;text&#39;，而非字符串&#39;foo&#39;： console.log(el.type); // 'text' 从上述分析来看，HTML Attributes与DOM Properties之间的关系很复杂，但实际上我们只需要记住一个核心原则：HTML Attributes的作用是设置与之对应的DOM Properties的初始值。 如何正确地设置元素属性在上文中，我们讨论了在Vue.js单文件组件的模板中，HTML Attributes和DOM Properties的设置方式。在普通的HTML文件中，浏览器会自动解析HTML Attributes并设置相应的DOM Properties。然而，在Vue.js的模板中，需要框架手动处理这些属性的设置。 首先，我们以一个禁用的按钮为例，如下所示的HTML代码： &lt;button disabled>Button&lt;/button> 浏览器会自动将这个按钮设置为禁用状态，并将其对应的DOM Properties el.disabled的值设置为true。但是，如果同样的代码出现在Vue.js的模板中，情况就会有所不同。 在Vue.js的模板中，HTML模板会被编译成虚拟节点（vnode），其中props.disabled的值是一个空字符串。如果直接使用setAttribute函数设置属性，会导致意外的效果，即按钮被禁用。例如，以下模板： &lt;button disabled=\"false\">Button&lt;/button> 对应的虚拟节点为： const button = &#123; type: 'button', props: &#123; disabled: false &#125; &#125;; 如果使用setAttribute函数将属性值设置为空字符串，实际上相当于： el.setAttribute('disabled', ''); 而按钮的el.disabled属性是布尔类型的，不关心具体的HTML Attributes的值是什么，只要disabled属性存在，按钮就会被禁用。因此，渲染器不应该总是使用setAttribute函数将vnode.props对象中的属性设置到元素上。 为了解决这个问题，我们可以优先设置元素的DOM Properties，但当值为空字符串时，需要手动将其矫正为true。以下是一个具体的实现示例： function mountElement(vnode, container) &#123; const el = createElement(vnode.type); if (vnode.props) &#123; for (const key in vnode.props) &#123; if (key in el) &#123; const type = typeof el[key]; const value = vnode.props[key]; if (type === 'boolean' &amp;&amp; value === '') &#123; el[key] = true; &#125; else &#123; el[key] = value; &#125; &#125; else &#123; el.setAttribute(key, vnode.props[key]); &#125; &#125; &#125; insert(el, container); &#125; 在上述代码中，我们检查每个vnode.props中的属性，看看是否存在对应的DOM Properties。如果存在，优先设置DOM Properties。同时，对布尔类型的DOM Properties做了值的矫正，即当要设置的值为空字符串时，将其矫正为布尔值true。如果vnode.props中的属性没有对应的DOM Properties，则仍然使用setAttribute函数完成属性的设置。 然而，上述实现仍然存在问题。有些DOM Properties是只读的，例如el.form。为了解决这个问题，我们可以添加一个辅助函数shouldSetAsProps，用于判断是否应该将属性作为DOM Properties设置。如果属性是只读的，或者需要特殊处理，就应该使用setAttribute函数来设置属性。 最后，为了使属性设置操作与平台无关，我们将属性设置相关的操作提取到渲染器选项中。以下是相应的代码示例： const renderer = createRenderer(&#123; createElement(tag) &#123; return document.createElement(tag); &#125;, setElementText(el, text) &#123; el.textContent = text; &#125;, insert(el, parent, anchor = null) &#123; parent.insertBefore(el, anchor); &#125;, patchProps(el, key, prevValue, nextValue) &#123; if (shouldSetAsProps(el, key, nextValue)) &#123; const type = typeof el[key]; if (type === 'boolean' &amp;&amp; nextValue === '') &#123; el[key] = true; &#125; else &#123; el[key] = nextValue; &#125; &#125; else &#123; el.setAttribute(key, nextValue); &#125; &#125; &#125;); 在mountElement函数中，只需要调用patchProps函数，并为其传递相应的参数即可。这样，我们就将属性相关的渲染逻辑从渲染器的核心中抽离出来，使其更加可维护和灵活。","link":"/2023/11/05/vue-renderer-2/"},{"title":"vue-事件渲染的处理","text":"引言本节我们将讨论如何处理事件，包括如何在虚拟节点中描述事件，如何把事件添加到 DOM 元素上，以及如何更新事件。我们先来解决第一个问题，即如何在虚拟节点中描述事件。事件可以视作一种特殊的属性，因此我们可以约定，在 vnode.props 对象中，凡是以字符串 on 开头的属性都视作事件。例如： const vnode = &#123; type: 'p', props: &#123; // 使用 onXxx 描述事件 onClick: () => &#123; alert('clicked'); &#125; &#125;, children: 'text' &#125;; 解决了事件在虚拟节点层面的描述问题后，我们再来看看如何将事件添加到 DOM 元素上。这非常简单，只需要在 patchProps 中调用 addEventListener 函数来绑定事件即可，如下面的代码所示： function patchProps(el, key, prevValue, nextValue) &#123; // 匹配以 on 开头的属性，视其为事件 if (/^on/.test(key)) &#123; // 根据属性名称得到对应的事件名称，例如 onClick ---> click const name = key.slice(2).toLowerCase(); // 移除上一次绑定的事件处理函数 prevValue &amp;&amp; el.removeEventListener(name, prevValue); // 绑定新的事件处理函数 el.addEventListener(name, nextValue); &#125; else if (key === 'class') &#123; // 省略部分代码（处理 class 属性的逻辑） &#125; else if (shouldSetAsProps(el, key, nextValue)) &#123; // 省略部分代码（处理其他属性的逻辑） &#125; else &#123; // 省略部分代码（处理其他属性的逻辑） &#125; &#125; 事实上可以更为优化的事件更新机制，避免多次调用 removeEventListener 和 addEventListener。 function patchProps(el, key, prevValue, nextValue) &#123; if (/^on/.test(key)) &#123; const name = key.slice(2).toLowerCase(); let invoker = el.__vei || (el.__vei = &#123;&#125;); if (nextValue) &#123; if (!invoker[name]) &#123; // 如果没有 invoker，则创建一个伪造的 invoker 函数 invoker[name] = (e) => &#123; invoker[name].value(e); &#125;; &#125; // 将真正的事件处理函数赋值给 invoker 函数的 value 属性 invoker[name].value = nextValue; // 绑定 invoker 函数作为事件处理函数 el.addEventListener(name, invoker[name]); &#125; else if (invoker[name]) &#123; // 如果新的事件处理函数不存在，且之前绑定的 invoker 存在，则移除绑定 el.removeEventListener(name, invoker[name]); invoker[name] = null; &#125; &#125; else if (key === 'class') &#123; // 省略部分代码（处理 class 属性的逻辑） &#125; else if (shouldSetAsProps(el, key, nextValue)) &#123; // 省略部分代码（处理其他属性的逻辑） &#125; else &#123; // 省略部分代码（处理其他属性的逻辑） &#125; &#125; 观察上面的代码，事件绑定主要分为两个步骤。先从 el._vei 中读取对应的 invoker，如果 invoker 不存在，则将伪造的 invoker 作为事件处理函数，并将它缓存到el._vei 属性中。 把真正的事件处理函数赋值给 invoker.value 属性，然后把伪造的 invoker 函数作为事件处理函数绑定到元素上。可以看到，当事件触发时，实际上执行的是伪造的事件处理函数，在其内部间接执行了真正的事件处理函数 invoker.value(e)。 当更新事件时，由于 el._vei 已经存在了，所以我们只需要将invoker.value 的值修改为新的事件处理函数即可。 这样，在更新事件时可以避免一次 removeEventListener 函数的调用，从而提升了性能。实际上，伪造的事件处理函数的作用不止于此，它还能解决事件冒泡与事件更新之间相互影响的问题。但目前的实现仍然存在问题。现在我们将事件处理函数缓存在el._vei 属性中，问题是，在同一时刻只能缓存一个事件处理函数。这意味着，如果一个元素同时绑定了多种事件，将会出现事件覆盖的现象。 const vnode = &#123; type: 'p', props: &#123; // 使用 onXxx 描述事件 onClick: () => &#123; alert('clicked'); &#125;, onContextmenu: () => &#123; alert('contextmenu'); &#125; &#125;, children: 'text' &#125;; // 假设 renderer 是你的渲染器对象 renderer.render(vnode, document.querySelector('#app')); 当渲染器尝试渲染这上面代码中给出的 vnode 时，会先绑定click 事件，然后再绑定 contextmenu 事件。后绑定的contextmenu 事件的处理函数将覆盖先绑定的 click 事件的处理函数。为了解决事件覆盖的问题，我们需要重新设计 el._vei 的数据结构。我们应该将 el._vei 设计为一个对象，它的键是事件名称，它的值则是对应的事件处理函数，这样就不会发生事件覆盖的现象了. 根据你提供的代码片段，这段代码主要是用于处理 DOM 元素的属性更新，其中包括事件的绑定和解绑逻辑。在这个代码中，它使用了一个 el._vei 的对象来缓存事件处理函数。下面是你提供的代码的一些修正： function patchProps(el, key, prevValue, nextValue) &#123; if (/^on/.test(key)) &#123; const invokers = el._vei || (el._vei = &#123;&#125;); const name = key.slice(2).toLowerCase(); let invoker = invokers[name]; if (nextValue) &#123; if (!invoker) &#123; invoker = el._vei[name] = (e) => &#123; if (Array.isArray(invoker.value)) &#123; invoker.value.forEach(fn => fn(e)); &#125; else &#123; invoker.value(e); &#125; &#125;; &#125; invoker.value = nextValue; el.addEventListener(name, invoker); &#125; else if (invoker) &#123; el.removeEventListener(name, invoker); el._vei[name] = null; &#125; &#125; else if (key === 'class') &#123; // 处理 class 属性的逻辑 &#125; else if (shouldSetAsProps(el, key, nextValue)) &#123; // 处理其他属性的逻辑 &#125; else &#123; // 处理其他属性的逻辑 &#125; &#125; 在这段代码中，我们修改了 invoker 函数的实现。当 invoker函数执行时，在调用真正的事件处理函数之前，要先检查invoker.value 的数据结构是否是数组，如果是数组则遍历它，并逐个调用定义在数组中的事件处理函数。","link":"/2023/11/05/vue-renderer-3/"},{"title":"vue-watch-computed原理","text":"引言之前介绍过了 effect 函数，它用来注册副作用函数，同时它也允许指定一些选项参数 options，例如指定 scheduler 调度器来控制副作用函数的执行时机和方式；也介绍了用来追踪和收集依赖的track 函数，以及用来触发副作用函数重新执行的 trigger 函数。实际上，综合这些内容，我们就可以实现 Vue.js 中一个非常重要并且非常有特色的能力——计算属性。 计算属性与lazy属性在Vue.js中，effect函数是用来创建响应式副作用的函数。默认情况下，传递给effect的副作用函数会立即执行。例如，下面的代码中，effect函数会立即执行传递给它的副作用函数： effect(() => &#123; console.log(obj.foo); &#125;); 然而，在某些情况下，我们希望副作用函数在需要的时候才执行，而不是立即执行。一个典型的例子是计算属性。为了实现这种延迟执行的效果，我们可以在options中添加一个lazy属性，并将其设置为true。当lazy为true时，副作用函数不会在初始化时立即执行，而是在需要的时候才执行。修正后的代码如下所示： effect( // 这个函数不会立即执行 () => &#123; console.log(obj.foo); &#125;, // options &#123; lazy: true &#125; ); 具体实现中，我们将副作用函数effectFn作为effect函数的返回值返回。这意味着，当我们调用effect函数时，我们会得到对应的副作用函数，并且可以在需要的时候手动执行它。这种机制赋予了我们更多的控制权，允许我们决定何时触发副作用函数的执行，而不是立即执行它。 这种设计模式特别适用于特定场景，例如计算属性。在计算属性中，我们可能希望在特定时刻触发副作用函数的执行，而不是在初始化时立即执行。通过将副作用函数作为effect函数的返回值，我们能够灵活地控制副作用函数的执行时机，以满足不同场景的需求。 function effect(fn, options = &#123;&#125;) &#123; const effectFn = () => &#123; cleanup(effectFn); activeEffect = effectFn; effectStack.push(effectFn); fn(); effectStack.pop(); activeEffect = effectStack[effectStack.length - 1]; &#125;; // 设置副作用函数的 options 和 deps effectFn.options = options; effectFn.deps = []; // 只有非 lazy 时执行副作用函数 if (!options.lazy) &#123; effectFn(); &#125; // 将副作用函数作为返回值返回 return effectFn; &#125; 在这个代码中，effect函数的第二个参数是一个options对象，其中lazy属性被设置为true。这意味着传递给effect的副作用函数会在需要的时候才执行，例如在计算属性被访问时。这种延迟执行的特性使得effect函数非常适合用于实现计算属性等场景。 在上述代码中，我们通过options参数的lazy属性控制副作用函数的立即执行。如果options.lazy为true，副作用函数将被延迟执行，直到手动触发为止。 现在我们通过计算属性实现了lazy懒加载，那么数据缓存该怎么实现呢。 function computed(getter) &#123; // value 用来缓存上一次计算的值 let value; // dirty 标志，用来标识是否需要重新计算值，为 true 则意味着“脏”，需要计算 let dirty = true; const effectFn = effect(getter, &#123; lazy: true &#125;); const obj = &#123; get value() &#123; // 只有“脏”时才计算值，并将得到的值缓存到 value 中 if (dirty) &#123; value = effectFn(); // 将 dirty 设置为 false，下一次访问直接使用缓存到 value 中的值 dirty = false; &#125; return value; &#125; &#125;; return obj; &#125; 解决了懒计算的问题，只有在真正需要计算value的时候，才会执行effectFn。同时，它还引入了一个dirty标志，用于标识当前的计算是否需要重新进行。如果dirty为true，则重新计算value的值，并将dirty标志设置为false，以便下一次访问时可以直接使用缓存的值。 watch 的实现原理所谓 watch，其本质就是观测一个响应式数据，当数据发生变化时通知并执行相应的回调函数。举个例子： watch(obj, () => &#123; console.log('数据变了') &#125;) // 修改响应数据的值，会导致回调函数执行 obj.foo++ 假设 obj 是一个响应数据，使用 watch 函数观测它，并传递一个回调函数，当修改响应式数据的值时，会触发该回调函数执行。实际上，watch 的实现本质上就是利用了 effect 以及options.scheduler 选项，如以下代码所示： effect(() => &#123; console.log(obj.foo) &#125;, &#123; scheduler() &#123; // 当 obj.foo 的值变化时，会执行 scheduler 调度函数 &#125; &#125;) 在一个副作用函数中访问响应式数据 obj.foo，通过前面的介绍，我们知道这会在副作用函数与响应式数据之间建立联系，当响应式数据变化时，会触发副作用函数重新执行。但有一个例外，即如果副作用函数存在 scheduler 选项，当响应式数据发生变化时，会触发 scheduler 调度函数执行，而非直接触发副作用函数执行。从这个角度来看，其实 scheduler 调度函数就相当于一个回调函数，而watch 的实现就是利用了这个特点。 下面是最简单的 watch 函数的实现： // watch 函数接收两个参数，source 是响应式数据，cb 是回调函数 function watch(source, cb) &#123; effect( // 触发读取操作，从而建立联系 () => source.foo, &#123; scheduler: scheduler(), // 当数据变化时，调用回调函数 cb fn: () => &#123; cb(); &#125;, &#125; ); &#125; 于是一段完整的代码： // 响应式数据对象 const data = &#123; foo: 1 &#125;; // 创建代理对象，用于监听数据变化 const obj = new Proxy(data, &#123; set(target, key, value) &#123; target[key] = value; // 数据变化时触发回调函数 watch(obj, () => &#123; console.log('数据变化了'); &#125;); return true; &#125;, &#125;); // watch 函数接收两个参数，source 是响应式数据，cb 是回调函数 function watch(source, cb) &#123; effect(() => source.foo, &#123; scheduler: scheduler(), fn: () => &#123; cb(); &#125;, &#125;); &#125; // 模拟 effect 函数 function effect(fn, options) &#123; // 在这里执行 effect 相关逻辑 fn(); // 这里假设执行 fn 会触发响应式数据的读取操作 &#125; // 模拟 scheduler 函数 function scheduler() &#123; // 在这里可以添加调度逻辑 // 这里返回一个函数作为 scheduler return function () &#123; // 这里可以添加具体的调度逻辑 // ... &#125;; &#125; // 数据变化 obj.foo++; // 输出: 数据变化了 我们首先定义了一个原始的数据对象data，其中有一个属性foo，初始值为1。接着，我们使用Proxy创建了一个代理对象obj，该代理对象会拦截对data的操作。 当你调用obj.foo++时，会触发Proxy的set拦截器。在set拦截器中，我们首先将属性值设置到目标对象上，然后调用watch函数，并传入obj和一个回调函数。在watch函数中，我们使用了一个假设的effect函数（实际开发中可能是框架提供的响应式函数），这个函数用于监听数据的变化。在watch函数中，我们传入了source.foo的读取操作，以及一个包含scheduler和fn属性的配置对象。scheduler可以用于定义调度逻辑（在示例中为空函数），fn则是一个当数据变化时会被调用的回调函数。 当obj.foo++执行时，set拦截器触发，watch函数被调用。","link":"/2023/10/31/vue-watch-computed/"},{"title":"浅谈WebAssembly","text":"引言看了不少Wasm的文章，也做了一些性能测试，现在来简单的谈下这门技术。 WASM &#x3D;&#x3D; 汇编级性能？这显然不对，WASM 里的 Assembly 并不意味着真正的汇编码，而只是种新约定的字节码，也是需要解释器运行的。 这种解释器肯定比 JS 解释器快得多，但自然也达不到真正的原生机器码水平。 一个可供参考的数据指标，是 JS 上了 JIT 后整体性能大致是机器码 1&#x2F;20 的水平，而 WASM 则可以跑到机器码 1&#x2F;3 的量级（视场景不同很不好说，仅供参考）。相当于即便你写的是 C++ 和 Rust 级的语言，得到的其实也只是 Java 和 C# 级的性能。 这也可以解释为什么 WASM 并不能在所有应用场景都显示出压倒性的性能优势：只要你懂得如何让 JS 引擎走在 Happy Path 上，那么在浏览器里，JS 就敢和 Rust 性能优化差不多。 一个在 WASM 和 JS 之间做性能对比的经典案例，就是 Mozilla 开发者和 V8 开发者的白学现场。整个过程是这样的： Mozilla Hacks 发表了一篇名为 用 Rust 和 WASM 优化 Source Map 性能 的博文，将 source-map 这个 JS 包的性能优化了五倍。 V8 核心开发 Vyacheslav Egorov 回应名为你也许不需要用 Rust 和 WASM 来优化 JS 的博文，用纯 JS 实现了速度比 Rust 更快的惊人优化。 原文作者以 无需魔法的速度 为名展开了进一步讨论，并用 Rust 做出了新的性能优化。 巧的是，这场论战正发生在两年前白色相簿的季节。双方就像雪菜和冬马那样展开了高水平的对决，名场面十分精彩。最终 Vyacheslav 给出了一张三轮过招后的性能对比图。可以看到虽然最终还是 Rust 更快，但 JS 被逼到极限后非但不是败犬，还胜出了一回合： 另外，大佬Milo Yip 做过的不同语言光线追踪性能测试（修罗场），也能侧面印证带 VM 语言与机器码之间的性能对比结论。C++、Java 和 JS 在未经特别优化的前提下，可以分别代表三个典型的性能档次： C++&#x2F;C#&#x2F;F#&#x2F;Java&#x2F;JS&#x2F;Lua&#x2F;Python&#x2F;Ruby 渲染比试 WASM 比 JS 快，所以计算密集型应用就该用它？这有点偏颇，WASM 同样是 CPU 上的计算。对于可以高度并行化的任务，使用 WebGL 来做 GPU 加速往往更快。譬如我在 实用 WebGL 图像处理入门 这篇文章里介绍的图像处理算法，比起 JS 里 for 循环遍历 Canvas 像素就可以很轻松地快个几十倍。 而这种套两层 for 循环的苦力活，用现在的 WASM 重写能快几倍就非常不错了。至于浏览器内 AI 计算的性能方面，社区的评测结论也是 WebGL 和 WebMetal 具备最高的性能水平，然后才是 WASM。参见这里：浏览器内的 AI 评测 不过，WebGL 的加速存在精度问题。例如前端图像缩放库 Pica，它的核心用的是 Lanczos 采样算法。我用 WebGL 着色器实现过这个算法，它并不复杂，早期的 Pica 也曾经加入过可选的 WebGL 优化，但现在却劈腿了 WASM。这一决策的理由在于，WASM 能保证相同参数下的计算结果和 JS 一致，但 WebGL 则不行。相关讨论参见这里：Issue #114 · nodeca&#x2F;pica 而且，对于前端来说，计算密集型的应用场景并不算太多，比起 WebGPU 这种图形渲染的技术的发展前景可以说算是比较弱势，但毕竟二者不在同一种应用场景下。 所以对计算密集型任务，WASM 并不是前端唯一的救星，而是给大家多了一种在性能、开发成本和效果之间权衡的选择。在我个人印象里，前端在图形渲染外需要算力的场景说实话并不太多，像加密、压缩、挖矿这种，都难说是高频刚需。至于未来可能相当重要的 AI 应用，长期而言我还是看好 WebGPU 这种更能发挥出 GPU 潜力的下一代标准，当然 WASM 也已经是个不错的可选项了。 只要嵌入 WASM 函数到 JS 就能提高性能？既然 WASM 很快，那么是不是我只要把 JS 里 const add (a, b) &#x3D;&gt; a + b 这样的代码换成用 C 编译出来的 WASM，就可以有效地提高性能了呢？ 这还真不一定。 因为现代浏览器内的 JS 引擎都有进行性能优化的利器，都标配了一种东西，那就是 JIT。简单来说，上面这个 add 函数如果始终都在算整数加法，那么 JS 引擎就会自动编译出一份计算 int a + int b 的机器码来替代掉原始的 JS 函数，这样高频调用这个函数的性能就会得到极大的提升，这也就是 JIT 所谓 Just-in-time 编译的奥妙所在了。 所以，不要一觉得 JS 慢就想着手动靠 WASM 来嵌入 C，其实现代 JS 引擎可都是在不停地帮你「自动把 JS 转换成 C」的！如果你可以把一个 JS 函数改写成等价的 C，那么我猜如果把这个函数单独抽离出来，靠 JS 引擎的 JIT 都很可能达到相近的性能。这应该就是 V8 开发者敢用 JS 和 Rust 对线的底气所在吧。 像在 JS 和 WASM 之间的调用终于变快了 这篇文章中，Lin Clark 非常精彩地论述了整个优化过程，最终使得 JS 和 WASM 间的函数调用，比非内联的 JS 函数间调用要快。不过，至于和被 JIT 内联掉的 JS 函数调用相比起来如何，这篇文章就没有提及了。 这里偏个题，Mozilla 经常宣传自己实现的超大幅优化，有不少都可能来源于之前明显的设计问题（平心而论，我们自己何尝不是这样呢）。像去年 Firefox 70 在 Mac 上实现的 大幅省电优化，其根源是什么呢？粗略的理解是，以前的 Firefox 在 Mac 上竟然每帧都会全量更新窗口像素！当然，这些文章的干货都相当多，十分推荐大家打好基础后看看原文，至少是个更大的世界，也常常能对软件架构设计有所启发。 如果后续 WASM 支持了 GC，那么嵌入互调的情况很可能更复杂。例如我最近就尝试在 Flutter 的 Dart 和安卓的 Java 之间手动同步大对象，希望能「嵌入一些安卓平台能力到 Flutter 体系里」，然而这带来了许多冗长而低性能的胶水代码，需要通过异步的消息来做深拷贝，可控性很低。 虽然 WASM 现在还没有 GC，但一旦加上，我有理由怀疑它和 JS 之间的对象生命周期管理也会遇到类似的问题。只是这个问题主要是让 Mozilla 和 Google 的人来操心，用不着我们管而已。 在 JS 里调 WASM，就像 Python 里调 C 那样简单？这个问题只有实际做过才有发言权。譬如我最近尝试过的这些东西： 在安卓的 Java class 里调用 C++ 在 Flutter 的 Dart 里调用 C 在 QuickJS 这种嵌入式 JS 引擎里调用 C 它们都能做到一件事，那就是在引擎里新建原生对象，并将它以传引用的方式直接交给C / C++函数调用，并用引擎的 GC 来管理对象的生命周期。这种方式一般称为 FFI（Foreign Function Interface 外部函数接口），可以把原生代码嵌入到语言 Runtime 中。但如果是两个不同的 Runtime，事情就没有这么简单了。例如 QuickJS 到 Java 的 binding 项目 Quack，就需要在 JS 的对象和 Java 对象中做 Marshalling（类似于 JSON 那样的序列化和反序列化）的过程，不能随便传引用。 对 WASM 来说是怎样的呢？ 基本上，WASM 的线性内存空间可以随便用 JS 读写，并没有深拷贝的困扰。不过，WASM倒有一些数据流的问题，只有 int 和 float 之流的数据类型，连 string 都没有，因此对于稍复杂一点的对象，都很难手写出 JS 和 WASM 两边各自的结构。这点导致你想直接使用Wasm做复杂的对象转换都较为困难，现在这件脏活是交由 wasm-bindgen 等轮子来做的,wasm-pack 使用另一个工具 wasm-bindgen 来提供 JavaScript 和 Rust 等其他类型之间的桥梁。 但毕竟这个过程并不是直接在 JS 的 Runtime 里嵌入 C &#x2F; C++ 函数，和传统编译到机器码的 FFI 还是挺不一样的。 例如现在如果需要频繁地用 WASM 操作 JS 对象，那么几乎必然是影响性能的。这方面典型的坑是基于 WASM 移植的 OpenGL 应用。像 C++ 中的一个 glTexImage2D 函数，目前编译到 WASM 后就需要先从 WASM 走到 JS 胶水层，再在 JS 里调 gl.texImage2D 这样的 WebGL API，最后才能经由 C++ binding 调用到原生的图形 API。这样从一层胶水变成了两层，性能不要说比起原生 C++，能比得上直接写 JS 吗？ 当然，Mozilla 也意识到了这个问题，因此他们在尝试如何更好地将 Web IDL（也就是浏览器原生 API 的 binding）开放给 WASM，并在这个过程中提出了 WASM Interface Types 概念：既然 WASM 已经是个字节码的中间层了，那么干脆给它约定个能一统所有编程语言运行时类型的 IR 规范吧！不过，这一规范还是希望主要靠协议化、结构化的深拷贝来解决问题，只有未来的 anyref 类型是可以传引用的。anyref 有些像 Unix 里的文件描述符，这里就不展开了。 WASM 属于前端生态？这个我不太认可, 要知道Wasm这个玩意其编译工具链和依赖库生态，基本完全不涉及 JS。 一套支持交叉编译的工具链，会附带上用于支持目标平台的一些库，例如 include 了 &lt;GLES2/gl2.h&gt; 之后，你调用到的 glTexImage2D API 就是动态库里提供的。有了动态库，这个 API 才能在 x86 &#x2F; ARM &#x2F; MIPS &#x2F; WASM 等平台上一致地跑起来（就像安卓上的 .so 格式）。 像 Emscripten 就提供了面向 WASM 平台，编译成 JS 格式的一套动态库。但它只能保证这些 API 能用，性能如何就另说了。它自己也对移植 WebGL 时的性瓶颈提出了很多的优化建议。 所以这里再重复一遍，编译 WASM 应用所需的依赖库和整套工具链，几乎都跟 JS 没什么关系。JS 就像机器码那样，只是人家工具链编译出来的输出格式而已。在 JS 开发者看来，这整套东西可能显得相当突兀。但从原生应用开发者的视角看来，这一切都再正常不过了。 后记WASM 当然是个革命性的技术，代表了一种跨平台的全新方向，尤其对原生应用开发者来说具备巨大的商业价值。但它对前端来说其实就是个浏览器内置的字节码虚拟机。","link":"/2023/11/03/wasm-1/"},{"title":"Webpack-自定义 loader/plugin","text":"引言loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 Loader API，并通过 this 上下文访问。 这边贴一个官网链接loader的用法和例子，以及自定义loader本地开发测试 Webpack Loader的简单使用当一个 loader 在资源中使用，这个 loader 只能传入一个参数 - 一个包含资源文件内容的字符串。 同步 loader 可以 return 一个代表已转换模块（transformed module）的单一值。 loader 会返回一个或者两个值。第一个值的类型是 JavaScript 代码的字符串或者 buffer。第二个可选值是 SourceMap，它是个 JavaScript 对象。 下面是一个简单的loader的用法，他将匹配所有的js文件，并使用loader.js处理 //webpack.config.js const path = require('path'); module.exports = &#123; //... module: &#123; rules: [ &#123; test: /\\.js$/, use: [ &#123; loader: path.resolve('path/to/loader.js'), options: &#123; /* ... */ &#125;, &#125;, ], &#125;, ], &#125;, &#125;; 由上面我们可以知道loader的使用方法，但对loader仅停留在使用，那具体的一个loader长什么样呢？ 比如说一个简单的loader是这样的： module.exports = function (content) &#123; // content 就是传入的源内容字符串 return content &#125; 一个 loader 就是一个node模块，其中暴露了一个函数，并只可以接收一个入参，这个参数是一个包含包含资源文件内容的字符串，而函数的返回值就是处理后的内容。 自定义webpack loader自定义loader的用法准则编写 loader 时应该遵循以下准则。它们按重要程度排序，有些仅适用于某些场景，请阅读下面详细的章节以获得更多信息。 保持 简单 。 使用 链式 传递。 模块化 的输出。 确保 无状态 。 使用 loader utilities 。 记录 loader 的依赖 。 解析 模块依赖关系 。 提取 通用代码 。 避免 绝对路径 。 使用 peer dependencies。 步骤1：创建项目目录和文件首先，在一个webpack项目目录中的文件夹中创建以下文件： src/loader/custom-loader.js：自定义Loader的源文件。 src/index.js：JavaScript入口文件，用于测试自定义Loader。 步骤2：编写自定义Loader在 custom-loader.js 文件中，编写你的自定义loader代码。这个Loader的作用是将在每个加载的JavaScript文件的顶部添加一个注释。 // src/loader/custom-loader.js module.exports = function(source) &#123; // 在源代码的顶部添加自定义注释 const updatedSource = `/** Custom Comment added by Custom Loader */\\n$&#123;source&#125;`; return updatedSource; &#125;; 步骤3：配置Webpack在项目根目录下创建Webpack配置文件 webpack.config.js。在配置文件中，使用刚刚编写的自定义Loader。 // webpack.config.js const path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, use: ['custom-loader'], // 使用自定义Loader处理.js文件 exclude: /node_modules/, &#125;, ], &#125;, &#125;; 功能就简单的进行了一下实现，这里我们主要说一下如何测试调用我们的本地的 loader，方式有两种，一种是通过 Npm link 的方式进行测试，这边贴一个Npm link的链接，大家可以去创建一个软连接进行本地测试，还是挺方便的npm-link。 另外一种就是直接在项目里面进行路径配置： 单loader配置方法//webpack.config.js &#123; test: /\\.js$/ use: [ &#123; loader: path.resolve('path/to/custom-loader.js'), options: &#123;/* ... */&#125; &#125; ] &#125; 多loader配置方法当然也可以通过数组的方式进行配置 //webpack.config.js resolveLoader: &#123; // 这里就是说先去找 node_modules 目录中，如果没有的话再去 loaders 目录查找 modules: [ 'node_modules', path.resolve(__dirname, 'custom-loader') ] &#125; 步骤4：测试自定义Loader在 index.js 文件中，编写一些JavaScript代码，例如： // src/index.js console.log('Hello, Webpack Loader!'); 步骤5：运行Webpack构建运行以下命令来构建你的项目： npx webpack --config webpack.config.js 构建完成后，你将在 dist 文件夹中找到生成的 bundle.js 文件。在这个文件里面可以看到在顶部添加了自定义注释的JavaScript代码。 Webpack plugin的简单使用插件向第三方开发者提供了 webpack 引擎中完整的能力。使用阶段式的构建回调，开发者可以在 webpack 构建流程中引入自定义的行为。 比如说最简单的一个例子： // webpack.config.js const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: __dirname + '/dist', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', // 指定HTML模板文件 filename: 'index.html', // 生成的HTML文件名 &#125;), // 可以添加更多的插件 ], &#125;; 在上面这个例子里面使用了HtmlWebpackPlugin插件，根据指定的HTML模板生成一个新的HTML文件，并将打包后的JavaScript文件自动添加到生成的HTML文件中。 一个基本的webpack 插件由以下组成： 一个 JavaScript 命名函数或 JavaScript 类。 在插件函数的 prototype 上定义一个 apply 方法，apply 方法在 webpack 装载这个插件的时候被调用，并且会传入 compiler 对象。。 指定一个绑定到 webpack 自身的事件钩子。 处理 webpack 内部实例的特定数据。 功能完成后调用 webpack 提供的回调。 一个插件结构如下： class HelloWorldPlugin &#123; apply(compiler) &#123; compiler.hooks.done.tap( 'Hello World Plugin', ( stats /* 绑定 done 钩子后，stats 会作为参数传入。 */ ) => &#123; console.log('Hello World!'); &#125; ); &#125; &#125; module.exports = HelloWorldPlugin; Compiler and Compilation在插件开发中最重要的两个资源就是 compiler 和 compilation 对象。可以说Webpack plugin的开发就是围绕着这两个对象的 hook 进行操作 compiler 对象可以理解为一个和 webpack 环境整体绑定的一个对象，它包含了所有的环境配置，包括 options，loader 和 plugin，当 webpack 启动时，这个对象会被实例化，并且他是全局唯一的，上面我们说到的 apply 方法传入的参数就是它。 compilation 在每次构建资源的过程中都会被创建出来，一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。它同样也提供了很多的 hook 。 自定义Webpack plugin步骤1：创建项目目录和文件首先，还是需要一个webpack项目。我们在这个文件夹中创建以下文件： src/plugins/CustomPlugin.js：自定义插件的源文件。 步骤2：编写自定义插件在 CustomPlugin.js 文件中，我们编写了一个插件，并将在Webpack构建结束时输出一条信息。 // src/plugins/CustomPlugin.js class CustomPlugin &#123; apply(compiler) &#123; compiler.hooks.done.tap('CustomPlugin', () => &#123; console.log('CustomPlugin: Webpack build process is done!'); &#125;); &#125; &#125; module.exports = CustomPlugin; 步骤3：配置Webpack在配置文件中，使用上面我们的自定义插件。 // webpack.config.js const CustomPlugin = require('./src/plugins/CustomPlugin'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: __dirname + '/dist', &#125;, plugins: [ new CustomPlugin(), // 可以添加更多的插件 ], &#125;; 步骤4：运行Webpack构建现在进行Webpack构建： npx webpack --config webpack.config.js","link":"/2023/10/29/webpack-plugin-design/"}],"tags":[{"name":"http","slug":"http","link":"/tags/http/"},{"name":"Webpack,Front-end","slug":"Webpack-Front-end","link":"/tags/Webpack-Front-end/"},{"name":"Cloud-Computing","slug":"Cloud-Computing","link":"/tags/Cloud-Computing/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"Hadoop,Cloud-Computing","slug":"Hadoop-Cloud-Computing","link":"/tags/Hadoop-Cloud-Computing/"},{"name":"JITcompiler,JavaScript,Wasm","slug":"JITcompiler-JavaScript-Wasm","link":"/tags/JITcompiler-JavaScript-Wasm/"},{"name":"Build,Rspack","slug":"Build-Rspack","link":"/tags/Build-Rspack/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Wasm","slug":"Wasm","link":"/tags/Wasm/"}],"categories":[{"name":"http","slug":"http","link":"/categories/http/"},{"name":"Webpack","slug":"Webpack","link":"/categories/Webpack/"},{"name":"Cloud-Computing","slug":"Cloud-Computing","link":"/categories/Cloud-Computing/"},{"name":"Front-end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"Hadoop","slug":"Hadoop","link":"/categories/Hadoop/"},{"name":"JITcompiler","slug":"JITcompiler","link":"/categories/JITcompiler/"},{"name":"Build","slug":"Build","link":"/categories/Build/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Cloud-Computing","slug":"Hadoop/Cloud-Computing","link":"/categories/Hadoop/Cloud-Computing/"},{"name":"Wasm","slug":"Wasm","link":"/categories/Wasm/"},{"name":"Rspack","slug":"Build/Rspack","link":"/categories/Build/Rspack/"}]}