<!DOCTYPE html>
<html class="has-navbar-fixed-top" lang="zh-tw">
<head>
    <meta charset="utf-8">
<title>Huangzl&#39;s blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1">



            
<link href="https://ikkkp.github.io/en/" rel="alternate" hreflang="en" />
            
    


    
    <meta name="description" content="Huli 的技術部落格，寫關於前端、JavaScript、資安以及各種技術議題。A tech blog about frotn-end and security">
    



    
<link rel="canonical" href="https://ikkkp.github.io/">
    





    <meta property="og:type" content="website">
<meta property="og:title" content="Huangzl&#39;s blog">
<meta property="og:url" content="https://ikkkp.github.io/index.html">
<meta property="og:site_name" content="Huangzl&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Huangzl">
<meta name="twitter:card" content="summary_large_image">



<link rel="alternative" href="/atom.xml" title="Huangzl&#39;s blog" type="application/atom+xml">



<link rel="icon" href="/img/IK.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">


<link rel="stylesheet" href="/css/bulma.css?v=2.css">



<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />


<link rel="stylesheet" href="/css/style.css?v=4.css">





    
    
    
    
    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1393J2EVCZ"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-1393J2EVCZ');
</script>


    


<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <script>
        if (localStorage.getItem('dark-mode')) {
            if (localStorage.getItem('dark-mode') === 'true') {
                document.body.classList.add('dark-mode')
            }
        } else {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.body.classList.add('dark-mode')
            }
        }
    </script>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    Huangzl&#39;s blog
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">文章列表</a>
            
            <a class="navbar-item "
               href="/categories">分類</a>
            
            <a class="navbar-item "
               href="/recommend">推薦閱讀</a>
            
            <a class="navbar-item "
               href="/abouts">關於我</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
            <a class="navbar-item" target="_blank" title="Facebook" href="https://twitter.com/hungzln3">
                
                <i class="fab fa-twitter"></i>
                
            </a>
               
            <a class="navbar-item" target="_blank" title="RSS" href="/atom-ch.xml">
                
                <i class="fas fa-rss"></i>
                
            </a>
               
            
            <a class="navbar-item btn-dark-mode" title="dark-mode" href="#">
                <div>
                    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="15" height="15" viewBox="0 0 256 256" xml:space="preserve">
                    <defs>
                    </defs>
                    <g style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: none; fill-rule: nonzero; opacity: 1;" transform="translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)" >
                        <path d="M 87.823 60.7 c -0.463 -0.423 -1.142 -0.506 -1.695 -0.214 c -15.834 8.398 -35.266 2.812 -44.232 -12.718 c -8.966 -15.53 -4.09 -35.149 11.101 -44.665 c 0.531 -0.332 0.796 -0.963 0.661 -1.574 c -0.134 -0.612 -0.638 -1.074 -1.259 -1.153 c -9.843 -1.265 -19.59 0.692 -28.193 5.66 C 13.8 12.041 6.356 21.743 3.246 33.35 S 1.732 57.08 7.741 67.487 c 6.008 10.407 15.709 17.851 27.316 20.961 C 38.933 89.486 42.866 90 46.774 90 c 7.795 0 15.489 -2.044 22.42 -6.046 c 8.601 -4.966 15.171 -12.43 18.997 -21.586 C 88.433 61.79 88.285 61.123 87.823 60.7 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: #ffa716; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
                    </g>
                    </svg>
                </div>
            </a>
            
                <a class="navbar-item" href="/en/">English</a>
            
            

        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2023/12/05/Event-Bubbling/" itemprop="url">冒泡和捕获</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2023-12-05T07:46:41.000Z" itemprop="datePublished">2023年12月5日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Vue/">Vue</a><span>></span><a class="article-category-link" href="/categories/Vue/Front-end/">Front-end</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2><span id="前言">前言</span></h2><p><strong>让我们从一个示例开始。</strong></p>
<p>处理程序（handler）被分配给了 <code>&lt;div&gt;</code>，但是如果你点击任何嵌套的标签（例如 <code>&lt;em&gt;</code> 或 <code>&lt;code&gt;</code>），该处理程序也会运行：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'The handler!'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">></span></span>If you click on <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>EM<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>, the handler on <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>DIV<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span> runs.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>So, if you click on EM, the handler on DIV runs.</p>
</blockquote>
<h2><span id="冒泡">冒泡</span></h2><p>冒泡（bubbling）原理很简单。</p>
<p><strong>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。</strong></p>
<p>假设我们有 3 层嵌套 <code>FORM &gt; DIV &gt; P</code> ，它们各自拥有一个处理程序：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">
  <span class="token selector">body *</span> <span class="token punctuation">&#123;</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 1px solid blue<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'form'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>FORM
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>DIV
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>P<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>现在，如果你点击 <code>&lt;p&gt;</code>，那么会发生什么？</strong></p>
<ol>
<li><p>首先，处理程序在 <code>&lt;p&gt;</code> 上运行。</p>
</li>
<li><p>然后，它在 <code>&lt;div&gt;</code> 上运行。</p>
</li>
<li><p>然后，它在 <code>&lt;form&gt;</code> 上运行。</p>
</li>
<li><p>最后，它在 document 上运行。</p>
</li>
</ol>
<p><strong>这种行为被称为“事件冒泡”，因为它像气泡一样从元素冒出来。</strong></p>
<p>因此，如果我们点击 <code>&lt;p&gt;</code>，那么我们将看到 3 个 alert：p → div → form。</p>
<h3><span id="eventtarget">event.target</span></h3><p>父元素上的处理程序始终可以获取事件实际发生位置的详细信息。</p>
<p><strong>引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过 event.target 访问。</strong></p>
<p>注意与 this（&#x3D;event.currentTarget）之间的区别：</p>
<ul>
<li><p><code>this</code> 是在处理程序运行时的“当前”元素，它始终相同。</p>
</li>
<li><p><code>event.target</code> 是在事件发生时的“目标”元素，它可以是任何元素，它在冒泡过程中改变。</p>
</li>
</ul>
<p>那我们来举个例子吧！</p>
<p><strong>例如，如果我们有一个处理程序 form.onclick，那么它可以“捕获”表单内的所有点击。无论点击发生在哪里，它都会冒泡到 <code>&lt;form&gt;</code> 并运行处理程序。</strong></p>
<p>注意哈！这边是将所有的事件都绑定到了 form 上，而不是每个元素上。</p>
<p>在 form.onclick 处理程序中：</p>
<p>this（&#x3D;event.currentTarget）是 <code>&lt;form&gt;</code> 元素，因为处理程序在它上面运行。<br>event.target 是表单中实际被点击的元素。</p>
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
</head>
<body>

<p>  A click shows both <code>event.target</code> and <code>this</code> to compare:</p>
  <form style="   background-color: green;
      position: relative;
      width: 150px;
      height: 150px;
      text-align: center;
      cursor: pointer;">FORM
    <div style="background-color: blue;
      position: absolute;
      top: 25px;
      left: 25px;
      width: 100px;
      height: 100px;">DIV
      <p style="background-color: red;
      position: absolute;
      top: 25px;
      left: 25px;
      width: 50px;
      height: 50px;
      line-height: 50px;
      margin: 0;">P</p>
    </div>
  </form>

  <script>
    form=document.querySelector('form');
    form.onclick = function(event) {
      // 输出事件目标和当前元素
      // （this=事件当前元素=form，event.target=事件目标=实际点击的元素）
      alert("target = " + event.target.tagName + ", this=" + this.tagName);
    };
  </script>
</body>
</html>

<h2><span id="停止冒泡">停止冒泡</span></h2><p>冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到 <code>&lt;html&gt;</code>，然后再到 document 对象，有些事件甚至会到达 window，它们会调用路径上所有的处理程序。</p>
<p>但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。</p>
<p>用于停止冒泡的方法是 event.stopPropagation()。</p>
<p>例如，如果你点击 <code>&lt;button&gt;</code>，这里的 body.onclick 不会工作：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">the bubbling doesn't reach here</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript">event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<div onclick="alert(`the bubbling doesn't reach here`)" style="width:150px;height:50px;background-color:red">
  <button onclick="event.stopPropagation()">Click me</button>
</div>

<h2><span id="捕获">捕获</span></h2><p><strong>事件处理的另一个阶段被称为“捕获（capturing）”。</strong></p>
<p>DOM 事件标准描述了事件传播的 3 个阶段：</p>
<ol>
<li>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</li>
<li>目标阶段（Target phase）—— 事件到达目标元素。</li>
<li>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</li>
</ol>
<p>下面是在表格中点击 <code>&lt;td&gt;</code> 的图片，摘自规范：</p>
<p><img src="/img/event-bubbling/eventbubling1.jpg" alt="Event-Bubbling"></p>
<p>也就是说：点击 <code>&lt;td&gt;</code>，事件首先通过祖先链向下到达元素（捕获阶段），然后到达目标（目标阶段），最后上升（冒泡阶段），在途中调用处理程序。</p>
<p>之前，我们只讨论了冒泡，因为捕获阶段很少被使用。通常我们看不到它。</p>
<p>使用 on<code>&lt;event&gt;</code> 属性或使用 HTML 特性（attribute）或使用两个参数的 addEventListener(event, handler) 添加的处理程序，对捕获一无所知，它们仅在第二阶段和第三阶段运行。</p>
<h2><span id="总结">总结</span></h2><p><strong>当一个事件发生时 —— 发生该事件的嵌套最深的元素被标记为“目标元素”（event.target）。</strong></p>
<ul>
<li>然后，事件从文档根节点向下移动到 event.target，并在途中调用分配了 addEventListener(…, true) 的处理程序（true 是 {capture: true} 的一个简写形式）。</li>
<li>然后，在目标元素自身上调用处理程序。</li>
<li>然后，事件从 event.target 冒泡到根，调用使用 on<code>&lt;event&gt;</code>、HTML 特性（attribute）和没有第三个参数的，或者第三个参数为 false&#x2F;{capture:false} 的addEventListener 分配的处理程序。</li>
</ul>
<p><strong>每个处理程序都可以访问 event 对象的属性：</strong></p>
<ul>
<li>event.target —— 引发事件的层级最深的元素。</li>
<li>event.currentTarget（&#x3D;this）—— 处理事件的当前元素（具有处理程序的元素）</li>
<li>event.eventPhase —— 当前阶段（capturing&#x3D;1，target&#x3D;2，bubbling&#x3D;3）。</li>
</ul>
<p>任何事件处理程序都可以通过调用 event.stopPropagation() 来停止事件，但不建议这样做，因为我们不确定是否确实不需要冒泡上来的事件，也许是用于完全不同的事情。</p>
<p>捕获阶段很少使用，通常我们会在冒泡时处理事件。这背后有一个逻辑。</p>
<p>事件处理程序也是如此。在特定元素上设置处理程序的代码，了解有关该元素最详尽的信息。特定于 <td> 的处理程序可能恰好适合于该 </td><td>，这个处理程序知道关于该元素的所有信息。所以该处理程序应该首先获得机会。然后，它的直接父元素也了解相关上下文，但了解的内容会少一些，以此类推，直到处理一般性概念并运行最后一个处理程序的最顶部的元素为止。</td></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2023/11/29/Custom-Elements/" itemprop="url">Vue Components 和 Web 组件Custom Elements</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2023-11-29T02:13:58.000Z" itemprop="datePublished">2023年11月29日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Vue/">Vue</a><span>></span><a class="article-category-link" href="/categories/Vue/Front-end/">Front-end</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2><span id="前言">前言</span></h2><p>Web 组件是一组 Web 原生 API 的总称，允许开发人员创建可重用的自定义元素。</p>
<p>Vue 和 Web Components 主要是互补技术。无论是将自定义元素集成到现有的 Vue 应用程序中，还是使用 Vue 构建和分发自定义元素，Vue 对使用和创建自定义元素都有出色的支持。</p>
<h2><span id="什么是custom-elements">什么是Custom Elements</span></h2><p>Web 组件的一个关键特性是创建自定义元素：即由 Web 开发人员定义行为的 HTML 元素，扩展了浏览器中可用的元素集。</p>
<p>Custom Elements有两种类型的自定义元素：</p>
<ul>
<li><strong>自定义内置元素（Customized built-in element）</strong> 继承自标准的 HTML 元素，例如 HTMLImageElement 或 HTMLParagraphElement。它们的实现定义了标准元素的行为。</li>
<li><strong>独立自定义元素（Autonomous custom element）</strong> 继承自 HTML 元素基类 HTMLElement。你必须从头开始实现它们的行为。</li>
</ul>
<h3><span id="自定义元素生命周期回调">自定义元素生命周期回调</span></h3><p>当然Custom Elements也有自定义元素生命周期回调</p>
<p><strong>一旦你的自定义元素被注册，当页面中的代码以特定方式与你的自定义元素交互时，浏览器将调用你的类的某些方法。</strong> 通过提供这些方法的实现，规范称之为生命周期回调，你可以运行代码来响应这些事件。</p>
<p>自定义元素生命周期回调包括：</p>
<ul>
<li>connectedCallback()：每当元素添加到文档中时调用。规范建议开发人员尽可能在此回调中实现自定义元素的设定，而不是在构造函数中实现。</li>
<li>disconnectedCallback()：每当元素从文档中移除时调用。</li>
<li>adoptedCallback()：每当元素被移动到新文档中时调用。</li>
<li>attributeChangedCallback()：在属性更改、添加、移除或替换时调用。有关此回调的更多详细信息，请参见响应属性变化。</li>
</ul>
<p>以下是一个记录这些生命周期事件的最小自定义元素示例：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 为这个元素创建类</span>
<span class="token keyword">class</span> <span class="token class-name">MyCustomElement</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLElement</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">static</span> observedAttributes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"color"</span><span class="token punctuation">,</span> <span class="token string">"size"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 必须首先调用 super 方法</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token function">connectedCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"自定义元素添加至页面。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token function">disconnectedCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"自定义元素从页面中移除。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token function">adoptedCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"自定义元素移动至新页面。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token function">attributeChangedCallback</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> newValue</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">属性 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 已变更。</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">"my-custom-element"</span><span class="token punctuation">,</span> MyCustomElement<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2><span id="在-vue-中使用自定义元素">在 Vue 中使用自定义元素​</span></h2><p>在 Vue 应用程序中使用自定义元素在很大程度上与使用原生 HTML 元素相同，但需要记住以下几点：</p>
<h3><span id="跳过组件解析">跳过组件解析​</span></h3><p><strong>默认情况下，Vue 会尝试将非原生 HTML 标签解析为已注册的 Vue 组件，然后再将其渲染为自定义元素。</strong> 这将导致 Vue 在开发过程中发出“无法解析组件”警告。为了让 Vue 知道某些元素应该被视为自定义元素并跳过组件解析，我们可以指定compilerOptions.isCustomElement选项。</p>
<p>如果您使用 Vue 进行构建设置，则该选项应通过构建配置传递，因为它是编译时选项。</p>
<p>浏览器内配置示例:</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Only works if using in-browser compilation.
&#x2F;&#x2F; If using build tools, see config examples below.
app.config.compilerOptions.isCustomElement &#x3D; (tag) &#x3D;&gt; tag.includes(&#39;-&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>Vite 配置示例​</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// vite.config.js</span>
<span class="token keyword">import</span> vue <span class="token keyword">from</span> <span class="token string">'@vitejs/plugin-vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token function">vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
      <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        <span class="token literal-property property">compilerOptions</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
          <span class="token comment">// treat all tags with a dash as custom elements</span>
          <span class="token function-variable function">isCustomElement</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token operator">=></span> tag<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Vue CLI 配置示例​</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// vue.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token function-variable function">chainWebpack</span><span class="token operator">:</span> <span class="token parameter">config</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    config<span class="token punctuation">.</span>module
      <span class="token punctuation">.</span><span class="token function">rule</span><span class="token punctuation">(</span><span class="token string">'vue'</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'vue-loader'</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token parameter">options</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
        <span class="token operator">...</span>options<span class="token punctuation">,</span>
        <span class="token literal-property property">compilerOptions</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
          <span class="token comment">// treat any tag that starts with ion- as custom elements</span>
          <span class="token function-variable function">isCustomElement</span><span class="token operator">:</span> <span class="token parameter">tag</span> <span class="token operator">=></span> tag<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'ion-'</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3><span id="使用-vue-构建自定义元素">使用 Vue 构建自定义元素​</span></h3><p>自定义元素的主要好处是它们可以与任何框架一起使用，甚至可以在没有框架的情况下使用。这使得它们非常适合分发最终消费者可能不使用相同前端堆栈的组件，或者当您希望将最终应用程序与其使用的组件的实现细节隔离时。</p>
<p><strong>定义自定义元素​</strong><br>Vue 支持通过该方法使用完全相同的 Vue 组件 API 创建自定义元素defineCustomElement。该方法接受与 相同的参数defineComponent，但返回一个扩展的自定义元素构造函数HTMLElement：</p>
<p>模板</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;my-vue-element&gt;&lt;&#x2F;my-vue-element&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> defineCustomElement <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> MyVueElement <span class="token operator">=</span> <span class="token function">defineCustomElement</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token comment">// normal Vue component options here</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>

  <span class="token comment">// defineCustomElement only: CSS to be injected into shadow root</span>
  <span class="token literal-property property">styles</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/* inlined css */</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">// Register the custom element.</span>
<span class="token comment">// After registration, all `&lt;my-vue-element>` tags</span>
<span class="token comment">// on the page will be upgraded.</span>
customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'my-vue-element'</span><span class="token punctuation">,</span> MyVueElement<span class="token punctuation">)</span>

<span class="token comment">// You can also programmatically instantiate the element:</span>
<span class="token comment">// (can only be done after registration)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>
  <span class="token keyword">new</span> <span class="token class-name">MyVueElement</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// initial props (optional)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当我们谈论自定义元素和Vue组件时，实际上在讨论构建网页应用程序时使用的两种不同方式。<strong>自定义元素是一种Web标准，就像HTML元素一样，而Vue组件是Vue.js框架提供的一种更高级的构建方式。</strong></p>
<p>有人认为只使用自定义元素是更“未来”的方式，但这段文字指出这种看法过于简单。它列举了一些原因，说明为什么Vue组件模型更为实用。其中一些关键点包括：</p>
<p>Vue组件提供了更多功能，如方便的模板系统、管理状态的方法，以及在服务器上渲染组件的高效方式。这些功能对于构建复杂的应用程序是必要的。</p>
<p>Vue组件支持强大的组合机制，而自定义元素在这方面有一些局限。这意味着使用Vue，你更容易构建灵活而强大的组件结构。使用Vue，你能够借助一个成熟的框架和庞大的社区，而不必自己构建和维护一套内部框架。</p>
<p>自定义元素和 Vue 组件之间确实存在一定程度的功能重叠：它们都允许我们定义具有数据传递、事件发出和生命周期管理的可重用组件。然而，Web 组件 API 的级别相对较低且简单。要构建实际的应用程序，我们需要一些该平台未涵盖的附加功能：</p>
<ul>
<li><p>声明性且高效的模板系统；</p>
</li>
<li><p>反应式状态管理系统，有利于跨组件逻辑提取和重用；</p>
</li>
<li><p>一种在服务器上渲染组件并在客户端 (SSR) 上进行组合的高性能方法，这对于 SEO 和LCP 等 Web Vitals 指标非常重要。原生自定义元素 SSR 通常涉及在 Node.js 中模拟 DOM，然后序列化变异的 DOM，而 Vue SSR 会尽可能编译为字符串连接，这更加高效。</p>
</li>
</ul>
<h3><span id="definecustomelement-api-vue-组件转化"><code>defineCustomElement</code> API Vue 组件转化</span></h3><p>使用 <code>defineCustomElement</code> API 将 Vue 组件转化为可以注册的自定义元素类有一些好处：</p>
<ol>
<li><p><strong>跨框架集成：</strong> 通过将 Vue 组件转化为自定义元素类，你可以在不同的前端框架和库中使用这个组件。这种方式使得你的组件更具通用性，可以与其他技术栈集成。</p>
</li>
<li><p><strong>独立使用：</strong> 将 Vue 组件注册为自定义元素后，它可以独立于 Vue 应用使用。这意味着你可以在没有整个 Vue 应用的情况下使用该组件，以及在不同的构建系统和模块系统中引入它。</p>
</li>
<li><p><strong>逐步迁移：</strong> 如果你的应用是逐步迁移到 Vue 的，你可以通过将某些组件转化为自定义元素来实现渐进式迁移。这使得你可以逐步地将 Vue 组件引入到一个已经存在的项目中，而无需一次性重写整个应用。</p>
</li>
<li><p><strong>Web Components 标准兼容性：</strong> 将 Vue 组件注册为自定义元素使其与 Web Components 标准兼容。这意味着你可以利用 Web Components 生态系统的其他工具和库，使你的组件更具互操作性。</p>
</li>
</ol>
<p>也就是说defineCustomElement API 的作用是将 Vue 组件编译为可以在浏览器中使用的自定义元素（Custom Element）。这意味着你不需要依赖 Vue 编译器在浏览器端实时编译 Vue 组件。</p>
<p>在使用 defineCustomElement API 时，Vue 组件会被提前编译成原生的自定义元素，这样就可以在浏览器中直接使用，而无需在运行时进行编译。</p>
<p>总体而言，通过使用 <code>defineCustomElement</code> API，你可以将 Vue 组件与自定义元素相结合，从而在更广泛的上下文中使用和共享这些组件，提高了组件的可复用性和灵活性。这在跨端组件开发集成上有很大的好处，你大可以先将组件开发成自定义元素，然后再在不同的端中使用。一个很典型的例子是我们之前提到的vue2和vue3的集成实现，这意味着你只需要将vue3的组件编译成自定义元素，然后在vue2中使用即可。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2023/11/28/vue5/" itemprop="url">Vue 2/3 共存开发的思路</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2023-11-28T15:40:22.000Z" itemprop="datePublished">2023年11月28日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Vue/">Vue</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2><span id="前言">前言</span></h2><p>2023 年 12 ⽉ 31 ⽇后，功能仍然可⽤，但不再提供更新，包括<br>• 安全更新<br>• 浏览器兼容</p>
<p>Evan 宣布 Vue 3 的第一个 RC将于 7 月中旬发布。这篇文章建议库&#x2F;插件作者开始迁移对 Vue 3 的支持。但是由于 API 和行为发生了很大变化，<strong>是否有可能使我们的库同时支持 Vue 2 和 3 ？</strong></p>
<h3><span id="通用代码">通用代码</span></h3><p>最简单的方法是编写适用于<strong>两个版本的通用代码</strong> ，无需任何额外的修改，就像人们对Python 2 和 3所做的那样。简单并不意味着容易。编写此类组件需要避免<strong>Vue 3 中新引入的内容</strong> 以及<strong>Vue 2 中弃用的内容</strong> 。换句话说，您不能使用：</p>
<ul>
<li>合成API</li>
<li>.sync .native修饰语</li>
<li>过滤器</li>
<li>3rd 方供应商对象</li>
</ul>
<h3><span id="使用分支">使用分支</span></h3><p>核心团队成员对此问题的回复建议使用不同的分支来分隔对每个定位版本的支持。我认为这对于现有和成熟的库来说是一个很好的解决方案，因为它们的代码库通常更稳定，并且版本目标优化可能需要它们具有更好的代码隔离。</p>
<p>这样做的缺点是您需要维护两个代码库，这会使您的工作量增加一倍。对于小型库或想要支持两个版本的新库来说，进行两次错误修复或功能补充是不理想的。我不建议在项目一开始就使用这种方法。</p>
<h3><span id="构建脚本">构建脚本</span></h3><p>在VueUse中，编写了一些构建脚本，以便在构建时从目标版本的 API 导入代码。之后，我需要发布两个标签vue2 vue3来区分不同版本的支持。有了这个，我可以编写一次代码并使库支持两个 Vue 版本。它的问题是我需要在每个版本上构建两次并引导用户安装相应的插件版本（@vue&#x2F;composition-api对于Vue 2则需要手动安装）。</p>
<h2><span id="vue-2x2f3-共存开发的思路">Vue 2&#x2F;3 共存开发的思路</span></h2><h3><span id="同时支持-vue-2x2f3-项目">同时⽀持 Vue 2&#x2F;3 项⽬</span></h3><h4><span id="vue-2x2f3-项目存在的可能场景">Vue 2&#x2F;3 项⽬存在的可能场景</span></h4><p><strong>渐进式迁移：</strong> 如果有一个较大的 Vue 2 项目，但是想要逐步迁移到 Vue 3，可以选择在项目中同时引入 Vue 3，然后逐步将 Vue 2 组件迁移到 Vue 3。</p>
<p><strong>依赖库和插件兼容性：</strong> 如果项目依赖于一些 Vue 2 的插件或库，而这些插件或库还没有升级到 Vue 3，可能需要同时使用 Vue 2 和 Vue 3 以确保兼容性。</p>
<p><strong>新功能采用 Vue 3：</strong> 可能希望项目中使用 Vue 3 来利用其新功能和性能优势，同时保留 Vue 2 用于旧的组件或功能。</p>
<p><strong>项⽬融合者：</strong> 公司内部基于体验要求，需要 Vue 2&#x2F;3项⽬呈现在同⼀⻚⾯中</p>
<p><strong>内部组件资产维护者：</strong> 需要在 Vue 2&#x2F;3 的项⽬都⽀持，且能⼒必须⼀致</p>
<p><strong>⽼项⽬应⽤开发者：</strong> 需要⽤到⼀个第三⽅图表组件，但只有 Vue 3 版本，⽽⾮ Vue 2 版本</p>
<h3><span id="解决方案">解决⽅案</span></h3><h4><span id="1-vue-2x2f3-项目共存">1. Vue 2&#x2F;3 项⽬共存</span></h4><p><img src="/img/vue5/vue5-1.png" alt="vue-5"></p>
<p>直接通过 Vue 3 的 createApp 创建⼀个 Vue 3 的根实例，然后通过 Vue 2 的 mount ⽅法挂载到 Vue 2 的根实例上，这样就可以在 Vue 2 的项⽬中使⽤ Vue 3 的组件。</p>
<p>相关的代码仓库贴在这里，大家自取：<a target="_blank" rel="noopener" href="https://github.com/ikkkp/vue5">vue5</a></p>
<p><img src="/img/vue5/vue5-2.jpg" alt="vue-5"></p>
<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// Vue 3 项⽬</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> createApp <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>

<span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#vue3'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// Vue 2 项⽬</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue2'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> h <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>App <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#vue2'</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这一个思路重要的是我们采用配置vite.config.ts解决不同模块的编译问题：编写了一些构建脚本，以便在构建时从目标版本的 API 导入代码。之后，我需要发布两个标签vue2 vue3来区分不同版本的支持。但是它的问题其实是需要在每个版本上引导用户安装相应的插件版本。这对于开发者处理包冲突问题并不是很友好。</p>
<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> path <span class="token keyword">from</span> <span class="token string">'path'</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> defineConfig <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vite'</span>
<span class="token keyword">import</span> Vue2 <span class="token keyword">from</span> <span class="token string">'@vitejs/plugin-vue2'</span>
<span class="token keyword">import</span> Vue3 <span class="token keyword">from</span> <span class="token string">'@vitejs/plugin-vue'</span>
<span class="token keyword">import</span> Inspect <span class="token keyword">from</span> <span class="token string">'vite-plugin-inspect'</span>
<span class="token keyword">import</span> compiler <span class="token keyword">from</span> <span class="token string">'vue2/compiler-sfc'</span>

<span class="token keyword">const</span> src <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'src'</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token function">Vue3</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
      include<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">vue3[/\\].*\.vue$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Vue2</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
      include<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">vue2[/\\].*\.vue$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      compiler<span class="token operator">:</span> compiler <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Inspect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样我们属于是将Vue2和Vue3单独做成了两个独立的包，然后在vite.config.ts中配置了不同的编译规则，这样就可以在同一个页面中使用Vue2和Vue3。</p>
<h4><span id="2-jessicasachsx2fpetite-方案">2. JessicaSachs&#x2F;petite 方案</span></h4><p>先来简单介绍一下<a target="_blank" rel="noopener" href="https://github.com/JessicaSachs/petite">petite</a>：</p>
<blockquote>
<p><strong>Petite是一个为Vue组件作者构建的主观GitHub模板。</strong> 它设置了开发、文档和测试通用SFC组件所需的工具，并与Vue 2.7运行时向后兼容。</p>
</blockquote>
<p>这是通过一些运行时辅助函数和一个非常主观的单体库结构实现的。</p>
<p>Petite设置了Vite、Volar、Linting、Vitepress、TypeScript和Testing，这样您就可以选择编写Vue 3风格的代码，同时轻松保持对Vue 2.x用户的向后兼容性。</p>
<p>而这也意味着您将在 npm 上发布软件包的两个版本，而不是为了支持 Vue 2 或 Vue 3 而中断主要版本。</p>
<p><strong>这样做的缺点是您的用户在升级和更改导入时需要安装新版本。</strong> 好处是您可以更轻松地编写向后兼容的代码并为用户提供定期升级。此外，您还可以拆分仅 Vue 2 和仅 Vue 3 的依赖项。</p>
<p>如果您在通用代码中使用lodash，您将需要在工作区根目录中运行后pnpm build，每个包 ( lib-vue3、lib-vue2) 应独立部署。</p>
<h4><span id="3-vue-bridge-方案">3. vue-bridge 方案</span></h4><h4><span id="4-vue-demi-方案">4. vue-demi 方案</span></h4><p>仓库实例：<a target="_blank" rel="noopener" href="https://github.com/ikkkp/vue5-baseon-vue-demi">vue-demi</a></p>
<p>Vue Demi是一个开发实用程序，允许您为 Vue 2 和 3 编写通用 Vue 库。无需担心用户安装的版本。</p>
<p>当您要创建 Vue 插件&#x2F;库时，只需安装vue-demi为依赖项并从中导入与 Vue 相关的任何内容即可。像往常一样发布你的插件&#x2F;库，你的包将变得通用！</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;
  &quot;dependencies&quot;: &#123;
    &quot;vue-demi&quot;: &quot;latest&quot;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> Vue<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> reactive<span class="token punctuation">,</span> ref <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue-demi'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在底层，它使用了postinstallnpm hook。安装所有包后，脚本将开始检查已安装的 Vue 版本，并将导出重定向到基于本地 Vue 版本。使用 Vue 2 时，@vue&#x2F;composition-api如果未安装，它也会自动安装。</p>
<p>所需要注意的有关于库&#x2F;组件的点：</p>
<p><strong>库&#x2F;组件</strong></p>
<ul>
<li>单仓库 - 多个包构建</li>
<li>依赖管理</li>
<li>alias 别名配置<ul>
<li>npm 包名</li>
<li>构建工具配置</li>
</ul>
</li>
</ul>
<h3><span id="vue-2-应用中引入-vue-3-组件">Vue 2 应⽤中引⼊ Vue 3 组件</span></h3><p><strong>会有组件互操作的限制</strong></p>
<ul>
<li>context 共享</li>
<li>scoped slots</li>
<li>事件</li>
</ul>
<p><strong>Vue 2 应⽤中引⼊ Vue 3 组件的思路</strong></p>
<ul>
<li>Vue 3 可以有多个全局实例</li>
<li>前提：Vue 2 升级到 2.7、Vue CLI 移除部分过时插件</li>
<li>互操作层：Custom Elements</li>
<li>构建⼯具：Vite</li>
</ul>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2023/11/24/2023-11-24-Writing/" itemprop="url">2023-11-24-随笔</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2023-11-23T16:21:52.000Z" itemprop="datePublished">2023年11月24日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Essay/">Essay</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>「人的一切痛苦，本质上都是对自己无能的愤怒」</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2023/11/22/2023-11-22-Writing/" itemprop="url">2023-11-22 随笔</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2023-11-22T15:55:21.000Z" itemprop="datePublished">2023年11月22日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Essay/">Essay</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>“你不爱我的时候 我可能还是爱你 同时爱那个曾经的自己<br>他又可爱 执迷不悟 又不可复制 其实谢谢你的体贴 这些日子 天又蓝又晴”</p>
<p>——《陪安东尼度过漫长岁月》</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2023/11/20/ModernWeb-Debugging1/" itemprop="url">ModernWeb-有关于Chrome本地代码调试的简单记录</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2023-11-20T11:06:50.000Z" itemprop="datePublished">2023年11月20日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Chrome/">Chrome</a><span>></span><a class="article-category-link" href="/categories/Chrome/devtools/">devtools</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2><span id="引言">引言</span></h2><p>自从上周去开了个前端的会议之后，对于前端的一些新技术有了一些新的认识，其中就有关于Chrome本地代码调试的一些新的认识，所以这里就简单的记录一下。这边先贴一个链接：<a target="_blank" rel="noopener" href="https://www.youtube.com/@ChromeDevs">youtube-ChromeDevs</a></p>
<p>这边要先感谢下<code>chrome的devtools团队</code>，他们的工作真的是太棒了，但是在 <code>jecfish</code> 的前端会议技术分享之前我却并不知道有这么多友好的web调试工具和性能测试手段，所以这里就简单的记录一下，大家要是有兴趣的话可以去看看上面的链接，里面有很多有用的东西，也欢迎给他们团队贴贴关注。</p>
<p>下面将先给出本章的大纲，然后再逐步展开。</p>
<p><img src="/img/ModernWeb/modernWeb1.jpg" alt="ModernWeb"></p>
<h2><span id="本地代码调试">本地代码调试</span></h2><p>这边的内容将是有关于本地代码调试，主要是有关于<code>source-map</code>的一些内容，这边将会有一些简单的介绍，然后再给出一些简单的例子。</p>
<h3><span id="对源代码映射source-map的需求">对源代码映射source-map的需求</span></h3><iframe width="100%" src="https://www.youtube.com/embed/FIYkjjFYvoI" title="What are source maps? | DevTools Tips" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<p>这边先给出一个链接：<a target="_blank" rel="noopener" href="https://web.dev/articles/source-maps?hl=zh-cn">source-map</a></p>
<p>这个链接是jecfish写的有关于source-map的一些内容要是大家有兴趣的话，可以去里面看看，要是文章太长大家看不下去的话，可以直接看下面的内容。</p>
<p>今天，我们要讨论的是源代码映射，这是一种现代 Web 开发中的重要工具，可大幅简化调试工作。在本文中，我们将探讨源代码映射的基础知识、源代码映射的生成方式以及源代码映射如何改善调试体验。</p>
<p>好嘟，要进入source-map的学习认知，我们得先要对Modern Web有一个最基本的认识。那我们来看看当我说到Modern Web的时候我们该聊些什么？</p>
<p><img src="/img/ModernWeb/modernWeb3.jpg" alt="ModernWeb"></p>
<p>我们可以看到控制台打印了一些BaseOn Css样式的一些内容，但我们今天虽然并不准备着重讲这个console的Css样式，但你依然可以在console定义一些样式让你的console打印的更漂亮！</p>
<p><img src="/img/ModernWeb/modernWeb4.jpg" alt="ModernWeb"></p>
<p><img src="/img/ModernWeb/modernWeb5.jpg" alt="ModernWeb"></p>
<p>时隔15年的时间，我们可以看到chrome开发者模式的调试工具从原来的寥寥几种，到现在的丰富多彩，这其中的变化是非常大的，所以我们今天就来聊聊这32种调试工具在chrome之中具体的应用。</p>
<p><img src="/img/ModernWeb/modernWeb6.jpg" alt="ModernWeb"></p>
<p><strong>我们知道浏览器只认识HTML &lt;&#x2F;&gt; CSS {;} JavaScript (,) Wasm（当然是现在浏览器引擎默认都内置了对Wasm模块的支持） 这几种语言，但是我们的前端框架却异常的丰富</strong> ，涉及到的语言：ts、less、sass，框架：Vue、React，Meta 框架：nust.js、next.js，这些框架都是在我们的前端代码中使用的，但是浏览器并不认识这些语言，所以我们需要将这些语言转换成浏览器认识的语言。</p>
<p>我们正在构建更复杂的 Web 应用，您的开发工作流可能会涉及到使用各种工具。例如：</p>
<ul>
<li>模板语言和 HTML 预处理器：Pug、Nunjucks、Markdown。</li>
<li>CSS 预处理器：SCSS、LESS、PostCSS。</li>
<li>JavaScript 框架：Angular、React、Vue、Svelte。</li>
<li>JavaScript 元框架：Next.js、Nuxt、Astro。</li>
<li>高级编程语言：TypeScript、Dart、CoffeeScript。<br>等等。这个名单还在不断加长！</li>
</ul>
<p><img src="/img/ModernWeb/modernWeb7.png" alt="ModernWeb"></p>
<p><strong>这些工具需要一个构建流程，以将代码转译为浏览器可以理解的标准 HTML、JavaScript 和 CSS。</strong>此外，为了优化性能，通常的做法是压缩（例如，使用 Terser 缩减和破坏 JavaScript）和合并这些文件，以缩减其大小并提高 Web 效率。</p>
<p>而将这众多的模板语言和预处理器、元框架转化成浏览器可以看得懂的 HTML、JavaScript 和 CSS，这个过程就是编译，而编译的过程中就会产生一些中间代码，这些中间代码就是我们的源代码映射，这个 <strong>源代码映射</strong> 就是我们今天要讲的内容。</p>
<p>例如，使用构建工具，我们可以将以下 TypeScript 文件转译并压缩为一行 JavaScript。这个demo在github上面也有：<a target="_blank" rel="noopener" href="https://github.com/jecfish/parcel-demo">parcel-demo</a></p>
<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/* A TypeScript demo: example.ts */</span>

document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token operator">?.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> num<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> greet<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'Hello'</span><span class="token punctuation">;</span>
  <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> HTMLParagraphElement<span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>greet<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, you are no. </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>num<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>压缩版本如下所示：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/* A compressed JavaScript version of the TypeScript demo: example.min.js  */</span>

document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">)</span><span class="token operator">?.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token keyword">const</span> e<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token operator">*</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText<span class="token operator">=</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, you are no. </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>e<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>不过，这项优化会增加调试难度。如果压缩代码将所有内容放在一行中，并且变量名称较短，则很难查明问题的根源。这正是源映射的用武之地，它们会将编译后的代码映射回原始代码。</p>
<p><img src="/img/ModernWeb/modernWeb8.jpg" alt="ModernWeb"></p>
<p>我们现在来具体看一个例子，这个例子是一个用ts代码写的简单的click事件触发的xhr，其中报了404错误。</p>
<p><img src="/img/ModernWeb/modernWeb9.jpg" alt="ModernWeb"></p>
<p>哎？发生什么事了，注意看红色箭头处，看来我们浏览器看得懂ts代码？</p>
<p><img src="/img/ModernWeb/modernWeb10.jpg" alt="ModernWeb"></p>
<p><img src="/img/ModernWeb/modernWeb11.jpg" alt="ModernWeb"></p>
<p>其实不然，看着这贴着的这张图，其实这个ts是从main.js里面解析过来的</p>
<h3><span id="了解源代码映射source-map">了解源代码映射source-map</span></h3><p><img src="/img/ModernWeb/modernWeb12.jpg" alt="ModernWeb"></p>
<p>这些源映射文件包含关于已编译代码如何映射到原始代码的基本信息，让开发者能够轻松地进行调试。下面是一个源映射的示例。</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;
  &quot;mappings&quot;: &quot;AAAAA,SAASC,cAAc,WAAWC, ...&quot;,
  &quot;sources&quot;: [&quot;src&#x2F;script.ts&quot;],
  &quot;sourcesContent&quot;: [&quot;document.querySelector(&#39;button&#39;)...&quot;],
  &quot;names&quot;: [&quot;document&quot;,&quot;querySelector&quot;, ...],
  &quot;version&quot;: 3,
  &quot;file&quot;: &quot;example.min.js.map&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>要了解其中每个字段，您可以阅读<a target="_blank" rel="noopener" href="https://bit.ly/sourcemap">源映射规范</a>或这篇关于<a target="_blank" rel="noopener" href="https://developer.chrome.com/blog/sourcemaps/?hl=zh-cn#the-anatomy-of-a-source-map">源映射剖析</a>的经典文章。</p>
<p>源映射最重要的方面是 mappings 字段。它使用 VLQ base 64 编码字符串将已编译文件中的行和位置映射到对应的原始文件。可使用 <a target="_blank" rel="noopener" href="https://sokra.github.io/source-map-visualization/">source-map-visualization</a> 和<a target="_blank" rel="noopener" href="https://evanw.github.io/source-map-visualization/">来源映射可视化</a>等来源映射可视化工具直观呈现此映射。</p>
<p><img src="/img/ModernWeb/modernWeb13.png" alt="ModernWeb"></p>
<p>左侧的生成的列会显示压缩内容，而原始列会显示原始来源。</p>
<p>可视化工具会以颜色代码对 original 列中的每一行以及 generated 列中的相应代码进行颜色编码。</p>
<p>mapping 部分显示了已解码的代码映射。例如，条目 65-&gt; 2:2 表示：</p>
<ul>
<li>生成的代码：const 一词在压缩内容中的位置 65 处开始。</li>
<li>原始代码：const 一词从原始内容中的第 2 行和第 2 列开始。</li>
</ul>
<p>这样一来，开发者便可以快速识别缩减后的代码与原始代码之间的关系，从而使调试过程更加顺畅。</p>
<p>浏览器开发者工具应用这些源代码映射，帮助您直接在浏览器中更快地查明调试问题。</p>
<p><img src="/img/ModernWeb/modernWeb14.png" alt="ModernWeb"></p>
<p><img src="/img/ModernWeb/modernWeb15.jpg" alt="ModernWeb"></p>
<p><img src="/img/ModernWeb/modernWeb16.jpg" alt="ModernWeb"></p>
<h3><span id="devtools-怎么知道该隐藏啥source-maps">DevTools 怎么知道该隐藏啥？Source maps</span></h3><p><img src="/img/ModernWeb/modernWeb17.jpg" alt="ModernWeb"></p>
<p><img src="/img/ModernWeb/modernWeb18.jpg" alt="ModernWeb"></p>
<p><img src="/img/ModernWeb/modernWeb19.jpg" alt="ModernWeb"></p>
<h2><span id="实用的chrome调试技巧">实用的chrome调试技巧</span></h2><h3><span id="请求">请求</span></h3><p><img src="/img/ModernWeb/modernWeb20.jpg" alt="ModernWeb"></p>
<p>你可以在Network面板中查看请求的详细信息，包括请求头、响应头、请求体、响应体、Cookies、Timing等等。</p>
<p>同时，devTools <a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/devtools/overrides/">devtools&#x2F;overrides</a> 也提供了通过本地覆盖，可以覆盖 HTTP 响应标头和Web 内容（包括XHR 和获取请求）来模拟远程资源，即使您无权访问它们。这使您可以对更改进行原型设计，而无需等待后端支持它们。本地覆盖还允许您在页面加载期间保留在 DevTools 中所做的更改。</p>
<p>这个东西在什么情况特别有用呢？</p>
<p>比如说，前端向后端发起的请求，后端返回的结果，可能还未进行跨域的处理（当然跨域的处理在后端做），那前端拿到的这个结果其实已经访问成功了，拿到了正确的数据，但是由于浏览器的安全策略，将此文件报告为不可信赖，这个时候我们就可以通过本地覆盖，来模拟后端返回的结果，这样就可以在前端进行调试了。</p>
<p>或者说有些数据在后端还未修改，前端拿到的数据是旧的，那我要干巴巴跟后端工程师小眼瞪大眼等着他们把数据改好了我们再进行工作嘛？这样实在是有点蠢hhhhh，我们可以通过重写content进行修改，这样就可以在前端进行调试了。</p>
<p><img src="/img/ModernWeb/modernWeb21.jpg" alt="ModernWeb"></p>
<p>那这个devtools&#x2F;overrides确实是有点牛逼的，那它是怎么运行的：</p>
<ul>
<li>当您在 DevTools 中进行更改时，DevTools 会将修改后的文件的副本保存到您指定的文件夹中。</li>
<li>当您重新加载页面时，DevTools 会提供本地修改后的文件，而不是网络资源。</li>
</ul>
<h4><span id="覆盖网页内容">覆盖网页内容</span></h4><h5><span id="设置文件夹"><strong>设置文件夹</strong></span></h5><ul>
<li>设置本地覆盖。</li>
<li>对文件进行更改并将其保存在 DevTools 中。</li>
</ul>
<p>例如，您可以在“源”中编辑文件，或在“元素” &gt; “样式”中编辑 CSS，除非 CSS 位于HTML 文件中。</p>
<p>DevTools 保存修改后的文件，在<strong>Sources &gt; Overrides</strong> 中列出它们，并在相关面板和窗格中显示已保存。被覆盖文件旁边的图标：<strong>Elements &gt; Styles、Network</strong> 和<strong>Sources &gt; Overrides</strong> 。</p>
<h5><span id="覆盖-xhr-或获取请求以模拟远程资源"><strong>覆盖 XHR 或获取请求以模拟远程资源</strong></span></h5><p>通过本地覆盖，您不需要访问后端，也不必等待它支持您的更改。即时模拟和实验：</p>
<ul>
<li>设置本地覆盖。</li>
<li>在Network中，过滤XHR&#x2F;fetch requests，找到您需要的请求，右键单击它，然后选择Override content。</li>
<li>对获取的数据进行更改并保存文件。</li>
<li>刷新。 刷新页面并观察应用的更改。</li>
</ul>
<p>要了解此工作流程，请观看以下视频：</p>
<p><video class="screenshot" width="100%" style="--vid-width: 800; --vid-height: 704" muted loop controls> <source src="https://storage.googleapis.com/web-dev-uploads/video/NJdAV9UgKuN8AhoaPBquL7giZQo1/TNcd8DCxoK6OmHQqJjKT.mp4" type="video/mp4"> </video></p>
<h4><span id="覆盖-http-响应标头">覆盖 HTTP 响应标头</span></h4><p>在“网络”面板中，您可以覆盖 HTTP 响应标头，而无需访问 Web 服务器。</p>
<p>通过响应标头覆盖，您可以在本地对各种标头进行原型修复，包括但不限于：</p>
<ul>
<li>跨源资源共享 (CORS) 标头</li>
<li>权限-策略标头</li>
<li>跨源隔离标头</li>
<li>要覆盖响应标头：</li>
</ul>
<p>设置本地覆盖并检查。</p>
<p>转到Network，找到请求，右键单击它，然后选择Override headers。DevTools 将带您进入<strong>标头&gt;响应标头编辑器</strong> 。</p>
<p><img src="/img/ModernWeb/headers.avif" alt="ModernWeb"></p>
<h3><span id="录制器有利于调试和测试">录制器，有利于调试和测试</span></h3><p>基于Chrome DevTools <a target="_blank" rel="noopener" href="https://developer.chrome.com/blog/extend-recorder/#export-json">Recorder</a> 的自定义和自动化用户流</p>
<p><img src="/img/ModernWeb/modernWeb22.jpg" alt="ModernWeb"></p>
<p>编写自动化测试并不是开发人员生活中最有趣的事情。作为开发人员，事实上确实需要功能、修复错误并改善世界！然而，当我们的工作流程中没有自动化测试时，从长远来看，事情可能会变得相当“错误”。所以，我们也认为编写自动化测试很重要。</p>
<p>使用Chrome DevTools 中的<a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/devtools/recorder/">Recorder</a> 面板，您可以录制和重放用户流程，通过不同的第三方扩展和库将其导出为各种格式（例如测试脚本），使用 Puppeteer Replay 库自定义用户流程，并将其与您现有的工作流程。</p>
<p>在这篇博文中，我们将讨论：</p>
<ul>
<li>如何以编程方式导出和重放用户流。</li>
<li>如何借助 Puppeteer Replay 自定义用户流程。</li>
<li>如何与您的<a target="_blank" rel="noopener" href="https://www.redhat.com/en/topics/devops/what-is-ci-cd">CI&#x2F;CD</a>工作流程集成。</li>
</ul>
<iframe width="100%" frameborder="0" allow="accelerometer; encrypted-media; gyroscope; picture-in-picture" allowfullscreen src="https://www.youtube.com/embed/LBgzmqzp7ew?autoplay=1&amp;start=0&amp;null"></iframe>


<h4><span id="以编程方式导出用户流并重播">以编程方式导出用户流并重播</span></h4><p>默认情况下，Recorder 使您能够将这些录音导出为<a target="_blank" rel="noopener" href="https://pptr.dev/">Puppeteer</a>或<a target="_blank" rel="noopener" href="https://github.com/puppeteer/replay">Puppeteer Replay</a>脚本，或者导出为纯 JSON 文件。</p>
<p><img src="/img/ModernWeb/record.avif" alt="ModernWeb"></p>
<h4><span id="使用-puppeteer-replay-进行重播">使用 Puppeteer Replay 进行重播</span></h4><p>将用户流导出为 JSON 文件后，您可以选择将其导入回记录器面板并重播，或使用外部库来重播。Puppeteer Replay库是可用的库之一。</p>
<img width="100%" src="https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format" sizes="(min-width:800px) 800px,calc(100vw - 48px)" srcset="https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=200 200w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=228 228w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=260 260w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=296 296w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=338 338w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=385 385w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=439 439w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=500 500w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=571 571w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=650 650w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=741 741w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=845 845w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=964 964w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=1098 1098w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=1252 1252w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=1428 1428w,https://wd.imgix.net/image/S3bCpnsKr6OqVjAww1n02HOXFsv1/Qzo4QVUa4A6HpXhHm5MI.gif?auto=format&amp;w=1600 1600w" alt="重播扩展允许扩展向 DevTools 添加面板来配置重播并显示重播结果。" loading="lazy" decoding="async">

<p>Puppeteer Replay 是一个库，可帮助您重播用户流程。它是一个基于 Puppeteer 的库，它允许您在浏览器中重播用户流程，而无需编写任何代码。您可以使用 Puppeteer Replay 重播您的用户流程，以确保您的应用程序在不同的环境中运行良好。</p>
<h4><span id="与-cix2fcd-管道集成">与 CI&#x2F;CD 管道集成</span></h4><p>有多种方法可以做到这一点，并且有很多工具。以下是使用GitHub Actions自动执行此过程的示例：</p>
<pre class="line-numbers language-none"><code class="language-none"># .github&#x2F;node.js.yml

name: Replay recordings

on:
  push:
    branches: [ &quot;main&quot; ]
  schedule:
    - cron: &#39;30 12 * * *&#39; # daily 12:30pm

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions&#x2F;checkout@v3
    - name: Use Node.js
      uses: actions&#x2F;setup-node@v3
      with:
        node-version: 18.x
        cache: &#39;npm&#39;
    - run: npm install puppeteer
    - run: npm run replay-all
    - run: npm run start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在此示例中，我们将在以下情况下重播用户流：</p>
<p>新的变更推送到main分支<br>每天中午 12:30<br>除了 GitHub Actions 之外，您还可以与您最喜欢的云提供商集成。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2023/11/11/vue-renderer-4/" itemprop="url">vue-renderer 渲染器的核心 Diff 算法</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2023-11-11T08:28:57.000Z" itemprop="datePublished">2023年11月11日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Vue/">Vue</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2><span id="前言">前言</span></h2><p>渲染器的核心就是 Diff 算法。简单来说，当新旧 vnode 的子节点都是一组节点时，为了以最小的性能开销完成更新操作，需要比较两组子节点，用于比较的算法就叫作 Diff 算法。我们知道，操作 DOM 的性能开销通常比较大，而渲染器的核心 Diff 算法就是为了解决这个问题而诞生的。</p>
<h2><span id="减少-dom-操作的性能开销">减少 DOM 操作的性能开销</span></h2><p>核心 Diff 只关心新旧虚拟节点都存在一组子节点的情况。针对两组子节点的更新，我们之前采用了一种简单直接的手段，即卸载全部旧子节点，再挂载全部新子节点。这么做的确可以完成更新，但由于没有复用任何 DOM 元素，所以会产生极大的性能开销。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 旧 vnode</span>
<span class="token keyword">const</span> oldNode <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'1'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'2'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'3'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 新 vnode</span>
<span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'4'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'5'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'6'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>按照之前的做法，当更新子节点时，我们需要执行 6 次 DOM 操作：</p>
<ul>
<li>卸载所有旧子节点，需要 3 次 DOM 删除操作；</li>
<li>挂载所有新子节点，需要 3 次 DOM 添加操作。</li>
</ul>
<p>但是，通过观察上面新旧 vnode 的子节点，可以发现：更新前后的所有子节点都是 p 标签，即标签元素不变；只有 p 标签的子节点（文本节点）会发生变化。</p>
<p>例如，oldVNode 的第一个子节点是一个 p 标签，且该 p 标签的子节点类型是文本节点，内容是 ‘1’。而 newVNode 的第一个子节点也是一个 p 标签，它的子节点的类型也是文本节点，内容是 ‘4’。可以发现，更新前后改变的只有 p 标签文本节点的内容。</p>
<p>所以，最理想的更新方式是，直接更新这个 p 标签的文本节点的内容。这样只需要一次 DOM 操作，即可完成一个 p 标签更新。新旧虚拟节点都有 3 个 p标签作为子节点，所以一共只需要 3 次 DOM 操作就可以完成全部节点的更新。相比原来需要执行 6 次 DOM 操作才能完成更新的方式，其性能提升了一倍。</p>
<p>按照这个思路，我们可以重新实现两组子节点的更新逻辑，如下面 patchChildren 函数的代码所示：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span><span class="token parameter">n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> n2<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 省略部分代码</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 重新实现两组子节点的更新方式</span>
    <span class="token comment">// 新旧 children</span>
    <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
    <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
    <span class="token comment">// 遍历旧的 children</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 调用 patch 函数逐个更新子节点</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 省略部分代码</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这段代码中，oldChildren 和 newChildren 分别是旧的一组子节点和新的一组子节点。我们遍历前者，并将两者中对应位置的节点分别传递给 patch 函数进行更新。patch 函数在执行更新时，发现新旧子节点只有文本内容不同，因此只会更新其文本节点的内容。这样，我们就成功地将 6 次 DOM 操作减少为 3 次。其中菱形代表新子节点，矩形代表旧子节点，圆形代表真实 DOM 节点。</p>
<p><img src="/img/vue-render/render-diff1.png" alt="render-diff"></p>
<p>这种做法虽然能够减少 DOM 操作次数，但问题也很明显。在上面的代码中，我们通过遍历旧的一组子节点，并假设新的一组子节点的数量与之相同，只有在这种情况下，这段代码才能正确地工作。但是，新旧两组子节点的数量未必相同。当新的一组子节点的数量少于旧的一组子节点的数量时，意味着有些节点在更新后应该被卸载。</p>
<p><img src="/img/vue-render/render-diff2.png" alt="render-diff"></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2023/11/10/Webpack-optimization-4/" itemprop="url">Webpack HMR 原理解析</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2023-11-10T02:15:11.000Z" itemprop="datePublished">2023年11月10日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Webpack/">Webpack</a><span>></span><a class="article-category-link" href="/categories/Webpack/Front-end/">Front-end</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2><span id="前言">前言</span></h2><p>Hot Module Replacement（以下简称 HMR）是 Webpack 发展至今一大特性 ，当你对代码进行修改并保存后，Webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。</p>
<p>例如，在开发 Web 页面过程中，当你点击按钮，出现一个弹窗的时候，发现弹窗标题没有对齐，这时候你修改 CSS 样式，然后保存，在浏览器没有刷新的前提下，标题样式发生了改变。感觉就像在 Chrome 的开发者工具中直接修改元素样式一样。</p>
<h2><span id="模块热替换hot-module-replacement">模块热替换(hot module replacement)</span></h2><p><code>模块热替换(HMR - hot module replacement)</code>功能会在应用程序运行过程中，替换、添加或删除 模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：</p>
<ul>
<li><p>保留在完全重新加载页面期间丢失的应用程序状态。</p>
</li>
<li><p>只更新变更内容，以节省宝贵的开发时间。</p>
</li>
<li><p>在源代码中 CSS&#x2F;JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</p>
</li>
</ul>
<h2><span id="为什么需要-hmr">为什么需要 HMR</span></h2><p>在 webpack HMR 功能之前，已经有很多 live reload 的工具或库，比如 <a target="_blank" rel="noopener" href="https://tapiov.net/live-server/">live-server</a>，这些库监控文件的变化，然后通知浏览器端刷新页面，那么我们为什么还需要 HMR 呢？答案其实在上文中已经提及一些。</p>
<ul>
<li><p>live reload 工具并不能够保存应用的状态（states），当刷新页面后，应用之前状态丢失，还是上文中的例子，点击按钮出现弹窗，当浏览器刷新后，弹窗也随即消失，要恢复到之前状态，还需再次点击按钮。而 webapck HMR 则不会刷新浏览器，而是运行时对模块进行热替换，保证了应用状态不会丢失，提升了开发效率。</p>
</li>
<li><p>在古老的开发流程中，我们可能需要手动运行命令对代码进行打包，并且打包后再手动刷新浏览器页面，而这一系列重复的工作都可以通过 HMR 工作流来自动化完成，让更多的精力投入到业务中，而不是把时间浪费在重复的工作上。</p>
</li>
<li><p>HMR 兼容市面上大多前端框架或库，比如 <a target="_blank" rel="noopener" href="https://github.com/gaearon/react-hot-loader">React Hot Loader</a>，<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-loader">Vue-loader</a>，能够监听 React 或者 Vue 组件的变化，实时将最新的组件更新到浏览器端。Elm Hot Loader 支持通过 webpack 对 Elm 语言代码进行转译并打包，当然它也实现了 HMR 功能。</p>
</li>
</ul>
<h2><span id="hmr-的工作原理图解">HMR 的工作原理图解</span></h2><p>初识 HMR 的时候觉得其很神奇，一直有一些疑问萦绕在脑海。</p>
<ul>
<li><p>webpack 可以将不同的模块打包成 bundle 文件或者几个 chunk 文件，但是当我通过 webpack HMR 进行开发的过程中，我并没有在我的 dist 目录中找到 webpack 打包好的文件，它们去哪呢？</p>
</li>
<li><p>通过查看 webpack-dev-server 的 package.json 文件，我们知道其依赖于 webpack-dev-middleware 库，那么 webpack-dev-middleware 在 HMR 过程中扮演什么角色？</p>
</li>
<li><p>使用 HMR 的过程中，通过 Chrome 开发者工具我知道浏览器是通过 websocket 和 webpack-dev-server 进行通信的，但是 websocket 的 message 中并没有发现新模块代码。打包后的新模块又是通过什么方式发送到浏览器端的呢？为什么新的模块不通过 websocket 随消息一起发送到浏览器端呢？</p>
</li>
<li><p>浏览器拿到最新的模块代码，HMR 又是怎么将老的模块替换成新的模块，在替换的过程中怎样处理模块之间的依赖关系？</p>
</li>
<li><p>当模块的热替换过程中，如果替换模块失败，有什么回退机制吗？</p>
</li>
</ul>
<p>带着上面的问题，于是决定深入到 webpack 源码，寻找 HMR 底层的奥秘。</p>
<p><img src="/img/webpack-optimization/HMR1.png" alt="webpack-optimization"></p>
<p>图一：HMR 工作流程图解</p>
<p>上图是<code>webpack</code> 配合 <code>webpack-dev-server</code> 进行应用开发的模块热更新流程图。</p>
<p>上图底部红色框内是服务端，而上面的橙色框是浏览器端。</p>
<p>绿色的方框是 <code>webpack</code> 代码控制的区域。蓝色方框是 <code>webpack-dev-server</code> 代码控制的区域，洋红色的方框是文件系统，文件修改后的变化就发生在这，而青色的方框是应用本身。</p>
<p>上图显示了我们修改代码到模块热更新完成的一个周期，通过深绿色的阿拉伯数字符号已经将 HMR 的整个过程标识了出来。</p>
<ul>
<li><p>第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</p>
</li>
<li><p>第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</p>
</li>
<li><p>第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</p>
</li>
<li><p>第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</p>
</li>
</ul>
<p><code>webpack-dev-server/client</code> 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 <code>webpack</code> ，<code>webpack/hot/dev-server</code> 的工作就是根据<br><code>webpack-dev-server/client</code> 传给它的信息以及 <code>dev-server</code> 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</p>
<p><code>HotModuleReplacement.runtime</code> 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</p>
<p>而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</p>
<p>最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</p>
<h2><span id="运用-hmr-的简单例子">运用 HMR 的简单例子</span></h2><p>在上一个部分，通过一张 HMR 流程图，简要的说明了 HMR 进行模块热更新的过程。当然你可能感觉还是很迷糊，对上面出现的一些英文名词也可能比较陌生（上面这些英文名词代表着代码仓库或者仓库中的文件模块），没关系，在这一部分，我将通过一个最简单最纯粹的例子，通过分析 wepack及 webpack-dev-server 源码详细说明各个库在 HMR 过程中的具体职责。</p>
<p>这边我通过一个简单的vue例子示例一下，这边贴一个仓库的连接<a target="_blank" rel="noopener" href="https://github.com/ikkkp/webpack-vue-demo">github.com&#x2F;ikkkp&#x2F;webpack-vue-demo</a></p>
<p>在开始这个例子之前简单对这个仓库文件进行下说明，仓库中包含文件如下：</p>
<p><img src="/img/webpack-optimization/HMR5.jpg" alt="webpack-optimization"></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
    VueLoaderPlugin
<span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue-loader'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 引入 webpack</span>
<span class="token keyword">const</span> AutoImport <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'unplugin-auto-import/webpack'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> Components <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'unplugin-vue-components/webpack'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
    ElementPlusResolver
<span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'unplugin-vue-components/resolvers'</span><span class="token punctuation">)</span>

<span class="token comment">/**
* @description 
* @version 1.0
* @author Huangzl
* @fileName webpack.base.config.js
* @date 2023/11/10 11:00:59
*/</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        <span class="token literal-property property">main</span><span class="token operator">:</span> <span class="token string">'./src/main'</span><span class="token punctuation">,</span>
        <span class="token comment">//单页应用开发模式禁用多入口</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">resolveLoader</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        <span class="token literal-property property">modules</span><span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token string">'node_modules'</span><span class="token punctuation">,</span>
            path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./src/loader'</span><span class="token punctuation">)</span>
        <span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'[id].[fullhash].js'</span><span class="token punctuation">,</span> <span class="token comment">// 使用 [fullhash] 替代 [hash]，这是新版本 webpack 的写法</span>
        <span class="token literal-property property">path</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token literal-property property">publicPath</span><span class="token operator">:</span> <span class="token string">'./'</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>
            <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.vue$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
            <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'vue-loader'</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span>
            <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
            <span class="token literal-property property">use</span><span class="token operator">:</span> <span class="token punctuation">[</span>
                <span class="token string">'style-loader'</span><span class="token punctuation">,</span>
                <span class="token punctuation">&#123;</span>
                    <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>
                    <span class="token literal-property property">options</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
                        <span class="token literal-property property">importLoaders</span><span class="token operator">:</span> <span class="token number">1</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
                <span class="token string">'postcss-loader'</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
            <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
            <span class="token literal-property property">use</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'babel-loader'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
                <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'company-loader'</span><span class="token punctuation">,</span>
                <span class="token literal-property property">options</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
                    <span class="token literal-property property">sign</span><span class="token operator">:</span> <span class="token string">'we-doctor@2021'</span><span class="token punctuation">,</span>
                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token literal-property property">exclude</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">node_modules</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span>
            <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(ico|png|jpg|gif|svg|eot|woff|woff2|ttf)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
            <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'file-loader'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">options</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
                <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'[name].[ext]?[hash]'</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

        <span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

    <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
            <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'./public/index.html'</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">VueLoaderPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
            <span class="token constant">BASE_URL</span><span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">'./'</span><span class="token punctuation">)</span> <span class="token comment">// 这里定义了 BASE_URL 为根路径 '/'</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">AutoImport</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
            <span class="token literal-property property">resolvers</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">ElementPlusResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">Components</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
            <span class="token literal-property property">resolvers</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">ElementPlusResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token literal-property property">optimization</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        <span class="token literal-property property">splitChunks</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
            <span class="token literal-property property">chunks</span><span class="token operator">:</span> <span class="token string">'all'</span><span class="token punctuation">,</span> <span class="token comment">// 只处理异步模块</span>
            <span class="token literal-property property">maxSize</span><span class="token operator">:</span> <span class="token number">20000000</span><span class="token punctuation">,</span> <span class="token comment">// 设置最大的chunk大小为2MB</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>值得一提的是，在上面的配置中并没有配置 HotModuleReplacementPlugin，原因在于当我们设置 devServer.hot 为 true 后，并且在package.json 文件中添加如下的 script 脚本：</p>
<blockquote>
<p>“start”: “webpack-dev-server –hot –open”</p>
</blockquote>
<p>添加 —hot 配置项后，devServer 会告诉 webpack 自动引入 HotModuleReplacementPlugin 插件，而不用我们再手动引入了。</p>
<p>上面给的是webpack.base.config.js的内容，我们下面通过修改App.vue的内容进行:</p>
<blockquote>
<p>- &lt;div&gt;hello&lt;&#x2F;div&gt; &#x2F;&#x2F; 将 hello 字符串修改为 hello world<br>  + &lt;div&gt;hello world&lt;&#x2F;div&gt; </p>
</blockquote>
<p><strong>第一步：webpack 对文件系统进行 watch 打包到内存中</strong></p>
<p>webpack-dev-middleware 调用 webpack 的 api 对文件系统 watch，当 hello.js 文件发生改变后，webpack 重新对文件进行编译打包，然后保存到内存中。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// webpack-dev-middleware/lib/Shared.js</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> watching <span class="token operator">=</span> compiler<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>watchOptions<span class="token punctuation">,</span> share<span class="token punctuation">.</span>handleCompilerCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">.</span>watching <span class="token operator">=</span> watching<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>你可能会疑问了，为什么 webpack 没有将文件直接打包到 output.path 目录下呢？文件又去了哪儿？原来 webpack 将 bundle.js 文件打包到了内存中，不生成文件的原因就在于访问内存中的代码比访问文件系统中的文件更快，而且也减少了代码写入文件的开销，这一切都归功于memory-fs，memory-fs 是 webpack-dev-middleware 的一个依赖库，webpack-dev-middleware 将 webpack 原本的 outputFileSystem 替换成了MemoryFileSystem 实例，这样代码就将输出到内存中。webpack-dev-middleware 中该部分源码如下：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// webpack-dev-middleware/lib/Shared.js</span>
<span class="token keyword">var</span> isMemoryFs <span class="token operator">=</span> <span class="token operator">!</span>compiler<span class="token punctuation">.</span>compilers <span class="token operator">&amp;&amp;</span> compiler<span class="token punctuation">.</span>outputFileSystem <span class="token keyword">instanceof</span> <span class="token class-name">MemoryFileSystem</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>isMemoryFs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fs <span class="token operator">=</span> compiler<span class="token punctuation">.</span>outputFileSystem<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    fs <span class="token operator">=</span> compiler<span class="token punctuation">.</span>outputFileSystem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MemoryFileSystem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先判断当前 fileSystem 是否已经是 MemoryFileSystem 的实例，如果不是，用 MemoryFileSystem 的实例替换 compiler 之前的 outputFileSystem。这样 bundle.js 文件代码就作为一个简单 javascript 对象保存在了内存中，当浏览器请求 bundle.js 文件时，devServer就直接去内存中找到上面保存的 javascript 对象返回给浏览器端。</p>
<p><strong>第二步：devServer 通知浏览器端文件发生改变</strong></p>
<p>在这一阶段，sockjs 是服务端和浏览器端之间的桥梁，在启动 devServer 的时候，sockjs 在服务端和浏览器端建立了一个 webSocket 长连接，以便将 webpack 编译和打包的各个阶段状态告知浏览器，最关键的步骤还是 webpack-dev-server 调用 webpack api 监听 compile的 done 事件，当compile 完成后，webpack-dev-server通过 _sendStatus 方法将编译打包后的新模块 hash 值发送到浏览器端。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// webpack-dev-server/lib/Server.js</span>
compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">stats</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// stats.hash 是最新打包文件的 hash 值</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_sendStats</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sockets<span class="token punctuation">,</span> stats<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>clientStats<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_stats <span class="token operator">=</span> stats<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">...</span>
<span class="token class-name">Server</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_sendStats</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">sockets<span class="token punctuation">,</span> stats<span class="token punctuation">,</span> force</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>force <span class="token operator">&amp;&amp;</span> stats <span class="token operator">&amp;&amp;</span>
  <span class="token punctuation">(</span><span class="token operator">!</span>stats<span class="token punctuation">.</span>errors <span class="token operator">||</span> stats<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stats<span class="token punctuation">.</span>assets <span class="token operator">&amp;&amp;</span>
  stats<span class="token punctuation">.</span>assets<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token parameter">asset</span> <span class="token operator">=></span> <span class="token operator">!</span>asset<span class="token punctuation">.</span>emitted<span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sockWrite</span><span class="token punctuation">(</span>sockets<span class="token punctuation">,</span> <span class="token string">'still-ok'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
  <span class="token comment">// 调用 sockWrite 方法将 hash 值通过 websocket 发送到浏览器端</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sockWrite</span><span class="token punctuation">(</span>sockets<span class="token punctuation">,</span> <span class="token string">'hash'</span><span class="token punctuation">,</span> stats<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>stats<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sockWrite</span><span class="token punctuation">(</span>sockets<span class="token punctuation">,</span> <span class="token string">'errors'</span><span class="token punctuation">,</span> stats<span class="token punctuation">.</span>errors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> 
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>stats<span class="token punctuation">.</span>warnings<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sockWrite</span><span class="token punctuation">(</span>sockets<span class="token punctuation">,</span> <span class="token string">'warnings'</span><span class="token punctuation">,</span> stats<span class="token punctuation">.</span>warnings<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>      <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sockWrite</span><span class="token punctuation">(</span>sockets<span class="token punctuation">,</span> <span class="token string">'ok'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>第三步：webpack-dev-server&#x2F;client 接收到服务端消息做出响应</strong></p>
<p>可能你又会有疑问，我并没有在业务代码里面添加接收 websocket 消息的代码，也没有在 webpack.config.js 中的 entry 属性中添加新的入口文件，那么 bundle.js 中接收 websocket 消息的代码从哪来的呢？原来是 webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。</p>
<p>webpack-dev-server&#x2F;client 当接收到 type 为 hash 消息后会将 hash 值暂存起来，当接收到 type 为 ok 的消息后对应用执行 reload 操作，如下图所示，hash 消息是在 ok 消息之前。</p>
<p><img src="/img/webpack-optimization/HMR3.jpg" alt="webpack-optimization"></p>
<p>在 reload 操作中，webpack-dev-server&#x2F;client 会根据 hot 配置决定是刷新浏览器还是对代码进行热更新（HMR）。</p>
<p>首先将 hash 值暂存到 currentHash 变量，当接收到 ok 消息后，对 App 进行 reload。如果配置了模块热更新，就调用 webpack&#x2F;hot&#x2F;emitter 将最新 hash 值发送给 webpack，然后将控制权交给 webpack 客户端代码。如果没有配置模块热更新，就直接调用 location.reload 方法刷新页面。</p>
<p><strong>第四步：webpack 接收到最新 hash 值验证并请求模块代码</strong></p>
<p>在这一步，其实是 webpack 中三个模块（三个文件，后面英文名对应文件路径）之间配合的结果，首先是 <code>webpack/hot/dev-server</code>（以下简称 dev-server） 监听第三步 <code>webpack-dev-server/client</code> 发送的 <code>webpackHotUpdate</code> 消息，调用 webpack&#x2F;lib&#x2F;HotModuleReplacement.runtime（简称 HMR runtime）中的 check 方法，检测是否有新的更新，在 check 过程中会利用 webpack&#x2F;lib&#x2F;JsonpMainTemplate.runtime（简称 jsonp runtime）中的两个方法 <code>hotDownloadUpdateChunk</code> 和 <code>hotDownloadManifest</code> ， 第二个方法是调用 AJAX 向服务端请求是否有更新的文件，如果有将发更新的文件列表返回浏览器端，而第一个方法是通过 jsonp 请求最新的模块代码，然后将代码返回给 <code>HMR runtime</code>，<code>HMR runtime</code> 会根据返回的新模块代码做进一步处理，可能是刷新页面，也可能是对模块进行热更新。</p>
<p><img src="/img/webpack-optimization/HMR4.jpg" alt="webpack-optimization"></p>
<p>值得注意的是，两次请求的都是使用上一次的 hash 值拼接的请求文件名，hotDownloadManifest 方法返回的是最新的 hash 值，hotDownloadUpdateChunk 方法返回的就是最新 hash 值对应的代码块。然后将新的代码块返回给 HMR runtime，进行模块热更新</p>
<p><strong>第五步：HotModuleReplacement.runtime 对模块进行热更新</strong></p>
<p>这一步是整个模块热更新（HMR）的关键步骤，而且模块热更新都是发生在HMR runtime 中的 hotApply 方法中</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// webpack/lib/HotModuleReplacement.runtime</span>
<span class="token keyword">function</span> <span class="token function">hotApply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">var</span> idx<span class="token punctuation">;</span>
    <span class="token keyword">var</span> queue <span class="token operator">=</span> outdatedModules<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        moduleId <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        module <span class="token operator">=</span> installedModules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
        <span class="token comment">// remove module from cache</span>
        <span class="token keyword">delete</span> installedModules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// when disposing there is no need to call dispose handler</span>
        <span class="token keyword">delete</span> outdatedDependencies<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// remove "parents" references from all children</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> module<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">var</span> child <span class="token operator">=</span> installedModules<span class="token punctuation">[</span>module<span class="token punctuation">.</span>children<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>child<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
            idx <span class="token operator">=</span> child<span class="token punctuation">.</span>parents<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>moduleId<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>idx <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                child<span class="token punctuation">.</span>parents<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// insert new code</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>moduleId <span class="token keyword">in</span> appliedUpdate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>appliedUpdate<span class="token punctuation">,</span> moduleId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            modules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span> <span class="token operator">=</span> appliedUpdate<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面 hotApply 方法可以看出，模块热替换主要分三个阶段，第一个阶段是找出 <code>outdatedModules</code> 和 <code>outdatedDependencies</code>，这儿我没有贴这部分代码，有兴趣可以自己阅读源码。第二个阶段从缓存中删除过期的模块和依赖，如下：</p>
<blockquote>
<p>delete installedModules[moduleId];<br>  delete outdatedDependencies[moduleId];</p>
</blockquote>
<p>第三个阶段是将新的模块添加到 modules 中，当下次调用 <strong>webpack_require</strong> (webpack 重写的 require 方法)方法的时候，就是获取到了新的模块代码了。</p>
<p>模块热更新的错误处理，如果在热更新过程中出现错误，热更新将回退到刷新浏览器，这部分代码在 dev-server 代码中，简要代码如下：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">check</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">updatedModules</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>updatedModules<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> status <span class="token operator">=</span> module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"abort"</span><span class="token punctuation">,</span> <span class="token string">"fail"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        window<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>dev-server 先验证是否有更新，没有代码更新的话，重载浏览器。如果在 hotApply 的过程中出现 abort 或者 fail 错误，也进行重载浏览器。</p>
<p><img src="/img/webpack-optimization/2-core.jpg" alt="webpack-optimization"></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2023/11/09/hadoop-4/" itemprop="url">Hadoop 2.0体系架构之分布式文件系统Yarn</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2023-11-09T04:28:01.000Z" itemprop="datePublished">2023年11月9日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Hadoop/">Hadoop</a><span>></span><a class="article-category-link" href="/categories/Hadoop/Cloud-Computing/">Cloud-Computing</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2><span id="hadoop-yarn-是什么">Hadoop Yarn 是什么</span></h2><p>在古老的 Hadoop1.0 中，MapReduce 的 JobTracker 负责了太多的工作，包括资源调度，管理众多的 TaskTracker 等工作。这自然是不合理的，于是 Hadoop 在 1.0 到 2.0 的升级过程中，便将 JobTracker 的资源调度工作独立了出来，而这一改动，直接让 Hadoop 成为大数据中最稳固的那一块基石。，而这个独立出来的资源管理框架，就是 Yarn 。</p>
<p>在详细介绍 Yarn 之前，我们先简单聊聊 Yarn ，Yarn 的全称是  <strong>Yet Another Resource Negotiator</strong> ，意思是“另一种资源调度器”，这种命名和“有间客栈”这种可谓是异曲同工之妙。这里多说一句，以前 Java 有一个项目编译工具，叫做 Ant，他的命名也是类似的，叫做 “Another Neat Tool”的缩写，翻译过来是“另一种整理工具”。</p>
<p>既然都叫做资源调度器了，那么自然，它的功能也是负责资源管理和调度的，接下来，我们就深入到 Yarn 这个东西内部一探究竟吧。</p>
<h2><span id="yarn-架构">Yarn 架构</span></h2><p><img src="/img/yarn-pkg/Yarn1.png" alt="hadoop-Yarn"></p>
<p>① Client：客户端，负责向集群提交作业。</p>
<p>② ResourceManager：集群主进程，仲裁中心，负责集群资源管理和任务调度。</p>
<p>③ Scheduler：资源仲裁模块。</p>
<p>④ ApplicationManager：选定，启动和监管ApplicationMaster。</p>
<p>⑤ NodeManager：集群从进程，管理监视Containers，执行具体任务。</p>
<p>⑥ Container：本机资源集合体，如某Container为4个CPU，8GB内存。</p>
<p>⑦ ApplicationMaster：任务执行和监管中心。</p>
<h3><span id="三个主要组件">三个主要组件</span></h3><p>再看最上面的图，我们能直观发现的两个主要的组件是 <code>ResourceManager</code> 和 <code>NodeManager</code> ，但其实还有一个 <code>ApplicationMaster</code> 在图中没有直观显示。我们分别来看这三个组件。</p>
<h4><span id="resourcemanager">ResourceManager</span></h4><p>我们先来说说上图中最中央的那个 ResourceManager（RM）。从名字上我们就能知道这个组件是负责资源管理的，整个系统有且只有一个 RM ，来负责资源的调度。</p>
<p>它也包含了两个主要的组件：<code>定时调用器(Scheduler)</code>以及<code>应用管理器(ApplicationManager)</code>。</p>
<p><code>定时调度器(Scheduler)</code>：从本质上来说，定时调度器就是一种策略，或者说一种算法。当 Client 提交一个任务的时候，它会根据所需要的资源以及当前集群的资源状况进行分配。注意，它只负责向应用程序分配资源，并不做监控以及应用程序的状态跟踪。</p>
<p><code>应用管理器(ApplicationManager)</code>：同样，听名字就能大概知道它是干嘛的。应用管理器就是负责管理 Client 用户提交的应用。上面不是说到定时调度器（Scheduler）不对用户提交的程序监控嘛，其实啊，监控应用的工作正是由应用管理器（ApplicationManager）完成的。</p>
<h4><span id="applicationmaster">ApplicationMaster</span></h4><p>每当 Client 提交一个 Application 时候，就会新建一个 ApplicationMaster 。由这个 ApplicationMaster 去与 ResourceManager 申请容器资源，获得资源后会将要运行的程序发送到容器上启动，然后进行分布式计算。</p>
<p>这里可能有些难以理解，为什么是把运行程序发送到容器上去运行？如果以传统的思路来看，是程序运行着不动，然后数据进进出出不停流转。但当数据量大的时候就没法这么玩了，因为海量数据移动成本太大，时间太长。但是中国有一句老话山不过来，我就过去。大数据分布式计算就是这种思想，既然大数据难以移动，那我就把容易移动的应用程序发布到各个节点进行计算呗，这就是大数据分布式计算的思路。</p>
<h4><span id="nodemanager">NodeManager</span></h4><p>NodeManager 是 ResourceManager 在每台机器的上代理，负责容器的管理，并监控他们的资源使用情况（cpu，内存，磁盘及网络等），以及向 ResourceManager&#x2F;Scheduler 提供这些资源使用报告。</p>
<p>Yarn的主要思想是将MRv1版JobTracker的两大功能——资源管理和任务调度，拆分成两个独立的进程：</p>
<p><img src="/img/yarn-pkg/Yarn2.png" alt="hadoop-Yarn"></p>
<ul>
<li><p>Yarn依旧是master&#x2F;slave结构</p>
</li>
<li><p>主进程ResourceManager是整个集群资源仲裁中心</p>
</li>
<li><p>从进程NodeManager管理本机资源</p>
</li>
<li><p>ResourceManager和从属节点的进程NodeManager组成了Hadoop 2.0的分布式数据计算框架</p>
</li>
</ul>
<h2><span id="提交一个-application-到-yarn-的流程">提交一个 Application 到 Yarn 的流程</span></h2><p><img src="/img/yarn-pkg/Yarn3.webp" alt="hadoop-Yarn"></p>
<p>这张图简单地标明了提交一个程序所经历的流程，接下来我们来具体说说每一步的过程。</p>
<ul>
<li><p>Client 向 Yarn 提交 Application，这里我们假设是一个 MapReduce 作业。</p>
</li>
<li><p>ResourceManager 向 NodeManager 通信，为该 Application 分配第一个容器。并在这个容器中运行这个应用程序对应的 ApplicationMaster。</p>
</li>
<li><p>ApplicationMaster 启动以后，对 作业（也就是 Application） 进行拆分，拆分 task 出来，这些 task 可以运行在一个或多个容器中。然后向<br>ResourceManager 申请要运行程序的容器，并定时向 ResourceManager 发送心跳。</p>
</li>
<li><p>申请到容器后，ApplicationMaster 会去和容器对应的 NodeManager 通信，而后将作业分发到对应的 NodeManager 中的容器去运行，这里会将拆分后的 MapReduce 进行分发，对应容器中运行的可能是 Map 任务，也可能是 Reduce 任务。</p>
</li>
<li><p>容器中运行的任务会向 ApplicationMaster 发送心跳，汇报自身情况。当程序运行完成后， ApplicationMaster 再向 ResourceManager 注销并释放容器资源。<br>以上就是一个作业的大体运行流程。</p>
</li>
</ul>
<p><img src="/img/yarn-pkg/Yarn4.png" alt="hadoop-Yarn"></p>
<h2><span id="yarn-架构典型拓扑">Yarn 架构典型拓扑</span></h2><p>除了<code>ResourceManager</code>和<code>NodeManager</code>两个实体外，Yarn还包括<code>WebAppProxyServer</code>和<code>JobHistoryServer</code>两个实体。</p>
<p><img src="/img/yarn-pkg/Yarn5.png" alt="hadoop-Yarn"></p>
<p><code>JobHistoryServer</code>：管理已完成的Yarn任务</p>
<ul>
<li>历史任务的日志和执行时的各种统计信息统一由JobTracker管理</li>
<li>Yarn将管理历史任务的功能抽象成一独立实体JobHistoryServer</li>
</ul>
<p><code>WebAppProxyServer</code>：任务执行时的Web页面代理</p>
<ul>
<li>通过使用代理，不仅进一步降低了ResourceManager的压力，还能降低Yarn受到的Web攻击</li>
<li>负责监管具体MapReduce任务执行全过程，将从Container那里收集过的任务执行信息汇总并显示到一个Web界面上</li>
</ul>
<h2><span id="yarn-调度策略">Yarn 调度策略</span></h2><p><strong>容量调度算法</strong><br><code>CapacityScheduler</code>是一种多用户多任务调度策略，它以队列为单位划分任务，以<code>Container</code>为单位分配资源</p>
<p><img src="/img/yarn-pkg/Yarn7.png" alt="hadoop-Yarn"></p>
<p><strong>公平调度策略</strong><br><code>FairScheduler</code>是一种允许多个<code>Yarn</code>任务公平使用集群资源的可插拔式调度策略</p>
<p><img src="/img/yarn-pkg/Yarn8.png" alt="hadoop-Yarn"></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2023/11/09/hadoop-3/" itemprop="url">Hadoop 2.0体系架构之分布式文件系统HDFS</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2023-11-09T02:45:27.000Z" itemprop="datePublished">2023年11月9日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Hadoop/">Hadoop</a><span>></span><a class="article-category-link" href="/categories/Hadoop/Cloud-Computing/">Cloud-Computing</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2><span id="hdfs设计原则">HDFS设计原则</span></h2><h3><span id="设计目标">设计目标</span></h3><p><strong>存储非常大的文件：这里非常大指的是几百M、G、或者TB级别。</strong></p>
<ul>
<li><p>采用流式的数据访问方式: HDFS基于这样的一个假设：最有效的数据处理模式是一次写入、多次读取数据集经常从数据源生成或者拷贝一次，然后在其上做很多分析工作<br>分析工作经常读取其中的大部分数据，即使不是全部。 因此读取整个数据集所需时间比读取第一条记录的延时更重要。</p>
</li>
<li><p>运行于商业硬件上: Hadoop不需要特别贵的、reliable的（可靠的）机器，可运行于普通商用机器（可以从多家供应商采购） ，商用机器不代表低端机器。在集群中（尤其是大的集群），节点失败率是比较高的HDFS的目标是确保集群在节点失败的时候不会让用户感觉到明显的中断。</p>
</li>
</ul>
<h3><span id="hdfs不适合的应用类型">HDFS不适合的应用类型</span></h3><p>有些场景不适合使用HDFS来存储数据。下面列举几个：</p>
<ol>
<li><p><strong>低延时的数据访问</strong><br>对延时要求在毫秒级别的应用，不适合采用HDFS。HDFS是为高吞吐数据传输设计的,因此可能牺牲延时HBase更适合低延时的数据访问。</p>
</li>
<li><p><strong>大量小文件</strong><br>文件的元数据（如目录结构，文件block的节点列表，<code>block-node mapping</code>）保存在NameNode的内存中， 整个文件系统的文件数量会受限于NameNode的内存大小。<br>经验而言，一个文件&#x2F;目录&#x2F;文件块一般占有150字节的元数据内存空间。如果有100万个文件，每个文件占用1个文件块，则需要大约300M的内存。因此十亿级别的文件数量在现有商用机器上难以支持。</p>
</li>
<li><p><strong>多方读写，需要任意的文件修改</strong><br>HDFS采用追加（append-only）的方式写入数据。不支持文件任意offset的修改。不支持多个写入器（writer）</p>
</li>
</ol>
<h2><span id="hdfs定位">HDFS定位</span></h2><p>为提高扩展性，HDFS采用了master&#x2F;slave架构来构建分布式存储集群，这种架构很容易向集群中任意添加或删除slave。</p>
<p>HDFS是Hadoop生态系统中的一个重要组件，它是一个分布式文件系统，旨在存储大量数据，并提供高吞吐量的数据访问。HDFS的设计目标是将数据存储在廉价的硬件上，并提供高容错性。它通过将数据分散到集群中的多个节点上来实现这一目标。HDFS的定位是作为一个批处理系统，适用于大规模数据的离线处理。</p>
<p>HDFS的主要特点包括：</p>
<ul>
<li>高容错性：HDFS将数据分散到多个节点上，因此即使某个节点出现故障，数据仍然可以通过其他节点进行访问。</li>
<li>高吞吐量：HDFS的设计目标是支持大规模数据的批处理，因此它提供了高吞吐量的数据访问。</li>
<li>适用于大文件：HDFS适用于存储大文件，因为它将文件分成多个块进行存储，并将这些块分散到多个节点上。</li>
<li>流式数据访问：HDFS支持流式数据访问，这意味着它可以高效地处理大量的数据流。</li>
</ul>
<p><img src="/img/HDFS/HDFS1.png" alt="hadoop-HDFS"></p>
<h2><span id="hdfs体系架构">HDFS体系架构</span></h2><p>HDFS采用master&#x2F;slave体系来构建分布式存储服务，提高了HDFS的可扩展性又简化了架构设计。<br>HDFS里将文件分块存储，优化存储颗粒度。namenode统一管理所有slave机器datanode存储空间，datanode以块为单位存储实际的数据。真正的文件I&#x2F;O操作时客户端直接和datanode交互。</p>
<h2><span id="hdfs核心概念">HDFS核心概念</span></h2><h3><span id="blocks">Blocks</span></h3><p>物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。</p>
<p>HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。</p>
<p>HDFS的Block为什么这么大？<br>是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M&#x2F;s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。<br>但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。</p>
<p>Block抽象的好处 </p>
<ul>
<li>Block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。 </li>
<li>Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。 </li>
<li>Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。</li>
</ul>
<h3><span id="namenode-amp-datanode">Namenode &amp; Datanode</span></h3><p>整个HDFS集群由Namenode和Datanode构成<code>master-worker（主从）</code>模式。Namenode负责构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。</p>
<h4><span id="namenode">Namenode</span></h4><p>Namenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式：</p>
<ul>
<li>namespace image</li>
<li>edit log</li>
</ul>
<p>但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。<br>在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： </p>
<ol>
<li><p>备份持久化元数据<br>将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。</p>
</li>
<li><p>Secondary Namenode<br>Secondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。下图为Secondary Namenode的管理界面：</p>
</li>
</ol>
<p><img src="/img/HDFS/HDFS2.jpg" alt="hadoop-HDFS"></p>
<p>Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。<br>在HA（High Availability高可用性）中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。</p>
<h4><span id="datanode">Datanode</span></h4><p>数据节点负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。</p>
<p><img src="/img/HDFS/HDFS3.jpg" alt="hadoop-HDFS"></p>
<h2><span id="经典hdfs体系架构">经典HDFS体系架构</span></h2><p><strong>NameNode负责管理文件系统的元数据信息，而DataNode则负责存储文件块的实际数据。</strong> 这种分工使得HDFS能够高效地存储和管理大规模数据。</p>
<p><img src="/img/HDFS/HDFS4.png" alt="hadoop-HDFS"></p>
<p>具体来说，当一个客户端需要读取或写入一个文件时，它会向NameNode发送请求。NameNode会返回文件的元数据信息和文件块的位置信息。客户端根据这些信息与DataNode进行通信，从而读取或写入文件块的实际数据。</p>
<p>因此，NameNode和DataNode在HDFS体系架构中扮演着不同的角色。</p>
<p>作用上的区别是什么？</p>
<p>HDFS是Hadoop分布式文件系统的缩写，是Hadoop生态系统中的一个重要组件。HDFS的体系架构包括一个NameNode和多个DataNode。NameNode是HDFS的主节点，负责管理文件系统的命名空间、文件的元数据信息以及文件块的位置信息。而DataNode则是HDFS的从节点，负责存储文件块的实际数据。</p>
<p><strong>具体来说，当一个客户端需要读取或写入一个文件时，它会向NameNode发送请求。NameNode会返回文件的元数据信息和文件块的位置信息。客户端根据这些信息与DataNode进行通信，从而读取或写入文件块的实际数据。</strong></p>
<p><img src="/img/HDFS/HDFS5.png" alt="hadoop-HDFS"></p>
<h3><span id="一般拓扑">一般拓扑</span></h3><p>只有单个NameNode节点，使用SecondaryNameNode或BackupNode节点实时获取NameNode元数据信息，备份元数据。</p>
<p><img src="/img/HDFS/HDFS6.png" alt="hadoop-HDFS"></p>
<h3><span id="商用拓扑">商用拓扑</span></h3><p>有两个NameNode节点，并使用ZooKeeper实现NameNode节点间的热切换。</p>
<p><img src="/img/HDFS/HDFS7.png" alt="hadoop-HDFS"></p>
<h2><span id="命令行接口">命令行接口</span></h2><p>HDFS提供了各种交互方式，例如通过Java API、HTTP、shell命令行的。命令行的交互主要通过hadoop fs来操作。例如：</p>
<blockquote>
<p>hadoop fs -copyFromLocal &#x2F;&#x2F; 从本地复制文件到HDFS<br> hadoop fs mkdir &#x2F;&#x2F; 创建目录<br> hadoop fs -ls  &#x2F;&#x2F; 列出文件列表</p>
</blockquote>
<p>Hadoop中，文件和目录的权限类似于POSIX模型，包括读、写、执行3种权限：</p>
<p>读权限（r）：用于读取文件或者列出目录中的内容<br>写权限（w）：对于文件，就是文件的写权限。目录的写权限指在该目录下创建或者删除文件（目录）的权限。<br>执行权限（x）：文件没有所谓的执行权限，被忽略。对于目录，执行权限用于访问器目录下的内容。</p>
<p>每个文件或目录都有owner，group，mode三个属性:</p>
<p>owner：指文件的所有者<br>group：为权限组<br>mode：由所有者权限、文件所属的组中组员的权限、非所有者非组员的权限组成。</p>
<p><img src="/img/HDFS/HDFS8.jpg" alt="hadoop-HDFS"></p>
<h2><span id="数据流读写流程">数据流（读写流程）</span></h2><h3><span id="读文件">读文件</span></h3><p>大致读文件的流程如下：</p>
<p><img src="/img/HDFS/HDFS9.png" alt="hadoop-HDFS"></p>
<ol>
<li><p>客户端传递一个文件Path给FileSystem的open方法</p>
</li>
<li><p>DFS采用RPC远程获取文件最开始的几个block的datanode地址。Namenode会根据网络拓扑结构决定返回哪些节点（前提是节点有block副本），如果客户端本身是Datanode并且节点上刚好有block副本，直接从本地读取。</p>
</li>
<li><p>客户端使用open方法返回的FSDataInputStream对象读取数据（调用read方法）</p>
</li>
<li><p>DFSInputStream（FSDataInputStream实现了改类）连接持有第一个block的、最近的节点，反复调用read方法读取数据</p>
</li>
<li><p>第一个block读取完毕之后，寻找下一个block的最佳datanode，读取数据。如果有必要，DFSInputStream会联系Namenode获取下一批Block 的节点信息（存放于内存，不持久化），这些寻址过程对客户端都是不可见的。</p>
</li>
<li><p>数据读取完毕，客户端调用close方法关闭流对象</p>
</li>
</ol>
<p>在读数据过程中，如果与Datanode的通信发生错误，DFSInputStream对象会尝试从下一个最佳节点读取数据，并且记住该失败节点， 后续Block的读取不会再连接该节点 </p>
<p>读取一个Block之后，DFSInputStram会进行检验和验证，如果Block损坏，尝试从其他节点读取数据，并且将损坏的block汇报给Namenode。 </p>
<p>客户端连接哪个datanode获取数据，是由namenode来指导的，这样可以支持大量并发的客户端请求，namenode尽可能将流量均匀分布到整个集群。 </p>
<p>Block的位置信息是存储在namenode的内存中，因此相应位置请求非常高效，不会成为瓶颈。</p>
<h3><span id="写文件">写文件</span></h3><p><img src="/img/HDFS/HDFS10.png" alt="hadoop-HDFS"></p>
<p>步骤分解 </p>
<ol>
<li><p>客户端调用DistributedFileSystem的create方法</p>
</li>
<li><p>DistributedFileSystem远程RPC调用Namenode在文件系统的命名空间中创建一个新文件，此时该文件没有关联到任何block。 这个过程中，Namenode会做很多校验工作，例如是否已经存在同名文件，是否有权限，如果验证通过，返回一个FSDataOutputStream对象。 如果验证不通过，抛出异常到客户端。</p>
</li>
<li><p>客户端写入数据的时候，DFSOutputStream分解为packets（数据包），并写入到一个数据队列中，该队列由DataStreamer消费。</p>
</li>
<li><p>DateStreamer负责请求Namenode分配新的block存放的数据节点。这些节点存放同一个Block的副本，构成一个管道。 DataStreamer将packet写入到管道的第一个节点，第一个节点存放好packet之后，转发给下一个节点，下一个节点存放 之后继续往下传递。</p>
</li>
<li><p>DFSOutputStream同时维护一个ack queue队列，等待来自datanode确认消息。当管道上的所有datanode都确认之后，packet从ack队列中移除。</p>
</li>
<li><p>数据写入完毕，客户端close输出流。将所有的packet刷新到管道中，然后安心等待来自datanode的确认消息。全部得到确认之后告知Namenode文件是完整的。 Namenode此时已经知道文件的所有Block信息（因为DataStreamer是请求Namenode分配block的），只需等待达到最小副本数要求，然后返回成功信息给客户端。</p>
</li>
</ol>
<p>Namenode如何决定副本存在哪个Datanode？</p>
<p>HDFS的副本的存放策略是可靠性、写带宽、读带宽之间的权衡。默认策略如下：</p>
<p>第一个副本放在客户端相同的机器上，如果机器在集群之外，随机选择一个（但是会尽可能选择容量不是太慢或者当前操作太繁忙的）</p>
<p>第二个副本随机放在不同于第一个副本的机架上。</p>
<p>第三个副本放在跟第二个副本同一机架上，但是不同的节点上，满足条件的节点中随机选择。</p>
<p>更多的副本在整个集群上随机选择，虽然会尽量避免太多副本在同一机架上。 </p>
<p>副本的位置确定之后，在建立写入管道的时候，会考虑网络拓扑结构。下面是可能的一个存放策略：</p>
<p><img src="/img/HDFS/HDFS11.png" alt="hadoop-HDFS"></p>
<p>这样选择很好的平衡了可靠性、读写性能</p>
<ul>
<li><p>可靠性：Block分布在两个机架上</p>
</li>
<li><p>写带宽：写入管道的过程只需要跨越一个交换机</p>
</li>
<li><p>读带宽：可以从两个机架中任选一个读取</p>
</li>
</ul>
<h2><span id="hdfs内部特性">HDFS内部特性</span></h2><h2><span id="数据冗余">数据冗余</span></h2><ul>
<li><p>HDFS将每个文件存储成一系列数据块（Block），默认块大小为64MB（可配置）。</p>
</li>
<li><p>为了容错，文件的所有数据块都会有副本（副本数量即复制因子，可配置）。</p>
</li>
<li><p>HDFS的文件都是一次性写入的，并且严格限制为任何时候都只有一个写用户。</p>
</li>
</ul>
<h2><span id="副本存放">副本存放</span></h2><ul>
<li><p>HDFS集群一般运行在多个机架上，不同机架上机器的通信需要通过交换机。</p>
</li>
<li><p>HDFS采用机架感知（Rack-aware）的策略来改进数据的可靠性、可用性和网络带宽的利用率。</p>
</li>
<li><p>机架的错误远比节点的错误少，这个策略可以防止整个机架失效时数据丢失，提高数据的可靠性和可用性，又能保证性能。</p>
</li>
</ul>
<h3><span id="副本选择">副本选择</span></h3><ul>
<li><p>HDFS会尽量使用离程序最近的副本来满足用户请求，这样可以减少总带宽消耗和读延时。</p>
</li>
<li><p>HDFS的架构支持数据均衡策略。</p>
</li>
</ul>
<h3><span id="心跳检测">心跳检测</span></h3><ul>
<li><p>NameNode周期性地从集群中的每个DataNode接受心跳包和块报告，收到心跳包说明该DataNode工作正常。</p>
</li>
<li><p>NameNode会标记最近没有心跳的DataNode为宕机，不会发给它们任何新的I&#x2F;O请求。</p>
</li>
<li><p>NameNode会不断检测这些需要复制的数据块，并在需要的时候重新复制。</p>
</li>
</ul>
<h3><span id="数据完整性检测">数据完整性检测</span></h3><ul>
<li><p>多种原因可能造成从DataNode获取的数据块有损坏。</p>
</li>
<li><p>HDFS客户端软件实现了对HDFS文件内容的校验和检查（Checksum）。</p>
</li>
<li><p>DataNode获得的数据块对应的校验和隐藏文件中的不同，客户端就会判定数据块有损坏，将从其他DataNode获取该数据块的副本。</p>
</li>
</ul>
<h3><span id="简单一致性模型-流式数据访问">简单一致性模型、流式数据访问</span></h3><ul>
<li><p>HDFS的应用程序一般对文件实行一次写、多次读的访问模式。</p>
</li>
<li><p>文件一旦创建、写入和关闭之后就不需要再更改了。</p>
</li>
<li><p>这样就简化了数据一致性问题，高吞吐量的数据访问才成为可能；运行在HDFS上的应用主要以流式读为主，做批量处理；更注重数据访问的高吞吐量。</p>
</li>
</ul>
<h3><span id="客户端缓存">客户端缓存</span></h3><ul>
<li><p>客户端创建文件的请求不是立即到达NameNode，HDFS客户端先把数据缓存到本地的一个临时文件，程序的写操作透明地重定向到这个临时文件。</p>
</li>
<li><p>当这个临时文件累积的数据超过一个块的大小（64MB）时，客户端才会联系NameNode。</p>
</li>
<li><p>如果NameNode在文件关闭之前死机，那么文件将会丢失。</p>
</li>
<li><p>如果不采用客户端缓存，网络速度和拥塞都会对输出产生很大的影响。</p>
</li>
</ul>

    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous is-invisible is-hidden-mobile">
        <a href="/archives/0/">上一頁</a>
    </div>
    <div class="pagination-next">
        <a href="/archives/2/">下一頁</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link is-current" href="/">1</a></li>
        
        <li><a class="pagination-link" href="/archives/2/">2</a></li>
        
        <li><a class="pagination-link" href="/archives/3/">3</a></li>
        
        <li><a class="pagination-link" href="/archives/4/">4</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2023 Huangzl&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ikkkp">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
<div class="column is-narrow has-text-centered">
    <div class="dropdown is-up is-right is-hoverable" style="margin-top: -0.2em;">
        <div class="dropdown-trigger">
            <button class="button is-small" aria-haspopup="true">
                <span class="icon">
                    <i class="fas fa-globe"></i>
                </span>
                <span>中文</span>
                <span class="icon is-small">
            <i class="fas fa-angle-down" aria-hidden="true"></i>
          </span>
            </button>
        </div>
        <div class="dropdown-menu has-text-left" role="menu" style="top:100%">
            <div class="dropdown-content">
            <!-- NOTE: 永遠回到首頁 -->
            
                <a href="/en/" class="dropdown-item">
                    English
                </a>
            
            </div>
        </div>
    </div>
</div>

        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>



    
    
    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="/js/script.js?v=3.js"></script>


    
</body>
</html>